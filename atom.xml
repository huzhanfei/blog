<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ByteLife</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-06-06T22:26:38.365Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Jeffrey Hu</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>语雀Markdown测试</title>
    <link href="http://yoursite.com/2020/06/07/yuque/%E8%AF%AD%E9%9B%80Markdown%E6%B5%8B%E8%AF%95/"/>
    <id>http://yoursite.com/2020/06/07/yuque/%E8%AF%AD%E9%9B%80Markdown%E6%B5%8B%E8%AF%95/</id>
    <published>2020-06-06T20:03:35.000Z</published>
    <updated>2020-06-06T22:26:38.365Z</updated>
    
    <content type="html"><![CDATA[<h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="这是一个列表"><a href="#这是一个列表" class="headerlink" title="这是一个列表"></a>这是一个列表</h3><ul><li>一个项目</li><li>两个项目</li></ul><a id="more"></a><h3 id="这是一段代码"><a href="#这是一段代码" class="headerlink" title="这是一段代码"></a>这是一段代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"hello world"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="这是一个表格"><a href="#这是一个表格" class="headerlink" title="这是一个表格"></a>这是一个表格</h3><table><thead><tr><th>标题</th><th>标题</th></tr></thead><tbody><tr><td>1</td><td>2</td></tr><tr><td>3</td><td>4</td></tr></tbody></table><h4 id="这是四级标题"><a href="#这是四级标题" class="headerlink" title="这是四级标题"></a>这是四级标题</h4>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;二级标题&quot;&gt;&lt;a href=&quot;#二级标题&quot; class=&quot;headerlink&quot; title=&quot;二级标题&quot;&gt;&lt;/a&gt;二级标题&lt;/h2&gt;&lt;h3 id=&quot;这是一个列表&quot;&gt;&lt;a href=&quot;#这是一个列表&quot; class=&quot;headerlink&quot; title=&quot;这是一个列表&quot;&gt;&lt;/a&gt;这是一个列表&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;一个项目&lt;/li&gt;
&lt;li&gt;两个项目&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>动态规划算法问题（经典找零案例）</title>
    <link href="http://yoursite.com/2017/03/20/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%AE%97%E6%B3%95%E9%97%AE%E9%A2%98%EF%BC%88%E7%BB%8F%E5%85%B8%E6%89%BE%E9%9B%B6%E6%A1%88%E4%BE%8B%EF%BC%89/"/>
    <id>http://yoursite.com/2017/03/20/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%AE%97%E6%B3%95%E9%97%AE%E9%A2%98%EF%BC%88%E7%BB%8F%E5%85%B8%E6%89%BE%E9%9B%B6%E6%A1%88%E4%BE%8B%EF%BC%89/</id>
    <published>2017-03-19T17:51:28.000Z</published>
    <updated>2020-06-06T22:26:01.821Z</updated>
    
    <content type="html"><![CDATA[<p>问题： 给定数组arr，arr中的所有的值都为正数且不重复。每个值代表一种面值的货币，每种面值的货币可以使用任意张，再给定一个整数aim代表要找的钱数，求换钱有多少种方法。</p><a id="more"></a><h2 id="暴力搜索方法"><a href="#暴力搜索方法" class="headerlink" title="暴力搜索方法"></a>暴力搜索方法</h2><h3 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h3><p>若给定arr={5, 10, 25, 1}，aim=1000。</p><ul><li>用0张5元的货币，让[10, 25, 1]组成剩下的1000元，最终方法数记作——res1；</li><li>用1张5元的货币，让[10, 25, 1]组成剩下的995元，最终方法数记作——res2；</li><li>用2张5元的货币，让[10, 25, 1]组成剩下的990元，最终方法数记作——res3；</li><li>用3张5元的货币，让[10, 25, 1]组成剩下的985元，最终方法数记作——res4；</li><li>……</li><li>用200张5元的货币，让[10, 25, 1]组成剩下的0元，最终方法数记作——res201；</li></ul><p>则res1、res2……res201的累加和即为最终的结果。</p><h3 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h3><p>定义递归函数：<code>int process1(arr, index, aim)</code>, 它的含义是如果用arr[index……N-1]这些面值的钱组成aim，返回总的方法数。</p><pre><code>public static int coins1(int[] arr, int aim) {    long startTime = System.currentTimeMillis();    if (arr == null || arr.length == 0 || aim &lt; 0) {        return 0;    }    int result = process1(arr,0,aim);    long endTime = System.currentTimeMillis();    System.out.println(&quot;暴力搜索方法所用时间：&quot; + (endTime - startTime) +&quot;ms&quot;);    return result;}public static int process1(int[] arr, int index, int aim) {    int res = 0;    // 判断是否所有面值的货币均已经计算完    if (index == arr.length) {        // 判断本次递归调用时钱的总数是否已经凑够，如果已经凑够则将总方法数加1        res = aim == 0 ? 1 : 0;     } else {         // 循环计算i张当前面值的货币        for (int i = 0; arr[index] * i &lt;= aim; i++) {            // 递归调用当使用i张当前面值的货币时，用其它货币组成剩下的钱            res += process1(arr, index + 1, aim - arr[index] * i);        }    }    return res;}</code></pre><p>暴力搜索方法比较好理解，但他在计算中存在大量的重复递归过程。 例如已经使用了0张5元和1张10元货币的情况下，后续将求： <code>process1(arr,2,990)</code> 而当计算使用2张5元和0张10元时，后续同样需要求： <code>process1(arr,2,990)</code> 因此这种重复的递归运算将造成大量的时间浪费。</p><h2 id="记忆搜索方法"><a href="#记忆搜索方法" class="headerlink" title="记忆搜索方法"></a>记忆搜索方法</h2><h3 id="思路分析-1"><a href="#思路分析-1" class="headerlink" title="思路分析"></a>思路分析</h3><p>由于暴力搜索方法中存在大量的重复递归，因此我们可以使用一个“记忆库”用于存储已经计算过的值，在本题中，使用index货币组成剩下的aim钱的值是一一对应的，因此可以使用int mem[index][aim]数组表示记忆库，其元素值为可以组成的方法数。</p><h3 id="具体实现-1"><a href="#具体实现-1" class="headerlink" title="具体实现"></a>具体实现</h3><ul><li><p>每计算完一个process(index,aim)，都将结果放入mem中，index和aim组成共同的key，返回结果为value。</p></li><li><p>要进入一个递归过程时，先以index和aim组成的key在mem中进行查询，如果已经存在value，则直接使用，如果不存在，再进入递归过程。</p><pre><code>public static int process2(int[] arr, int index, int aim, int[][] mem) {    int res = 0;    // 判断是否所有面值的货币均已经计算完    if (index == arr.length) {        // 判断本次递归调用时钱的总数是否已经凑够，如果已经凑够则将总方法数加1        res = aim == 0 ? 1 : 0;    } else {        int memVal = 0;        // 循环计算i张当前面值的货币        for (int i = 0; arr[index] * i &lt;= aim; i++) {            // 获取记忆库中当使用i张index货币时，用其它货币组成剩下的钱            memVal = mem[index + 1][aim - arr[index] * i];            // 判断记忆库中存在记录            if (memVal != 0) {                // 将记忆库中的方法数累加到结果中                res += memVal == -1 ? 0 : memVal;            } else {                // 递归调用当使用i张当前面值的货币时，用其它货币组成剩下的钱                res += process2(arr, index + 1, aim - arr[index] * i, mem);            }        }    }    // 将使用index货币组成aim钱的结果存储到记忆库中    mem[index][aim] = res == 0 ? -1 : res;    return res;}</code></pre></li></ul><h2 id="动态规划方法"><a href="#动态规划方法" class="headerlink" title="动态规划方法"></a>动态规划方法</h2><h3 id="思路分析-2"><a href="#思路分析-2" class="headerlink" title="思路分析"></a>思路分析</h3><p>如果arr长度为N，生成行数为N，列数为aim+1的矩阵dp。 dp[i][j]的含义是在使用arr[0]…arr[i]货币的情况下，组成钱数j的方法数。 <img data-src="https://cdn.javacodes.cn/files/2017/03/2017-03-19_17-51-32.jpg" alt="">￼</p><ol><li>如果完全不用arr[i]货币，只使用arr[0]…arr[i-1]货币时，方法数为dp[i-1][j]。</li><li>如果用1张arr[i]货币，剩下的钱使用arr[0]…arr[i-1]货币组成，方法数为dp[i-1][j-1*arr[i]]。</li><li>如果用2张arr[i]货币，剩下的钱使用arr[0]…arr[i-1]货币组成，方法数为dp[i-1][j-1*arr[i]]。</li><li>如果用3张arr[i]货币，剩下的钱使用arr[0]…arr[i-1]货币组成，方法数为dp[i-1][j-1*arr[i]]。</li><li>……</li></ol><p>dp[i][j]的值即为上述所有值得累加和。 求每一个位置都需要枚举，时间复杂度为O(aim)。dp一共有N*aim个位置，所以总的时间复杂度为O(N*aim2) 最终的结果值即为矩阵最右下角的dp[N-1][aim]。</p><h4 id="记忆搜索方法与动态规划方法的联系"><a href="#记忆搜索方法与动态规划方法的联系" class="headerlink" title="记忆搜索方法与动态规划方法的联系"></a>记忆搜索方法与动态规划方法的联系</h4><ul><li>记忆化搜索方法就是某种形态的动态规划方法。</li><li>记忆化搜索不关心到达某一个递归路径的路程。只是单纯地堆计算过的递归过程进行记录，避免重复递归的过程。</li><li>动态规划方法则是规定好每一个递归霍城的计算顺序，一次进行计算，后面的计算过程严格依赖前面的计算过程。</li><li>两者都是空间换时间的方法，也有枚举的过程，区别在于动态规划规定计算顺序，而记忆搜索不用规定。</li></ul><h4 id="什么是动态规划方法"><a href="#什么是动态规划方法" class="headerlink" title="什么是动态规划方法"></a>什么是动态规划方法</h4><ul><li>本质是利用申请的空间来记录每一个暴力搜索的计算过程，下次要用结果的时候直接使用，而不再进行重复的递归过程。</li><li>动态规划规定每一种递归状态的计算顺序，依次进行计算。从简单到复杂，按顺序计算。</li></ul><h3 id="具体实现-2"><a href="#具体实现-2" class="headerlink" title="具体实现"></a>具体实现</h3><pre><code>public static int process3(int[] arr, int aim) {    // 创建dp矩阵    int[][] dp = new int[arr.length][aim + 1];    for (int i = 0; i &lt; dp.length; i++) {        dp[i][0] = 1; // 凑成0元的方法必然是什么货币都不用，只有1种        if (i == 0) {            // 如果只是用arr[0]这一种货币，则能凑到j钱置1            for (int j = 0; j &lt; dp[i].length; j++) {                dp[i][j] = j % arr[i] == 0 ? 1 : 0;            }        } else {            for (int j = 1; j &lt; dp[i].length; j++) {                int temp = 0;                // 枚举使用k张arr[i]货币后dp[i-1]中组成剩下钱数的方法数                for (int k = 0; k * arr[i] &lt;= j; k++) {                    temp += dp[i - 1][j - k * arr[i]];//方法数累加                }                dp[i][j] = temp;            }        }    }    // 返回dp矩阵最右下角的值即为最后结果    return dp[arr.length - 1][aim];}</code></pre><h2 id="动态规划方法的再优化"><a href="#动态规划方法的再优化" class="headerlink" title="动态规划方法的再优化"></a>动态规划方法的再优化</h2><h3 id="思路分析-3"><a href="#思路分析-3" class="headerlink" title="思路分析"></a>思路分析</h3><p>由于动态规划方法的执行顺序有着严格的规定，因此使得对算法的进一步优化成为可能。 对于刚才的问题中，我们需要枚举<code>dp[i-1][j-k*arr[i]]</code>(k=1,2,3…)并与<code>dp[i-1][j]</code>累加，实际上<code>dp[i-1][j-k*arr[i]]</code>(k=1,2,3…)的累加值就是<code>dp[i][j-arr[i]]</code>。 <img data-src="https://cdn.javacodes.cn/files/2017/03/2017-03-19_17-51-32-2.jpg" alt="">￼ 所以可以简化为： <code>dp[i][j] = dp[i][j-arr[i]] + dp[i-1][j]</code> 从而彻底省略枚举过程。时间复杂度从O(N<em>aim2)变为O(N</em>aim)</p><h3 id="具体实现-3"><a href="#具体实现-3" class="headerlink" title="具体实现"></a>具体实现</h3><p>经过优化后的代码实现如下：</p><pre><code>public static int process4(int[] arr, int aim) {    // 创建dp矩阵    int[][] dp = new int[arr.length][aim + 1];    for (int i = 0; i &lt; dp.length; i++) {        dp[i][0] = 1; // 凑成0元的方法必然是什么货币都不用，只有1种        for (int j = 1; j &lt; dp[i].length; j++) {            if (i == 0) {                dp[i][j] = j % arr[i] == 0 ? 1 : 0;            } else if(j &gt;= arr[i]){                dp[i][j] = dp[i][j - arr[i]] + dp[i - 1][j];            } else {                dp[i][j] = dp[i - 1][j];            }        }    }    // 返回dp矩阵最右下角的值即为最后结果    return dp[arr.length - 1][aim];}</code></pre><h2 id="动态规划方法的空间优化"><a href="#动态规划方法的空间优化" class="headerlink" title="动态规划方法的空间优化"></a>动态规划方法的空间优化</h2><p>我们可以看到，经过优化的动态规划方法速度已经非常让人满意，但是它的空间浪费却很严重，我们发现动态规划方法是严格的矩阵从上至下、从左至右的方向顺序计算，那么其实真正每次计算式只需要用到的是当前行与当前行的上一行，因此其实我们可以将原本的dp二维矩阵简化为一维向量。 通过读取和修改向量本身的元素值来达到目的，修改后的代码如下所示：</p><pre><code>public static int process5(int[] arr, int aim) {    // 创建dp向量    int[] dp = new int[aim + 1];    for (int i = 0; i &lt; arr.length; i++) {        dp[0] = 1; // 凑成0元的方法必然是什么货币都不用，只有1种        for (int j = 1; j &lt; dp.length; j++) {            if (i == 0) {                dp[j] = j % arr[i] == 0 ? 1 : 0;            } else if(j &gt;= arr[i]){                dp[j] += dp[j - arr[i]];            }        }    }    // 返回dp向量尾元素即最终结果    return dp[aim];}</code></pre><h2 id="各种计算方法的运行速度对比"><a href="#各种计算方法的运行速度对比" class="headerlink" title="各种计算方法的运行速度对比"></a>各种计算方法的运行速度对比</h2><p>上述所有的实现代码中，都加入了记录算法开始时间和结束时间的代码，我们通过运行测试，得到下面的结果： <img data-src="https://cdn.javacodes.cn/files/2017/03/2017-03-19_17-51-32-1.jpg" alt="">￼</p><ul><li>可以看到，暴力搜索方法毋庸置疑是速度最慢的，因为其存在大量的重复递归过程。</li><li>记忆化搜索方法由于避免了重复递归，因此效率更高一些。</li><li>经过优化的动态规划方法可以看到在我的实测环境中，运行时间近乎为0ms，可以说是非常快的。</li></ul><h2 id="暴力递归优化成动态规划方法的大体过程"><a href="#暴力递归优化成动态规划方法的大体过程" class="headerlink" title="暴力递归优化成动态规划方法的大体过程"></a>暴力递归优化成动态规划方法的大体过程</h2><ol><li>实现暴力递归方法；</li><li>在暴力搜索方法的函数中看看哪些参数可以代表递归过程。</li><li>找到代表递归过程的参数之后，记忆化搜索方法的实现非常容易。</li><li>通过分析记忆化搜索的依赖路径，进而实现动态规划。</li><li>根据记忆化搜索方法改出动态规划方法，进而看看是否能够化简，如果能化简，还能实现时间复杂度更低的动态规划方法。</li></ol><h2 id="动态规划方法的关键点"><a href="#动态规划方法的关键点" class="headerlink" title="动态规划方法的关键点"></a>动态规划方法的关键点</h2><ol><li><strong>最优化原理</strong>：也就是<strong>最优子结构性质</strong>。指一个最优化策略具有这样的性质，不论过去状态和决策如何，对前面的决策所形成的状态而言，余下的诸决策必须构成最优策略。简单来说就是一个最优化策略的子策略总是最优的，如果一个问题满足最优化原理，就成为其具有最优子结构性质。</li><li><strong>无后效性</strong>：指某状态下决策的收益，只与状态和决策相关，与到达该状态的路径无关。</li><li><strong>子问题的重叠性</strong>：动态规划将原来具有指数级时间复杂度的暴力搜索算法改进成了具有多项式时间复杂度的算法。其中的关键在于解决冗余，这是动态规划算法的根本目的。</li></ol><blockquote><p>本文为博主学习牛客网课程<a href="https://www.nowcoder.com/courses/semester/algorithm" target="_blank" rel="noopener">《直通BAT-面试算法精讲课》</a>的学习笔记 如果需要购买该课程，可以使用博主的优惠码：<strong>Adg00aI</strong>，获取10元优惠。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;问题： 给定数组arr，arr中的所有的值都为正数且不重复。每个值代表一种面值的货币，每种面值的货币可以使用任意张，再给定一个整数aim代表要找的钱数，求换钱有多少种方法。&lt;/p&gt;
    
    </summary>
    
    
      <category term="JAVA" scheme="http://yoursite.com/categories/JAVA/"/>
    
    
      <category term="动态规划" scheme="http://yoursite.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>浅析ClassNotFoundException与NoClassDefFoundError</title>
    <link href="http://yoursite.com/2017/03/18/%E6%B5%85%E6%9E%90ClassNotFoundException%E4%B8%8ENoClassDefFoundError/"/>
    <id>http://yoursite.com/2017/03/18/%E6%B5%85%E6%9E%90ClassNotFoundException%E4%B8%8ENoClassDefFoundError/</id>
    <published>2017-03-18T02:57:13.000Z</published>
    <updated>2020-06-06T22:26:01.821Z</updated>
    
    <content type="html"><![CDATA[<p>最近接到电话面试中，面试官问我ClassNotFoundException与NoClassDefFoundError有什么样的区别，至于前者经常遇到，我还是能答上一些，至于后者，完全没遇到过啊，只好瞎编了，都忘记当时是怎么回答的。然后面试官问我他们都会出现在哪些情况，ClassNotFoundException我还可以说出几种情况，可是后者这下不能编了，只好求饶。结果面试官还给我讲解了一下，感觉非常尴尬。 回来以后又查阅了一些相关的资料，并尝试了一下，整理分享给网友。</p><a id="more"></a><h3 id="ClassNotFoundException"><a href="#ClassNotFoundException" class="headerlink" title="ClassNotFoundException"></a>ClassNotFoundException</h3><p>这个异常我们遇到的频率还是很高的，先来看看官方文档中的定义：</p><blockquote><p>当应用程序试图使用以下方法通过<strong>字符串名</strong>加载类时，抛出该异常：</p><ul><li>Class 类中的 forName 方法。</li><li>ClassLoader 类中的 findSystemClass 方法。</li><li>ClassLoader 类中的 loadClass 方法。</li></ul><p>但是没有找到具有指定名称的类的定义。 从 1.4 版本开始，此异常已经更新，以符合通用的异常链机制。在构造时提供并通过 <code>getException()</code> 方法访问的“加载类时引发的可选异常”，现在被称为原因，它可以通过 <code>Throwable.getCause()</code> 方法以及与上面提到的“遗留方法”来访问。</p></blockquote><p>也就是说在<strong>类加载</strong>阶段，通过类全名加载类时，如果不能找到这个类，就会抛出ClassNotFoundException，当然，通常在开发中可能出现该异常的情况总结如下：</p><ol><li>所需要的支持类库放错了地方，并没有放在类路径(CLASSPATH环境变量)里面。</li><li>使用了重复的类库，且版本不一致。导致低版本的被优先使用。</li><li>类名错了，一般是使用Class.forName的时候，手工指定了类名的情况。</li><li>没有导入纯JAVA驱动包。</li></ol><p>当然啦，我经常遇到这个异常，尤其是在使用JDBC加载驱动的时候，驱动类的类全名真的是很难记的有木有！</p><h3 id="NoClassDefFoundError"><a href="#NoClassDefFoundError" class="headerlink" title="NoClassDefFoundError"></a>NoClassDefFoundError</h3><p>可以看到这个错误的类名以Error结尾，因此它属于JVM虚拟机错误，不需要程序员捕获，下图是它的继承结构： <img data-src="https://cdn.javacodes.cn/files/2017/03/2017-03-18_02-57-20.jpg" alt="">￼ 还是同样先来看下官方文档中的定义：</p><blockquote><p>当 Java 虚拟机或 ClassLoader 实例试图在类的定义中加载（作为通常方法调用的一部分或者作为使用 new 表达式创建的新实例的一部分），但无法找到该类的定义时，抛出此异常。 当前执行的类被编译时，所搜索的类定义存在，但无法再找到该定义。</p></blockquote><p>通俗的说，就是编译的时候有这个类，而<strong>运行期</strong>的时候，这个类找不到了！就会抛出NoClassDefFoundError异常。 想要演示这个异常的出现很简单，只需要在编译好的class文件中将对应类的class文件删除，运行的时候就会抛出这个异常啦！ 那么在实际开发中，通常会在哪些情况遇到该异常呢？通常我们在开发过程中，肯定不会刻意的去删除某个class文件，但仍然有出现该异常的情况。 比如我们在使用第三方jar包时，有些SDK也会设定自己的Classpath。编译过程结束后在运行的过程中就要将已开发的应用和所有引入的jar包拷贝到应用服务器的相应目录下才可以运行，而应用服务器使用的Classpath也很有可能与SDK的不同，在这个过程中就有很大的几率造成双方环境不一致。所以很多开发者就会遇到在SDK中可以编译，运行也没有问题，但是同样的程序放到应用服务器上就出现NoClassDefFoundErr这个异常这种情况。</p><blockquote><p><strong>参考文章</strong>： 1. JavaTM Platform Standard Edition 6 的 API 规范 2. <a href="http://blog.csdn.net/fengkuangqi/article/details/32324053" target="_blank" rel="noopener">NoClassDefDoundErr与ClassNotFoundException区别</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近接到电话面试中，面试官问我ClassNotFoundException与NoClassDefFoundError有什么样的区别，至于前者经常遇到，我还是能答上一些，至于后者，完全没遇到过啊，只好瞎编了，都忘记当时是怎么回答的。然后面试官问我他们都会出现在哪些情况，ClassNotFoundException我还可以说出几种情况，可是后者这下不能编了，只好求饶。结果面试官还给我讲解了一下，感觉非常尴尬。 回来以后又查阅了一些相关的资料，并尝试了一下，整理分享给网友。&lt;/p&gt;
    
    </summary>
    
    
      <category term="JAVA" scheme="http://yoursite.com/categories/JAVA/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="类加载" scheme="http://yoursite.com/tags/%E7%B1%BB%E5%8A%A0%E8%BD%BD/"/>
    
      <category term="异常" scheme="http://yoursite.com/tags/%E5%BC%82%E5%B8%B8/"/>
    
  </entry>
  
  <entry>
    <title>ThreadLocal 详解</title>
    <link href="http://yoursite.com/2017/03/15/ThreadLocal%20%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2017/03/15/ThreadLocal%20%E8%AF%A6%E8%A7%A3/</id>
    <published>2017-03-15T15:34:01.000Z</published>
    <updated>2020-06-06T22:26:01.821Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ThreadLocal是什么"><a href="#ThreadLocal是什么" class="headerlink" title="ThreadLocal是什么"></a>ThreadLocal是什么</h2><p>　　早在JDK 1.2的版本中就提供Java.lang.ThreadLocal，ThreadLocal为解决多线程程序的并发问题提供了一种新的思路。使用这个工具类可以很简洁地编写出优美的多线程程序。 　　 　　当使用ThreadLocal维护变量时，ThreadLocal为每个使用该变量的线程提供独立的变量副本，所以每一个线程都可以独立地改变自己的副本，而不会影响其它线程所对应的副本。 　　 　　从线程的角度看，目标变量就象是线程的本地变量，这也是类名中“Local”所要表达的意思。 　　 　　所以，在Java中编写线程局部变量的代码相对来说要笨拙一些，因此造成线程局部变量没有在Java开发者中得到很好的普及。 　　</p><a id="more"></a><h2 id="ThreadLocal的接口方法"><a href="#ThreadLocal的接口方法" class="headerlink" title="ThreadLocal的接口方法"></a>ThreadLocal的接口方法</h2><p>ThreadLocal类接口很简单，只有4个方法，我们先来了解一下：</p><ul><li><strong>void set(Object value)</strong>：设置当前线程的线程局部变量的值。</li><li><strong>public Object get()</strong>：该方法返回当前线程所对应的线程局部变量。</li><li><strong>public void remove()</strong>：将当前线程局部变量的值删除，目的是为了减少内存的占用，该方法是JDK 5.0新增的方法。需要指出的是，当线程结束后，对应该线程的局部变量将自动被垃圾回收，所以显式调用该方法清除线程的局部变量并不是必须的操作，但它可以加快内存回收的速度。</li><li><strong>protected Object initialValue()</strong>：返回该线程局部变量的初始值，该方法是一个protected的方法，显然是为了让子类覆盖而设计的。这个方法是一个延迟调用方法，在线程第1次调用get()或set(Object)时才执行，并且仅执行1次。ThreadLocal中的缺省实现直接返回一个null。</li></ul><p>　　值得一提的是，在JDK5.0中，ThreadLocal已经支持泛型，该类的类名已经变为ThreadLocal。API方法也相应进行了调整，新版本的API方法分别是void set(T value)、T get()以及T initialValue()。 　　 　　ThreadLocal是如何做到为每一个线程维护变量的副本的呢？其实实现的思路很简单：在ThreadLocal类中有一个Map，用于存储每一个线程的变量副本，Map中元素的键为线程对象，而值对应线程的变量副本。我们自己就可以提供一个简单的实现版本：</p><pre><code>package com.test;public class TestNum {    // ①通过匿名内部类覆盖ThreadLocal的initialValue()方法，指定初始值    private static ThreadLocal&lt;Integer&gt; seqNum = new ThreadLocal&lt;Integer&gt;() {        public Integer initialValue() {            return 0;        }    };    // ②获取下一个序列值    public int getNextNum() {        seqNum.set(seqNum.get() + 1);        return seqNum.get();    }    public static void main(String[] args) {        TestNum sn = new TestNum();        // ③ 3个线程共享sn，各自产生序列号        TestClient t1 = new TestClient(sn);        TestClient t2 = new TestClient(sn);        TestClient t3 = new TestClient(sn);        t1.start();        t2.start();        t3.start();    }    private static class TestClient extends Thread {        private TestNum sn;        public TestClient(TestNum sn) {            this.sn = sn;        }        public void run() {            for (int i = 0; i &lt; 3; i++) {                // ④每个线程打出3个序列值                System.out.println(&quot;thread[&quot; + Thread.currentThread().getName() + &quot;] --&gt; sn[&quot;                         + sn.getNextNum() + &quot;]&quot;);            }        }    }}</code></pre><p>　　通常我们通过匿名内部类的方式定义ThreadLocal的子类，提供初始的变量值，如例子中①处所示。TestClient线程产生一组序列号，在③处，我们生成3个TestClient，它们共享同一个TestNum实例。运行以上代码，在控制台上输出以下的结果：</p><pre><code>thread[Thread-0] --&gt; sn[1]thread[Thread-1] --&gt; sn[1]thread[Thread-2] --&gt; sn[1]thread[Thread-1] --&gt; sn[2]thread[Thread-0] --&gt; sn[2]thread[Thread-1] --&gt; sn[3]thread[Thread-2] --&gt; sn[2]thread[Thread-0] --&gt; sn[3]thread[Thread-2] --&gt; sn[3]</code></pre><p>　　考察输出的结果信息，我们发现每个线程所产生的序号虽然都共享同一个TestNum实例，但它们并没有发生相互干扰的情况，而是各自产生独立的序列号，这是因为我们通过ThreadLocal为每一个线程提供了单独的副本。</p><h2 id="Thread同步机制的比较"><a href="#Thread同步机制的比较" class="headerlink" title="Thread同步机制的比较"></a>Thread同步机制的比较</h2><p>　　ThreadLocal和线程同步机制相比有什么优势呢？ThreadLocal和线程同步机制都是为了解决多线程中相同变量的访问冲突问题。 　　 　　在同步机制中，通过对象的锁机制保证同一时间只有一个线程访问变量。这时该变量是多个线程共享的，使用同步机制要求程序慎密地分析什么时候对变量进行读写，什么时候需要锁定某个对象，什么时候释放对象锁等繁杂的问题，程序设计和编写难度相对较大。 　　 　　而ThreadLocal则从另一个角度来解决多线程的并发访问。ThreadLocal会为每一个线程提供一个独立的变量副本，从而隔离了多个线程对数据的访问冲突。因为每一个线程都拥有自己的变量副本，从而也就没有必要对该变量进行同步了。ThreadLocal提供了线程安全的共享对象，在编写多线程代码时，可以把不安全的变量封装进ThreadLocal。 　　 　　由于ThreadLocal中可以持有任何类型的对象，低版本JDK所提供的get()返回的是Object对象，需要强制类型转换。但JDK 5.0通过泛型很好的解决了这个问题，在一定程度地简化ThreadLocal的使用，代码清单 9 2就使用了JDK 5.0新的ThreadLocal版本。 　　 　　概括起来说，对于多线程资源共享的问题，同步机制采用了“以时间换空间”的方式，而ThreadLocal采用了“以空间换时间”的方式。前者仅提供一份变量，让不同的线程排队访问，而后者为每一个线程都提供了一份变量，因此可以同时访问而互不影响。 　　 　　spring使用ThreadLocal解决线程安全问题我们知道在一般情况下，只有无状态的Bean才可以在多线程环境下共享，在Spring中，绝大部分Bean都可以声明为singleton作用域。就是因为Spring对一些Bean（如RequestContextHolder、TransactionSynchronizationManager、LocaleContextHolder等）中非线程安全状态采用ThreadLocal进行处理，让它们也成为线程安全的状态，因为有状态的Bean就可以在多线程中共享了。 　　 　　一般的Web应用划分为展现层、服务层和持久层三个层次，在不同的层中编写对应的逻辑，下层通过接口向上层开放功能调用。在一般情况下，从接收请求到返回响应所经过的所有程序调用都同属于一个线程，如图9‑2所示： 　　 　　<img data-src="https://cdn.javacodes.cn/files/2017/03/2017-03-15_15-34-09.gif" alt="">￼ 　　同一线程贯通三层这样你就可以根据需要，将一些非线程安全的变量以ThreadLocal存放，在同一次请求响应的调用线程中，所有关联的对象引用到的都是同一个变量。 　　下面的实例能够体现Spring对有状态Bean的改造思路： 　　代码清单3 TestDao：非线程安全</p><pre><code>package com.test;import java.sql.Connection;import java.sql.SQLException;import java.sql.Statement;public class TestDao {    private Connection conn;// ①一个非线程安全的变量    public void addTopic() throws SQLException {        Statement stat = conn.createStatement();// ②引用非线程安全变量        // …    }}</code></pre><p>　　由于①处的conn是成员变量，因为addTopic()方法是非线程安全的，必须在使用时创建一个新TopicDao实例（非singleton）。下面使用ThreadLocal对conn这个非线程安全的“状态”进行改造： 　　代码清单4 TestDao：线程安全</p><pre><code>package com.test;import java.sql.Connection;import java.sql.SQLException;import java.sql.Statement;public class TestDaoNew {    // ①使用ThreadLocal保存Connection变量    private static ThreadLocal&lt;Connection&gt; connThreadLocal = new ThreadLocal&lt;Connection&gt;();    public static Connection getConnection() {        // ②如果connThreadLocal没有本线程对应的Connection创建一个新的Connection，        // 并将其保存到线程本地变量中。        if (connThreadLocal.get() == null) {            Connection conn = getConnection();            connThreadLocal.set(conn);            return conn;        } else {            return connThreadLocal.get();// ③直接返回线程本地变量        }    }    public void addTopic() throws SQLException {        // ④从ThreadLocal中获取线程对应的Connection        Statement stat = getConnection().createStatement();    }}</code></pre><p>　　不同的线程在使用TopicDao时，先判断connThreadLocal.get()是否是null，如果是null，则说明当前线程还没有对应的Connection对象，这时创建一个Connection对象并添加到本地线程变量中；如果不为null，则说明当前的线程已经拥有了Connection对象，直接使用就可以了。这样，就保证了不同的线程使用线程相关的Connection，而不会使用其它线程的Connection。因此，这个TopicDao就可以做到singleton共享了。 　　 　　当然，这个例子本身很粗糙，将Connection的ThreadLocal直接放在DAO只能做到本DAO的多个方法共享Connection时不发生线程安全问题，但无法和其它DAO共用同一个Connection，要做到同一事务多DAO共享同一Connection，必须在一个共同的外部类使用ThreadLocal保存Connection。</p><pre><code>package com.test;import java.sql.Connection;import java.sql.DriverManager;import java.sql.SQLException;public class ConnectionManager {    private static ThreadLocal&lt;Connection&gt; connectionHolder = new ThreadLocal&lt;Connection&gt;() {        @Override        protected Connection initialValue() {            Connection conn = null;            try {                conn = DriverManager.getConnection(                        &quot;jdbc:mysql://localhost:3306/test&quot;, &quot;username&quot;,                        &quot;password&quot;);            } catch (SQLException e) {                e.printStackTrace();            }            return conn;        }    };    public static Connection getConnection() {        return connectionHolder.get();    }    public static void setConnection(Connection conn) {        connectionHolder.set(conn);    }}</code></pre><h2 id="java-lang-ThreadLocal的具体实现"><a href="#java-lang-ThreadLocal的具体实现" class="headerlink" title="java.lang.ThreadLocal的具体实现"></a>java.lang.ThreadLocal的具体实现</h2><p>　　那么到底ThreadLocal类是如何实现这种“为每个线程提供不同的变量拷贝”的呢？先来看一下ThreadLocal的set()方法的源码是如何实现的：</p><pre><code>/**    * Sets the current thread&apos;s copy of this thread-local variable    * to the specified value.  Most subclasses will have no need to    * override this method, relying solely on the {@link #initialValue}    * method to set the values of thread-locals.    *    * @param value the value to be stored in the current thread&apos;s copy of    *        this thread-local.    */   public void set(T value) {       Thread t = Thread.currentThread();       ThreadLocalMap map = getMap(t);       if (map != null)           map.set(this, value);       else           createMap(t, value);   }</code></pre><p>　　在这个方法内部我们看到，首先通过getMap(Thread t)方法获取一个和当前线程相关的ThreadLocalMap，然后将变量的值设置到这个ThreadLocalMap对象中，当然如果获取到的ThreadLocalMap对象为空，就通过createMap方法创建。 　　线程隔离的秘密，就在于ThreadLocalMap这个类。ThreadLocalMap是ThreadLocal类的一个静态内部类，它实现了键值对的设置和获取（对比Map对象来理解），每个线程中都有一个独立的ThreadLocalMap副本，它所存储的值，只能被当前线程读取和修改。ThreadLocal类通过操作每一个线程特有的ThreadLocalMap副本，从而实现了变量访问在不同线程中的隔离。因为每个线程的变量都是自己特有的，完全不会有并发错误。还有一点就是，ThreadLocalMap存储的键值对中的键是this对象指向的ThreadLocal对象，而值就是你所设置的对象了。 　　为了加深理解，我们接着看上面代码中出现的getMap和createMap方法的实现：</p><pre><code>    /**     * Get the map associated with a ThreadLocal. Overridden in     * InheritableThreadLocal.     *     * @param  t the current thread     * @return the map     */    ThreadLocalMap getMap(Thread t) {        return t.threadLocals;    }    /**     * Create the map associated with a ThreadLocal. Overridden in     * InheritableThreadLocal.     *     * @param t the current thread     * @param firstValue value for the initial entry of the map     * @param map the map to store.     */    void createMap(Thread t, T firstValue) {        t.threadLocals = new ThreadLocalMap(this, firstValue);    }    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">　　接下来再看一下ThreadLocal类中的get()方法:</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;java</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Returns the value in the current thread&#39;s copy of this</span><br><span class="line">     * thread-local variable.  If the variable has no value for the</span><br><span class="line">     * current thread, it is first initialized to the value returned</span><br><span class="line">     * by an invocation of the &#123;@link #initialValue&#125; method.</span><br><span class="line">     *</span><br><span class="line">     * @return the current thread&#39;s value of this thread-local</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public T get() &#123;</span><br><span class="line">        Thread t &#x3D; Thread.currentThread();</span><br><span class="line">        ThreadLocalMap map &#x3D; getMap(t);</span><br><span class="line">        if (map !&#x3D; null) &#123;</span><br><span class="line">            ThreadLocalMap.Entry e &#x3D; map.getEntry(this);</span><br><span class="line">            if (e !&#x3D; null)</span><br><span class="line">                return (T)e.value;</span><br><span class="line">        &#125;</span><br><span class="line">        return setInitialValue();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>　　再来看setInitialValue()方法：```java     /**     * Variant of set() to establish initialValue. Used instead     * of set() in case user has overridden the set() method.     *     * @return the initial value     */    private T setInitialValue() {        T value = initialValue();        Thread t = Thread.currentThread();        ThreadLocalMap map = getMap(t);        if (map != null)            map.set(this, value);        else            createMap(t, value);        return value;    }</code></pre><p>　　获取和当前线程绑定的值时，ThreadLocalMap对象是以this指向的ThreadLocal对象为键进行查找的，这当然和前面set()方法的代码是相呼应的。 　　进一步地，我们可以创建不同的ThreadLocal实例来实现多个变量在不同线程间的访问隔离，为什么可以这么做？因为不同的ThreadLocal对象作为不同键，当然也可以在线程的ThreadLocalMap对象中设置不同的值了。通过ThreadLocal对象，在多线程中共享一个值和多个值的区别，就像你在一个HashMap对象中存储一个键值对和多个键值对一样，仅此而已。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>　　ThreadLocal是解决线程安全问题一个很好的思路，它通过为每个线程提供一个独立的变量副本解决了变量并发访问的冲突问题。在很多情况下，ThreadLocal比直接使用synchronized同步机制解决线程安全问题更简单，更方便，且结果程序拥有更高的并发性。 ConnectionManager.java</p><pre><code>package com.test;import java.sql.Connection;import java.sql.DriverManager;import java.sql.SQLException;public class ConnectionManager {    private static ThreadLocal&lt;Connection&gt; connectionHolder = new ThreadLocal&lt;Connection&gt;() {        @Override        protected Connection initialValue() {            Connection conn = null;            try {                conn = DriverManager.getConnection(                        &quot;jdbc:mysql://localhost:3306/test&quot;, &quot;username&quot;,                        &quot;password&quot;);            } catch (SQLException e) {                e.printStackTrace();            }            return conn;        }    };    public static Connection getConnection() {        return connectionHolder.get();    }    public static void setConnection(Connection conn) {        connectionHolder.set(conn);    }}</code></pre><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>　　看到网友评论的很激烈，甚至关于ThreadLocalMap不是ThreadLocal里面的，而是Thread里面的这种评论都出现了，于是有了这个后记，下面先把jdk源码贴上，源码最有说服力了。</p><pre><code>/**     * ThreadLocalMap is a customized hash map suitable only for     * maintaining thread local values. No operations are exported     * outside of the ThreadLocal class. The class is package private to     * allow declaration of fields in class Thread.  To help deal with     * very large and long-lived usages, the hash table entries use     * WeakReferences for keys. However, since reference queues are not     * used, stale entries are guaranteed to be removed only when     * the table starts running out of space.     */    static class ThreadLocalMap {...}</code></pre><p>　　源码就是以上，这源码自然是在ThreadLocal里面的，有截图为证。 　　 　　<img data-src="https://cdn.javacodes.cn/files/2017/03/2017-03-15_15-34-09.jpg" alt="">￼ 　　本文是自己在学习ThreadLocal的时候，一时兴起，深入看了源码，思考了此类的作用、使用范围，进而联想到对传统的synchronize共享变量线程安全的问题进行比较，而总结的博文，总结一句话就是一个是锁机制进行时间换空间，一个是存储拷贝进行空间换时间。 (全文完)</p><blockquote><p>转载自<a href="http://blog.csdn.net/lufeng20" target="_blank" rel="noopener">http://blog.csdn.net/lufeng20</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;ThreadLocal是什么&quot;&gt;&lt;a href=&quot;#ThreadLocal是什么&quot; class=&quot;headerlink&quot; title=&quot;ThreadLocal是什么&quot;&gt;&lt;/a&gt;ThreadLocal是什么&lt;/h2&gt;&lt;p&gt;　　早在JDK 1.2的版本中就提供Java.lang.ThreadLocal，ThreadLocal为解决多线程程序的并发问题提供了一种新的思路。使用这个工具类可以很简洁地编写出优美的多线程程序。 　　 　　当使用ThreadLocal维护变量时，ThreadLocal为每个使用该变量的线程提供独立的变量副本，所以每一个线程都可以独立地改变自己的副本，而不会影响其它线程所对应的副本。 　　 　　从线程的角度看，目标变量就象是线程的本地变量，这也是类名中“Local”所要表达的意思。 　　 　　所以，在Java中编写线程局部变量的代码相对来说要笨拙一些，因此造成线程局部变量没有在Java开发者中得到很好的普及。 　　&lt;/p&gt;
    
    </summary>
    
    
      <category term="JAVA" scheme="http://yoursite.com/categories/JAVA/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="并发" scheme="http://yoursite.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="ThreadLocal" scheme="http://yoursite.com/tags/ThreadLocal/"/>
    
  </entry>
  
  <entry>
    <title>Java NIO 教程详解</title>
    <link href="http://yoursite.com/2017/03/15/Java%20NIO%20%E6%95%99%E7%A8%8B%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2017/03/15/Java%20NIO%20%E6%95%99%E7%A8%8B%E8%AF%A6%E8%A7%A3/</id>
    <published>2017-03-14T17:34:53.000Z</published>
    <updated>2020-06-06T22:26:01.817Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>英文原文地址：<a href="http://tutorials.jenkov.com/java-nio/index.html" target="_blank" rel="noopener">http://tutorials.jenkov.com/java-nio/index.html</a> 中文来源地址：<a href="http://ifeve.com/java-nio-all/" target="_blank" rel="noopener">http://ifeve.com/java-nio-all/</a> 作者：Jakob Jenkov 译者：郭蕾 校对：方腾飞 本文由<a href="https://cdn.javacodes.cn" target="_blank" rel="noopener">老H博客</a>整理修订</p></blockquote><p>[TOC] Java NIO(New IO)是一个可以替代标准Java IO API的IO API（从Java 1.4开始)，Java NIO提供了与标准IO不同的IO工作方式。</p><ul><li><strong>Java NIO: Channels and Buffers（通道和缓冲区）</strong>：标准的IO基于字节流和字符流进行操作的，而NIO是基于通道（Channel）和缓冲区（Buffer）进行操作，数据总是从通道读取到缓冲区中，或者从缓冲区写入到通道中。</li><li><strong>Java NIO: Non-blocking IO（非阻塞IO）</strong>：Java NIO可以让你非阻塞的使用IO，例如：当线程从通道读取数据到缓冲区时，线程还是可以进行其他事情。当数据被写入到缓冲区时，线程可以继续处理它。从缓冲区写入通道也类似。</li><li><strong>Java NIO: Selectors（选择器）</strong>：Java NIO引入了选择器的概念，选择器用于监听多个通道的事件（比如：连接打开，数据到达）。因此，单个的线程可以监听多个数据通道。</li></ul><a id="more"></a><p>各章节直达链接：</p><ol><li><a href="#nio-1">Java NIO概述</a></li><li><a href="#nio-2">Java NIO Channel</a></li><li><a href="#nio-3">Java NIO Buffer</a></li><li><a href="#nio-4">Java NIO Scatter / Gather</a></li><li><a href="#nio-5">Java NIO 通道之间的数据传输</a></li><li><a href="#nio-6">Java NIO Selector</a></li><li><a href="#nio-7">Java NIO FileChannel</a></li><li><a href="#nio-8">Java NIO SocketChannel</a></li><li><a href="#nio-9">Java NIO ServerSocketChannel</a></li><li><a href="#nio-10">Java NIO DataGramChannel</a></li><li><a href="#nio-11">Java NIO Pipe</a></li><li><a href="#nio-12">Java NIO NIO 与IO</a></li></ol><hr><h2 id="一、Java-NIO-概述"><a href="#一、Java-NIO-概述" class="headerlink" title="一、Java NIO 概述"></a>一、Java NIO 概述</h2><p>Java NIO 由以下几个核心部分组成：</p><ul><li>Channels</li><li>Buffers</li><li>Selectors</li></ul><p>虽然Java NIO 中除此之外还有很多类和组件，但在我看来，Channel，Buffer 和 Selector 构成了核心的API。其它组件，如Pipe和FileLock，只不过是与三个核心组件共同使用的工具类。因此，在概述中我将集中在这三个组件上。其它组件会在单独的章节中讲到。</p><h3 id="Channel-和-Buffer"><a href="#Channel-和-Buffer" class="headerlink" title="Channel 和 Buffer"></a>Channel 和 Buffer</h3><p>基本上，所有的 IO 在NIO 中都从一个Channel 开始。Channel 有点象流。 数据可以从Channel读到Buffer中，也可以从Buffer 写到Channel中。这里有个图示： <img data-src="https://cdn.javacodes.cn/files/2017/03/2017-03-14_17-35-10-1.jpg" alt="">￼ Channel和Buffer有好几种类型。下面是JAVA NIO中的一些主要Channel的实现：</p><ul><li>FileChannel</li><li>DatagramChannel</li><li>SocketChannel</li><li>ServerSocketChannel</li></ul><p>正如你所看到的，这些通道涵盖了UDP 和 TCP 网络IO，以及文件IO。 与这些类一起的有一些有趣的接口，但为简单起见，我尽量在概述中不提到它们。本教程其它章节与它们相关的地方我会进行解释。 以下是Java NIO里关键的Buffer实现：</p><ul><li>ByteBuffer</li><li>CharBuffer</li><li>DoubleBuffer</li><li>FloatBuffer</li><li>IntBuffer</li><li>LongBuffer</li><li>ShortBuffer</li></ul><p>这些Buffer覆盖了你能通过IO发送的基本数据类型：byte, short, int, long, float, double 和 char。 Java NIO 还有个 MappedByteBuffer，用于表示内存映射文件， 我也不打算在概述中说明。</p><h3 id="Selector"><a href="#Selector" class="headerlink" title="Selector"></a>Selector</h3><p>Selector允许单线程处理多个 Channel。如果你的应用打开了多个连接（通道），但每个连接的流量都很低，使用Selector就会很方便。例如，在一个聊天服务器中。 这是在一个单线程中使用一个Selector处理3个Channel的图示： <img data-src="https://cdn.javacodes.cn/files/2017/03/2017-03-14_17-35-10.jpg" alt="">￼ 要使用Selector，得向Selector注册Channel，然后调用它的<code>select()</code>方法。这个方法会一直阻塞到某个注册的通道有事件就绪。一旦这个方法返回，线程就可以处理这些事件，事件的例子有如新连接进来，数据接收等。</p><hr><h2 id="二、Channal"><a href="#二、Channal" class="headerlink" title="二、Channal"></a>二、Channal</h2><p>Java NIO的通道类似流，但又有些不同：</p><ul><li>既可以从通道中读取数据，又可以写数据到通道。但流的读写通常是单向的。</li><li>通道可以异步地读写。</li><li>通道中的数据总是要先读到一个Buffer，或者总是要从一个Buffer中写入。</li></ul><p>正如上面所说，从通道读取数据到缓冲区，从缓冲区写入数据到通道。如下图所示： <img data-src="https://cdn.javacodes.cn/files/2017/03/2017-03-14_17-35-10-4.jpg" alt="">￼</p><h3 id="Channel的实现"><a href="#Channel的实现" class="headerlink" title="Channel的实现"></a>Channel的实现</h3><p>这些是Java NIO中最重要的通道的实现：</p><ul><li>FileChannel</li><li>DatagramChannel</li><li>SocketChannel</li><li>ServerSocketChannel</li></ul><p>FileChannel 从文件中读写数据。 DatagramChannel 能通过UDP读写网络中的数据。 SocketChannel 能通过TCP读写网络中的数据。 ServerSocketChannel可以监听新进来的TCP连接，像Web服务器那样。对每一个新进来的连接都会创建一个SocketChannel。</p><h3 id="基本的-Channel-示例"><a href="#基本的-Channel-示例" class="headerlink" title="基本的 Channel 示例"></a>基本的 Channel 示例</h3><p>下面是一个使用FileChannel读取数据到Buffer中的示例：</p><pre><code>RandomAccessFile aFile = new RandomAccessFile(&quot;data/nio-data.txt&quot;, &quot;rw&quot;);FileChannel inChannel = aFile.getChannel();ByteBuffer buf = ByteBuffer.allocate(48);int bytesRead = inChannel.read(buf);while (bytesRead != -1) {  System.out.println(&quot;Read &quot; + bytesRead);  buf.flip();  while(buf.hasRemaining()){      System.out.print((char) buf.get());  }  buf.clear();  bytesRead = inChannel.read(buf);}aFile.close();</code></pre><p>注意 buf.flip() 的调用，首先读取数据到Buffer，然后反转Buffer,接着再从Buffer中读取数据。下一节会深入讲解Buffer的更多细节。</p><hr><h2 id="三、Buffer"><a href="#三、Buffer" class="headerlink" title="三、Buffer"></a>三、Buffer</h2><p>Java NIO中的Buffer用于和NIO通道进行交互。如你所知，数据是从通道读入缓冲区，从缓冲区写入到通道中的。 缓冲区本质上是一块可以写入数据，然后可以从中读取数据的内存。这块内存被包装成NIO Buffer对象，并提供了一组方法，用来方便的访问该块内存。</p><h3 id="Buffer的基本用法"><a href="#Buffer的基本用法" class="headerlink" title="Buffer的基本用法"></a>Buffer的基本用法</h3><p>使用Buffer读写数据一般遵循以下四个步骤：</p><ol><li>写入数据到Buffer</li><li>调用<code>flip()</code>方法</li><li>从Buffer中读取数据</li><li>调用<code>clear()</code>方法或者<code>compact()</code>方法</li></ol><p>当向buffer写入数据时，buffer会记录下写了多少数据。一旦要读取数据，需要通过<code>flip()</code>方法将Buffer从写模式切换到读模式。在读模式下，可以读取之前写入到buffer的所有数据。 一旦读完了所有的数据，就需要清空缓冲区，让它可以再次被写入。有两种方式能清空缓冲区：调用<code>clear()</code>或<code>compact()</code>方法。</p><ul><li><code>clear()</code>方法会清空整个缓冲区。</li><li><code>compact()</code>方法只会清除已经读过的数据。任何未读的数据都被移到缓冲区的起始处，新写入的数据将放到缓冲区未读数据的后面。</li></ul><p>下面是一个使用Buffer的例子：</p><pre><code>RandomAccessFile aFile = new RandomAccessFile(&quot;data/nio-data.txt&quot;, &quot;rw&quot;);FileChannel inChannel = aFile.getChannel();//create buffer with capacity of 48 bytesByteBuffer buf = ByteBuffer.allocate(48);int bytesRead = inChannel.read(buf); //read into buffer.while (bytesRead != -1) {  buf.flip(); //make buffer ready for read  while(buf.hasRemaining()){      System.out.print((char) buf.get()); // read 1 byte at a time  }  buf.clear(); //make buffer ready for writing  bytesRead = inChannel.read(buf);}aFile.close();</code></pre><h3 id="Buffer的capacity-position和limit"><a href="#Buffer的capacity-position和limit" class="headerlink" title="Buffer的capacity,position和limit"></a>Buffer的capacity,position和limit</h3><p>缓冲区本质上是一块可以写入数据，然后可以从中读取数据的内存。这块内存被包装成NIO Buffer对象，并提供了一组方法，用来方便的访问该块内存。 为了理解Buffer的工作原理，需要熟悉它的三个属性：</p><ul><li>capacity</li><li>position</li><li>limit</li></ul><p>position和limit的含义取决于Buffer处在读模式还是写模式。不管Buffer处在什么模式，capacity的含义总是一样的。 这里有一个关于capacity，position和limit在读写模式中的说明，详细的解释在插图后面。 <img data-src="https://cdn.javacodes.cn/files/2017/03/2017-03-14_17-35-10-5.jpg" alt="">￼</p><ul><li><strong>capacity</strong>：作为一个内存块，Buffer有一个固定的大小值，也叫“capacity”.你只能往里写capacity个byte、long，char等类型。一旦Buffer满了，需要将其清空（通过读数据或者清除数据）才能继续写数据往里写数据。</li><li><strong>position</strong>：当你写数据到Buffer中时，position表示当前的位置。初始的position值为0.当一个byte、long等数据写到Buffer后， position会向前移动到下一个可插入数据的Buffer单元。position最大可为capacity – 1。 当读取数据时，也是从某个特定位置读。当将Buffer从写模式切换到读模式，position会被重置为0. 当从Buffer的position处读取数据时，position向前移动到下一个可读的位置。</li><li><strong>limit</strong>：在写模式下，Buffer的limit表示你最多能往Buffer里写多少数据。 写模式下，limit等于Buffer的capacity。当切换Buffer到读模式时， limit表示你最多能读到多少数据。因此，当切换Buffer到读模式时，limit会被设置成写模式下的position值。换句话说，你能读到之前写入的所有数据（limit被设置成已写数据的数量，这个值在写模式下就是position）。</li></ul><h3 id="Buffer的类型"><a href="#Buffer的类型" class="headerlink" title="Buffer的类型"></a>Buffer的类型</h3><p>Java NIO 有以下Buffer类型</p><ul><li>ByteBuffer</li><li>MappedByteBuffer</li><li>CharBuffer</li><li>DoubleBuffer</li><li>FloatBuffer</li><li>IntBuffer</li><li>LongBuffer</li><li>ShortBuffer</li></ul><p>如你所见，这些Buffer类型代表了不同的数据类型。换句话说，就是可以通过char，short，int，long，float 或 double类型来操作缓冲区中的字节。 MappedByteBuffer 有些特别，在涉及它的专门章节中再讲。</p><h3 id="Buffer的分配"><a href="#Buffer的分配" class="headerlink" title="Buffer的分配"></a>Buffer的分配</h3><p>要想获得一个Buffer对象首先要进行分配。 每一个Buffer类都有一个<code>allocate()</code>方法。下面是一个分配48字节capacity的ByteBuffer的例子。</p><pre><code>ByteBuffer buf = ByteBuffer.allocate(48);</code></pre><p>这是分配一个可存储1024个字符的CharBuffer：</p><pre><code>CharBuffer buf = CharBuffer.allocate(1024);</code></pre><h3 id="向Buffer中写数据"><a href="#向Buffer中写数据" class="headerlink" title="向Buffer中写数据"></a>向Buffer中写数据</h3><p>写数据到Buffer有两种方式：</p><ul><li>从Channel写到Buffer。</li><li>通过Buffer的<code>put()</code>方法写到Buffer里。</li></ul><p>从Channel写到Buffer的例子</p><pre><code>int bytesRead = inChannel.read(buf); //read into buffer.</code></pre><p>通过<code>put()</code>方法写Buffer的例子：</p><pre><code>buf.put(127);</code></pre><p><code>put()</code>方法有很多版本，允许你以不同的方式把数据写入到Buffer中。例如， 写到一个指定的位置，或者把一个字节数组写入到Buffer。 更多Buffer实现的细节参考JavaDoc。</p><h4 id="flip-方法"><a href="#flip-方法" class="headerlink" title="flip()方法"></a>flip()方法</h4><p><code>flip()</code>方法将Buffer从写模式切换到读模式。调用<code>flip()</code>方法会将position设回0，并将limit设置成之前position的值。 换句话说，position现在用于标记读的位置，limit表示之前写进了多少个byte、char等 —— 现在能读取多少个byte、char等。</p><h3 id="从Buffer中读取数据"><a href="#从Buffer中读取数据" class="headerlink" title="从Buffer中读取数据"></a>从Buffer中读取数据</h3><p>从Buffer中读取数据有两种方式：</p><ul><li>从Buffer读取数据到Channel。</li><li>使用<code>get()</code>方法从Buffer中读取数据。</li></ul><p>从Buffer读取数据到Channel的例子：</p><pre><code>//read from buffer into channel.int bytesWritten = inChannel.write(buf);</code></pre><p>使用<code>get()</code>方法从Buffer中读取数据的例子</p><pre><code>byte aByte = buf.get();</code></pre><p><code>get()</code>方法有很多版本，允许你以不同的方式从Buffer中读取数据。例如，从指定position读取，或者从Buffer中读取数据到字节数组。更多Buffer实现的细节参考JavaDoc。</p><h3 id="rewind-方法"><a href="#rewind-方法" class="headerlink" title="rewind()方法"></a>rewind()方法</h3><p><code>Buffer.rewind()</code>将position设回0，所以你可以重读Buffer中的所有数据。limit保持不变，仍然表示能从Buffer中读取多少个元素（byte、char等）。</p><h3 id="clear-与compact-方法"><a href="#clear-与compact-方法" class="headerlink" title="clear()与compact()方法"></a>clear()与compact()方法</h3><p>一旦读完Buffer中的数据，需要让Buffer准备好再次被写入。可以通过<code>clear()</code>或<code>compact()</code>方法来完成。</p><ul><li><p>如果调用的是<code>clear()</code>方法，position将被设回0，limit被设置成 capacity的值。换句话说，Buffer 被清空了。Buffer中的数据并未清除，只是这些标记告诉我们可以从哪里开始往Buffer里写数据。如果Buffer中有一些未读的数据，调用<code>clear()</code>方法，数据将“被遗忘”，意味着不再有任何标记会告诉你哪些数据被读过，哪些还没有。</p></li><li><p>如果Buffer中仍有未读的数据，且后续还需要这些数据，但是此时想要先先写些数据，那么使用<code>compact()</code>方法。<code>compact()</code>方法将所有未读的数据拷贝到Buffer起始处。然后将position设到最后一个未读元素正后面。limit属性依然像<code>clear()</code>方法一样，设置成capacity。现在Buffer准备好写数据了，但是不会覆盖未读的数据。</p></li></ul><h3 id="mark-与reset-方法"><a href="#mark-与reset-方法" class="headerlink" title="mark()与reset()方法"></a>mark()与reset()方法</h3><p>通过调用<code>Buffer.mark()</code>方法，可以标记Buffer中的一个特定position。之后可以通过调用<code>Buffer.reset()</code>方法恢复到这个position。例如：</p><pre><code>buffer.mark();//call buffer.get() a couple of times, e.g. during parsing.buffer.reset(); //set position back to mark.</code></pre><h3 id="equals-与compareTo-方法"><a href="#equals-与compareTo-方法" class="headerlink" title="equals()与compareTo()方法"></a>equals()与compareTo()方法</h3><p>可以使用<code>equals()</code>和<code>compareTo()</code>方法两个Buffer。 ####equals() 当满足下列条件时，表示两个Buffer相等：</p><ol><li>有相同的类型（byte、char、int等）。</li><li>Buffer中剩余的byte、char等的个数相等。</li><li>Buffer中所有剩余的byte、char等都相同。</li></ol><p>如你所见，equals只是比较Buffer的一部分，不是每一个在它里面的元素都比较。实际上，它只比较Buffer中的剩余元素。 ####compareTo()方法 <code>compareTo()</code>方法比较两个Buffer的剩余元素(byte、char等)， 如果满足下列条件，则认为一个Buffer“小于”另一个Buffer：</p><ol><li>第一个不相等的元素小于另一个Buffer中对应的元素 。</li><li>所有元素都相等，但第一个Buffer比另一个先耗尽(第一个Buffer的元素个数比另一个少。</li></ol><p>（译注：剩余元素是从 position到limit之间的元素）</p><hr><h2 id="四、Scatter-Gather"><a href="#四、Scatter-Gather" class="headerlink" title="四、Scatter/Gather"></a>四、Scatter/Gather</h2><p>Java NIO开始支持scatter/gather，scatter/gather用于描述从Channel（译者注：Channel在中文经常翻译为通道）中读取或者写入到Channel的操作。</p><ul><li><strong>分散（scatter）</strong>：从Channel中读取是指在读操作时将读取的数据写入多个buffer中。因此，Channel将从Channel中读取的数据“分散（scatter）”到多个Buffer中。</li><li><strong>聚集（gather）</strong>：写入Channel是指在写操作时将多个buffer的数据写入同一个Channel，因此，Channel 将多个Buffer中的数据“聚集（gather）”后发送到Channel。</li></ul><p>scatter / gather经常用于需要将传输的数据分开处理的场合，例如传输一个由消息头和消息体组成的消息，你可能会将消息体和消息头分散到不同的buffer中，这样你可以方便的处理消息头和消息体。 ###Scattering Reads Scattering Reads是指数据从一个channel读取到多个buffer中。如下图描述： <img data-src="https://cdn.javacodes.cn/files/2017/03/2017-03-14_17-35-10-2.jpg" alt="">￼ 代码示例如下：</p><pre><code>ByteBuffer header = ByteBuffer.allocate(128);ByteBuffer body = ByteBuffer.allocate(1024);ByteBuffer[] bufferArray = { header, body };channel.read(bufferArray);</code></pre><p>注意buffer首先被插入到数组，然后再将数组作为<code>channel.read()</code> 的输入参数。<code>read()</code>方法按照buffer在数组中的顺序将从channel中读取的数据写入到buffer，当一个buffer被写满后，channel紧接着向另一个buffer中写。 Scattering Reads在移动下一个buffer前，必须填满当前的buffer，这也意味着它不适用于动态消息(译者注：消息大小不固定)。换句话说，如果存在消息头和消息体，消息头必须完成填充（例如 128byte），Scattering Reads才能正常工作。</p><h3 id="Gathering-Writes"><a href="#Gathering-Writes" class="headerlink" title="Gathering Writes"></a>Gathering Writes</h3><p>Gathering Writes是指数据从多个buffer写入到同一个channel。如下图描述： <img data-src="https://cdn.javacodes.cn/files/2017/03/2017-03-14_17-35-10-3.jpg" alt="">￼ 代码示例如下：</p><pre><code>ByteBuffer header = ByteBuffer.allocate(128);ByteBuffer body = ByteBuffer.allocate(1024);//write data into buffersByteBuffer[] bufferArray = { header, body };channel.write(bufferArray);</code></pre><p>buffers数组是<code>write()</code>方法的入参，write()方法会按照buffer在数组中的顺序，将数据写入到channel，注意只有position和limit之间的数据才会被写入。因此，如果一个buffer的容量为128byte，但是仅仅包含58byte的数据，那么这58byte的数据将被写入到channel中。因此与Scattering Reads相反，Gathering Writes能较好的处理动态消息。</p><hr><h2 id="五、通道之间的数据传输"><a href="#五、通道之间的数据传输" class="headerlink" title="五、通道之间的数据传输"></a>五、通道之间的数据传输</h2><p>在Java NIO中，如果两个通道中有一个是FileChannel，那你可以直接将数据从一个channel（译者注：channel中文常译作通道）传输到另外一个channel。</p><h3 id="transferFrom"><a href="#transferFrom" class="headerlink" title="transferFrom()"></a>transferFrom()</h3><p>FileChannel的<code>transferFrom()</code>方法可以将数据从源通道传输到FileChannel中（译者注：这个方法在JDK文档中的解释为将字节从给定的可读取字节通道传输到此通道的文件中）。下面是一个简单的例子：</p><pre><code>javaRandomAccessFile fromFile = new RandomAccessFile(&quot;fromFile.txt&quot;, &quot;rw&quot;);FileChannel fromChannel = fromFile.getChannel();RandomAccessFile toFile = new RandomAccessFile(&quot;toFile.txt&quot;, &quot;rw&quot;);FileChannel toChannel = toFile.getChannel();long position = 0;long count = fromChannel.size();toChannel.transferFrom(fromChannel, position, count);</code></pre><p>方法的输入参数position表示从position处开始向目标文件写入数据，count表示最多传输的字节数。如果源通道的剩余空间小于 count 个字节，则所传输的字节数要小于请求的字节数。 此外要注意，在SoketChannel的实现中，SocketChannel只会传输此刻准备好的数据（可能不足count字节）。因此，SocketChannel可能不会将请求的所有数据(count个字节)全部传输到FileChannel中。</p><h3 id="transferTo"><a href="#transferTo" class="headerlink" title="transferTo()"></a>transferTo()</h3><p><code>transferTo()</code>方法将数据从FileChannel传输到其他的channel中。下面是一个简单的例子：</p><pre><code>RandomAccessFile fromFile = new RandomAccessFile(&quot;fromFile.txt&quot;, &quot;rw&quot;);FileChannel fromChannel = fromFile.getChannel();RandomAccessFile toFile = new RandomAccessFile(&quot;toFile.txt&quot;, &quot;rw&quot;);FileChannel toChannel = toFile.getChannel();long position = 0;long count = fromChannel.size();fromChannel.transferTo(position, count, toChannel);</code></pre><p>是不是发现这个例子和前面那个例子特别相似？除了调用方法的FileChannel对象不一样外，其他的都一样。 上面所说的关于SocketChannel的问题在<code>transferTo()</code>方法中同样存在。SocketChannel会一直传输数据直到目标buffer被填满。</p><hr><h2 id="六、Selector"><a href="#六、Selector" class="headerlink" title="六、Selector"></a>六、Selector</h2><p>Selector（选择器）是Java NIO中能够检测一到多个NIO通道，并能够知晓通道是否为诸如读写事件做好准备的组件。这样，一个单独的线程可以管理多个channel，从而管理多个网络连接。</p><h3 id="为什么使用Selector"><a href="#为什么使用Selector" class="headerlink" title="为什么使用Selector?"></a>为什么使用Selector?</h3><p>仅用单个线程来处理多个Channels的好处是，只需要更少的线程来处理通道。事实上，可以只用一个线程处理所有的通道。对于操作系统来说，线程之间上下文切换的开销很大，而且每个线程都要占用系统的一些资源（如内存）。因此，使用的线程越少越好。 但是，需要记住，现代的操作系统和CPU在多任务方面表现的越来越好，所以多线程的开销随着时间的推移，变得越来越小了。实际上，如果一个CPU有多个内核，不使用多任务可能是在浪费CPU能力。不管怎么说，关于那种设计的讨论应该放在另一篇不同的文章中。在这里，只要知道使用Selector能够处理多个通道就足够了。 下面是单线程使用一个Selector处理3个channel的示例图： <img data-src="https://cdn.javacodes.cn/files/2017/03/2017-03-14_17-35-14-3.jpg" alt="">￼</p><h3 id="Selector的创建"><a href="#Selector的创建" class="headerlink" title="Selector的创建"></a>Selector的创建</h3><p>通过调用<code>Selector.open()</code>方法创建一个Selector，如下：</p><pre><code>Selector selector = Selector.open();</code></pre><h3 id="向Selector注册通道"><a href="#向Selector注册通道" class="headerlink" title="向Selector注册通道"></a>向Selector注册通道</h3><p>为了将Channel和Selector配合使用，必须将channel注册到selector上。通过 <code>SelectableChannel.register()</code>方法来实现，如下：</p><pre><code>channel.configureBlocking(false);SelectionKey key = channel.register(selector, Selectionkey.OP_READ);</code></pre><p>与Selector一起使用时，Channel必须处于非阻塞模式下。这意味着不能将FileChannel与Selector一起使用，因为FileChannel不能切换到非阻塞模式。而套接字通道都可以。 注意register()方法的第二个参数。这是一个“interest集合”，意思是在通过Selector监听Channel时对什么事件感兴趣。可以监听四种不同类型的事件：</p><ol><li>Connect</li><li>Accept</li><li>Read</li><li>Write</li></ol><p>通道触发了一个事件意思是该事件已经就绪。所以，某个channel成功连接到另一个服务器称为“连接就绪”。一个server socket channel准备好接收新进入的连接称为“接收就绪”。一个有数据可读的通道可以说是“读就绪”。等待写数据的通道可以说是“写就绪”。 这四种事件用SelectionKey的四个常量来表示：</p><ol><li>SelectionKey.OP_CONNECT</li><li>SelectionKey.OP_ACCEPT</li><li>SelectionKey.OP_READ</li><li>SelectionKey.OP_WRITE</li></ol><p>如果你对不止一种事件感兴趣，那么可以用“位或”操作符将常量连接起来，如下：</p><pre><code>int interestSet = SelectionKey.OP_READ | SelectionKey.OP_WRITE;</code></pre><p>在下面还会继续提到interest集合。</p><h3 id="SelectionKey"><a href="#SelectionKey" class="headerlink" title="SelectionKey"></a>SelectionKey</h3><p>在上一小节中，当向Selector注册Channel时，register()方法会返回一个SelectionKey对象。这个对象包含了一些你感兴趣的属性：</p><ul><li>interest集合</li><li>ready集合</li><li>Channel</li><li>Selector</li><li>附加的对象（可选）</li></ul><p>下面我会描述这些属性。</p><h4 id="interest集合"><a href="#interest集合" class="headerlink" title="interest集合"></a>interest集合</h4><p>就像向Selector注册通道一节中所描述的，interest集合是你所选择的感兴趣的事件集合。可以通过SelectionKey读写interest集合，像这样：</p><pre><code>int interestSet = selectionKey.interestOps();boolean isInterestedInAccept = (interestSet &amp; SelectionKey.OP_ACCEPT) == SelectionKey.OP_ACCEPT；boolean isInterestedInConnect = interestSet &amp; SelectionKey.OP_CONNECT;boolean isInterestedInRead = interestSet &amp; SelectionKey.OP_READ;boolean isInterestedInWrite = interestSet &amp; SelectionKey.OP_WRITE;</code></pre><p>可以看到，用“位与”操作interest 集合和给定的SelectionKey常量，可以确定某个确定的事件是否在interest 集合中。</p><h4 id="ready集合"><a href="#ready集合" class="headerlink" title="ready集合"></a>ready集合</h4><p>ready 集合是通道已经准备就绪的操作的集合。在一次选择(Selection)之后，你会首先访问这个ready set。Selection将在下一小节进行解释。可以这样访问ready集合：</p><pre><code>int readySet = selectionKey.readyOps();</code></pre><p>可以用像检测interest集合那样的方法，来检测channel中什么事件或操作已经就绪。但是，也可以使用以下四个方法，它们都会返回一个布尔类型：</p><pre><code>selectionKey.isAcceptable();selectionKey.isConnectable();selectionKey.isReadable();selectionKey.isWritable();</code></pre><h4 id="Channel-Selector"><a href="#Channel-Selector" class="headerlink" title="Channel + Selector"></a>Channel + Selector</h4><p>从SelectionKey访问Channel和Selector很简单。如下：</p><pre><code>Channel channel = selectionKey.channel();Selector selector = selectionKey.selector();</code></pre><h4 id="附加的对象"><a href="#附加的对象" class="headerlink" title="附加的对象"></a>附加的对象</h4><p>可以将一个对象或者更多信息附着到SelectionKey上，这样就能方便的识别某个给定的通道。例如，可以附加 与通道一起使用的Buffer，或是包含聚集数据的某个对象。使用方法如下：</p><pre><code>selectionKey.attach(theObject);Object attachedObj = selectionKey.attachment();</code></pre><p>还可以在用<code>register()</code>方法向Selector注册Channel的时候附加对象。如：</p><pre><code>SelectionKey key = channel.register(selector, SelectionKey.OP_READ, theObject);</code></pre><h3 id="通过Selector选择通道"><a href="#通过Selector选择通道" class="headerlink" title="通过Selector选择通道"></a>通过Selector选择通道</h3><p>一旦向Selector注册了一或多个通道，就可以调用几个重载的<code>select()</code>方法。这些方法返回你所感兴趣的事件（如连接、接受、读或写）已经准备就绪的那些通道。换句话说，如果你对“读就绪”的通道感兴趣，<code>select()</code>方法会返回读事件已经就绪的那些通道。 下面是select()方法：</p><ul><li>int select()：阻塞到至少有一个通道在你注册的事件上就绪了。</li><li>int select(long timeout)：和<code>select()</code>一样，除了最长会阻塞timeout毫秒(参数)。</li><li>int selectNow()：不会阻塞，不管什么通道就绪都立刻返回（译者注：此方法执行非阻塞的选择操作。如果自从前一次选择操作后，没有通道变成可选择的，则此方法直接返回零）。</li></ul><p><code>select()</code>方法返回的int值表示有多少通道已经就绪。亦即，自上次调用<code>select()</code>方法后有多少通道变成就绪状态。如果调用<code>select()</code>方法，因为有一个通道变成就绪状态，返回了1，若再次调用<code>select()</code>方法，如果另一个通道就绪了，它会再次返回1。如果对第一个就绪的channel没有做任何操作，现在就有两个就绪的通道，但在每次<code>select()</code>方法调用之间，只有一个通道就绪了。</p><h3 id="selectedKeys"><a href="#selectedKeys" class="headerlink" title="selectedKeys()"></a>selectedKeys()</h3><p>一旦调用了<code>select()</code>方法，并且返回值表明有一个或更多个通道就绪了，然后可以通过调用selector的<code>selectedKeys()</code>方法，访问“已选择键集（selected key set）”中的就绪通道。如下所示：</p><pre><code>Set selectedKeys = selector.selectedKeys();</code></pre><p>当像Selector注册Channel时，<code>Channel.register()</code>方法会返回一个SelectionKey 对象。这个对象代表了注册到该Selector的通道。可以通过SelectionKey的<code>selectedKeySet()</code>方法访问这些对象。 可以遍历这个已选择的键集合来访问就绪的通道。如下：</p><pre><code>Set selectedKeys = selector.selectedKeys();Iterator keyIterator = selectedKeys.iterator();while(keyIterator.hasNext()) {    SelectionKey key = keyIterator.next();    if(key.isAcceptable()) {        // a connection was accepted by a ServerSocketChannel.    } else if (key.isConnectable()) {        // a connection was established with a remote server.    } else if (key.isReadable()) {        // a channel is ready for reading    } else if (key.isWritable()) {        // a channel is ready for writing    }    keyIterator.remove();}</code></pre><p>这个循环遍历已选择键集中的每个键，并检测各个键所对应的通道的就绪事件。 注意每次迭代末尾的<code>keyIterator.remove()</code>调用。Selector不会自己从已选择键集中移除SelectionKey实例。必须在处理完通道时自己移除。下次该通道变成就绪时，Selector会再次将其放入已选择键集中。 <code>SelectionKey.channel()</code>方法返回的通道需要转型成你要处理的类型，如ServerSocketChannel或SocketChannel等。</p><h3 id="wakeUp"><a href="#wakeUp" class="headerlink" title="wakeUp()"></a>wakeUp()</h3><p>某个线程调用<code>select()</code>方法后阻塞了，即使没有通道已经就绪，也有办法让其从<code>select()</code>方法返回。只要让其它线程在第一个线程调用<code>select()</code>方法的那个对象上调用<code>Selector.wakeup()</code>方法即可。阻塞在select()方法上的线程会立马返回。 如果有其它线程调用了<code>wakeup()</code>方法，但当前没有线程阻塞在<code>select()</code>方法上，下个调用select()方法的线程会立即“醒来（wake up）”。</p><h3 id="close"><a href="#close" class="headerlink" title="close()"></a>close()</h3><p>用完Selector后调用其<code>close()</code>方法会关闭该Selector，且使注册到该Selector上的所有SelectionKey实例无效。通道本身并不会关闭。</p><h3 id="完整的示例"><a href="#完整的示例" class="headerlink" title="完整的示例"></a>完整的示例</h3><p>这里有一个完整的示例，打开一个Selector，注册一个通道注册到这个Selector上(通道的初始化过程略去),然后持续监控这个Selector的四种事件（接受，连接，读，写）是否就绪。</p><pre><code>Selector selector = Selector.open();channel.configureBlocking(false);SelectionKey key = channel.register(selector, SelectionKey.OP_READ);while(true) {  int readyChannels = selector.select();  if(readyChannels == 0) continue;  Set selectedKeys = selector.selectedKeys();  Iterator keyIterator = selectedKeys.iterator();  while(keyIterator.hasNext()) {    SelectionKey key = keyIterator.next();    if(key.isAcceptable()) {        // a connection was accepted by a ServerSocketChannel.    } else if (key.isConnectable()) {        // a connection was established with a remote server.    } else if (key.isReadable()) {        // a channel is ready for reading    } else if (key.isWritable()) {        // a channel is ready for writing    }    keyIterator.remove();  }}</code></pre><hr><h2 id="七、FileChannel"><a href="#七、FileChannel" class="headerlink" title="七、FileChannel"></a>七、FileChannel</h2><p>Java NIO中的FileChannel是一个连接到文件的通道。可以通过文件通道读写文件。 FileChannel无法设置为非阻塞模式，它总是运行在阻塞模式下。</p><h3 id="打开FileChannel"><a href="#打开FileChannel" class="headerlink" title="打开FileChannel"></a>打开FileChannel</h3><p>在使用FileChannel之前，必须先打开它。但是，我们无法直接打开一个FileChannel，需要通过使用一个InputStream、OutputStream或RandomAccessFile来获取一个FileChannel实例。 下面是通过RandomAccessFile打开FileChannel的示例：</p><pre><code>RandomAccessFile aFile = new RandomAccessFile(&quot;data/nio-data.txt&quot;, &quot;rw&quot;);FileChannel inChannel = aFile.getChannel();</code></pre><h3 id="从FileChannel读取数据"><a href="#从FileChannel读取数据" class="headerlink" title="从FileChannel读取数据"></a>从FileChannel读取数据</h3><p>调用多个<code>read()</code>方法之一从FileChannel中读取数据。如：</p><pre><code>ByteBuffer buf = ByteBuffer.allocate(48);int bytesRead = inChannel.read(buf);</code></pre><p>首先，分配一个Buffer。从FileChannel中读取的数据将被读到Buffer中。 然后，调用FileChannel.read()方法。该方法将数据从FileChannel读取到Buffer中。read()方法返回的int值表示了有多少字节被读到了Buffer中。如果返回-1，表示到了文件末尾。</p><h3 id="向FileChannel写数据"><a href="#向FileChannel写数据" class="headerlink" title="向FileChannel写数据"></a>向FileChannel写数据</h3><p>使用<code>FileChannel.write()</code>方法向FileChannel写数据，该方法的参数是一个Buffer。如：</p><pre><code>String newData = &quot;New String to write to file...&quot; + System.currentTimeMillis();ByteBuffer buf = ByteBuffer.allocate(48);buf.clear();buf.put(newData.getBytes());buf.flip();while(buf.hasRemaining()) {    channel.write(buf);}</code></pre><p>注意<code>FileChannel.write()</code>是在while循环中调用的。因为无法保证<code>write()</code>方法一次能向FileChannel写入多少字节，因此需要重复调用<code>write()</code>方法，直到Buffer中已经没有尚未写入通道的字节。</p><h3 id="关闭FileChannel"><a href="#关闭FileChannel" class="headerlink" title="关闭FileChannel"></a>关闭FileChannel</h3><p>用完FileChannel后必须将其关闭。如：</p><pre><code>channel.close();</code></pre><h3 id="FileChannel的position方法"><a href="#FileChannel的position方法" class="headerlink" title="FileChannel的position方法"></a>FileChannel的position方法</h3><p>有时可能需要在FileChannel的某个特定位置进行数据的读/写操作。可以通过调用<code>position()</code>方法获取FileChannel的当前位置。 也可以通过调用<code>position(long pos)</code>方法设置FileChannel的当前位置。 这里有两个例子:</p><pre><code>long pos = channel.position();channel.position(pos +123);</code></pre><ul><li>如果将位置设置在文件结束符之后，然后试图从文件通道中读取数据，读方法将返回-1 —— 文件结束标志。</li><li>如果将位置设置在文件结束符之后，然后向通道中写数据，文件将撑大到当前位置并写入数据。这可能导致“文件空洞”，磁盘上物理文件中写入的数据间有空隙。</li></ul><h3 id="FileChannel的size方法"><a href="#FileChannel的size方法" class="headerlink" title="FileChannel的size方法"></a>FileChannel的size方法</h3><p>FileChannel实例的<code>size()</code>方法将返回该实例所关联文件的大小。如:</p><pre><code>long fileSize = channel.size();</code></pre><h3 id="FileChannel的truncate方法"><a href="#FileChannel的truncate方法" class="headerlink" title="FileChannel的truncate方法"></a>FileChannel的truncate方法</h3><p>可以使用<code>FileChannel.truncate()</code>方法截取一个文件。截取文件时，文件将中指定长度后面的部分将被删除。如：</p><pre><code>channel.truncate(1024);</code></pre><p>这个例子截取文件的前1024个字节。</p><h3 id="FileChannel的force方法"><a href="#FileChannel的force方法" class="headerlink" title="FileChannel的force方法"></a>FileChannel的force方法</h3><p><code>FileChannel.force()</code>方法将通道里尚未写入磁盘的数据强制写到磁盘上。出于性能方面的考虑，操作系统会将数据缓存在内存中，所以无法保证写入到FileChannel里的数据一定会即时写到磁盘上。要保证这一点，需要调用<code>force()</code>方法。 <code>force()</code>方法有一个boolean类型的参数，指明是否同时将文件元数据（权限信息等）写到磁盘上。 下面的例子同时将文件数据和元数据强制写到磁盘上：</p><pre><code>channel.force(true);</code></pre><hr><h2 id="八、SocketChannel"><a href="#八、SocketChannel" class="headerlink" title="八、SocketChannel"></a>八、SocketChannel</h2><p>Java NIO中的SocketChannel是一个连接到TCP网络套接字的通道。可以通过以下2种方式创建SocketChannel：</p><ol><li>打开一个SocketChannel并连接到互联网上的某台服务器。</li><li>一个新连接到达ServerSocketChannel时，会创建一个SocketChannel。</li></ol><h3 id="打开-SocketChannel"><a href="#打开-SocketChannel" class="headerlink" title="打开 SocketChannel"></a>打开 SocketChannel</h3><p>下面是SocketChannel的打开方式：</p><pre><code>SocketChannel socketChannel = SocketChannel.open();socketChannel.connect(new InetSocketAddress(&quot;http://jenkov.com&quot;, 80));</code></pre><h3 id="关闭-SocketChannel"><a href="#关闭-SocketChannel" class="headerlink" title="关闭 SocketChannel"></a>关闭 SocketChannel</h3><p>当用完SocketChannel之后调用<code>SocketChannel.close()</code>关闭SocketChannel：</p><pre><code>socketChannel.close();</code></pre><h3 id="从-SocketChannel-读取数据"><a href="#从-SocketChannel-读取数据" class="headerlink" title="从 SocketChannel 读取数据"></a>从 SocketChannel 读取数据</h3><p>要从SocketChannel中读取数据，调用一个<code>read()</code>的方法之一。以下是例子：</p><pre><code>ByteBuffer buf = ByteBuffer.allocate(48);int bytesRead = socketChannel.read(buf);</code></pre><p>首先，分配一个Buffer。从SocketChannel读取到的数据将会放到这个Buffer中。 然后，调用<code>SocketChannel.read()</code>。该方法将数据从SocketChannel 读到Buffer中。read()方法返回的int值表示读了多少字节进Buffer里。如果返回的是-1，表示已经读到了流的末尾（连接关闭了）。</p><h3 id="写入-SocketChannel"><a href="#写入-SocketChannel" class="headerlink" title="写入 SocketChannel"></a>写入 SocketChannel</h3><p>写数据到SocketChannel用的是<code>SocketChannel.write()</code>方法，该方法以一个Buffer作为参数。示例如下：</p><pre><code>String newData = &quot;New String to write to file...&quot; + System.currentTimeMillis();ByteBuffer buf = ByteBuffer.allocate(48);buf.clear();buf.put(newData.getBytes());buf.flip();while(buf.hasRemaining()) {    channel.write(buf);}</code></pre><p>注意<code>SocketChannel.write()</code>方法的调用是在一个while循环中的。<code>write()</code>方法无法保证能写多少字节到SocketChannel。所以，我们重复调用<code>write()</code>直到Buffer没有要写的字节为止。</p><h3 id="非阻塞模式"><a href="#非阻塞模式" class="headerlink" title="非阻塞模式"></a>非阻塞模式</h3><p>可以设置 SocketChannel 为非阻塞模式（non-blocking mode）.设置之后，就可以在异步模式下调用<code>connect()</code>,<code>read()</code>和<code>write()</code>了。</p><h4 id="connect"><a href="#connect" class="headerlink" title="connect()"></a>connect()</h4><p>如果SocketChannel在非阻塞模式下，此时调用<code>connect()</code>，该方法可能在连接建立之前就返回了。为了确定连接是否建立，可以调用<code>finishConnect()</code>的方法。像这样：</p><pre><code>socketChannel.configureBlocking(false);socketChannel.connect(new InetSocketAddress(&quot;http://jenkov.com&quot;, 80));while(! socketChannel.finishConnect() ){    //wait, or do something else...    }</code></pre><h4 id="write"><a href="#write" class="headerlink" title="write()"></a>write()</h4><p>非阻塞模式下，<code>write()</code>方法在尚未写出任何内容时可能就返回了。所以需要在循环中调用<code>write()</code>。前面已经有例子了，这里就不赘述了。</p><h4 id="read"><a href="#read" class="headerlink" title="read()"></a>read()</h4><p>非阻塞模式下,<code>read()</code>方法在尚未读取到任何数据时可能就返回了。所以需要关注它的int返回值，它会告诉你读取了多少字节。</p><h4 id="非阻塞模式与选择器"><a href="#非阻塞模式与选择器" class="headerlink" title="非阻塞模式与选择器"></a>非阻塞模式与选择器</h4><p>非阻塞模式与选择器搭配会工作的更好，通过将一或多个SocketChannel注册到Selector，可以询问选择器哪个通道已经准备好了读取，写入等。Selector与SocketChannel的搭配使用会在后面详讲。</p><hr><h2 id="九、ServerSocketChannel"><a href="#九、ServerSocketChannel" class="headerlink" title="九、ServerSocketChannel"></a>九、ServerSocketChannel</h2><p>Java NIO中的 ServerSocketChannel 是一个可以监听新进来的TCP连接的通道, 就像标准IO中的ServerSocket一样。ServerSocketChannel类在<code>java.nio.channels</code>包中。 这里有个例子：</p><pre><code>ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();serverSocketChannel.socket().bind(new InetSocketAddress(9999));while(true){    SocketChannel socketChannel =            serverSocketChannel.accept();    //do something with socketChannel...}</code></pre><h3 id="打开-ServerSocketChannel"><a href="#打开-ServerSocketChannel" class="headerlink" title="打开 ServerSocketChannel"></a>打开 ServerSocketChannel</h3><p>通过调用 <code>ServerSocketChannel.open()</code>方法来打开ServerSocketChannel.如：</p><pre><code>ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();</code></pre><h3 id="关闭-ServerSocketChannel"><a href="#关闭-ServerSocketChannel" class="headerlink" title="关闭 ServerSocketChannel"></a>关闭 ServerSocketChannel</h3><p>通过调用<code>ServerSocketChannel.close()</code>方法来关闭ServerSocketChannel. 如：</p><pre><code>serverSocketChannel.close();</code></pre><h3 id="监听新进来的连接"><a href="#监听新进来的连接" class="headerlink" title="监听新进来的连接"></a>监听新进来的连接</h3><p>通过 <code>ServerSocketChannel.accept()</code>方法监听新进来的连接。当 <code>accept()</code>方法返回的时候,它返回一个包含新进来的连接的 SocketChannel。因此, <code>accept()</code>方法会一直阻塞到有新连接到达。 通常不会仅仅只监听一个连接,在while循环中调用 <code>accept()</code>方法. 如下面的例子：</p><pre><code>while(true){    SocketChannel socketChannel =            serverSocketChannel.accept();    //do something with socketChannel...}</code></pre><p>当然,也可以在while循环中使用除了true以外的其它退出准则。</p><h3 id="非阻塞模式-1"><a href="#非阻塞模式-1" class="headerlink" title="非阻塞模式"></a>非阻塞模式</h3><p>ServerSocketChannel可以设置成非阻塞模式。在非阻塞模式下，<code>accept()</code>方法会立刻返回，如果还没有新进来的连接,返回的将是null。 因此，需要检查返回的SocketChannel是否是null.如：</p><pre><code>ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();serverSocketChannel.socket().bind(new InetSocketAddress(9999));serverSocketChannel.configureBlocking(false);while(true){    SocketChannel socketChannel =            serverSocketChannel.accept();    if(socketChannel != null){        //do something with socketChannel...    }}</code></pre><hr><h2 id="十、DatagramChannel"><a href="#十、DatagramChannel" class="headerlink" title="十、DatagramChannel"></a>十、DatagramChannel</h2><p>Java NIO中的DatagramChannel是一个能收发UDP包的通道。因为UDP是无连接的网络协议，所以不能像其它通道那样读取和写入。它发送和接收的是数据包。</p><h3 id="打开-DatagramChannel"><a href="#打开-DatagramChannel" class="headerlink" title="打开 DatagramChannel"></a>打开 DatagramChannel</h3><p>下面是 DatagramChannel 的打开方式：</p><pre><code>DatagramChannel channel = DatagramChannel.open();channel.socket().bind(new InetSocketAddress(9999));</code></pre><p>这个例子打开的 DatagramChannel可以在UDP端口9999上接收数据包。</p><h3 id="接收数据"><a href="#接收数据" class="headerlink" title="接收数据"></a>接收数据</h3><p>通过<code>receive()</code>方法从DatagramChannel接收数据，如：</p><pre><code>ByteBuffer buf = ByteBuffer.allocate(48);buf.clear();channel.receive(buf);</code></pre><p><code>receive()</code>方法会将接收到的数据包内容复制到指定的Buffer. 如果Buffer容不下收到的数据，多出的数据将被丢弃。</p><h3 id="发送数据"><a href="#发送数据" class="headerlink" title="发送数据"></a>发送数据</h3><p>通过<code>send()</code>方法从DatagramChannel发送数据，如:</p><pre><code>String newData = &quot;New String to write to file...&quot;                    + System.currentTimeMillis();ByteBuffer buf = ByteBuffer.allocate(48);buf.clear();buf.put(newData.getBytes());buf.flip();int bytesSent = channel.send(buf, new InetSocketAddress(&quot;jenkov.com&quot;, 80));</code></pre><p>这个例子发送一串字符到”jenkov.com”服务器的UDP端口80。 因为服务端并没有监控这个端口，所以什么也不会发生。也不会通知你发出的数据包是否已收到，因为UDP在数据传送方面没有任何保证。</p><h3 id="连接到特定的地址"><a href="#连接到特定的地址" class="headerlink" title="连接到特定的地址"></a>连接到特定的地址</h3><p>可以将DatagramChannel“连接”到网络中的特定地址的。由于UDP是无连接的，连接到特定地址并不会像TCP通道那样创建一个真正的连接。而是锁住DatagramChannel ，让其只能从特定地址收发数据。 这里有个例子:</p><pre><code>channel.connect(new InetSocketAddress(&quot;jenkov.com&quot;, 80));</code></pre><p>当连接后，也可以使用<code>read()</code>和<code>write()</code>方法，就像在用传统的通道一样。只是在数据传送方面没有任何保证。这里有几个例子：</p><pre><code>int bytesRead = channel.read(buf);int bytesWritten = channel.write(but);</code></pre><hr><h2 id="十一、Pipe"><a href="#十一、Pipe" class="headerlink" title="十一、Pipe"></a>十一、Pipe</h2><p>Java NIO 管道是2个线程之间的单向数据连接。Pipe有一个source通道和一个sink通道。数据会被写到sink通道，从source通道读取。 这里是Pipe原理的图示： <img data-src="https://cdn.javacodes.cn/files/2017/03/2017-03-14_17-35-14-2.jpg" alt="">￼</p><h3 id="创建管道"><a href="#创建管道" class="headerlink" title="创建管道"></a>创建管道</h3><p>通过<code>Pipe.open()</code>方法打开管道。例如：</p><pre><code>Pipe pipe = Pipe.open();</code></pre><h3 id="向管道写数据"><a href="#向管道写数据" class="headerlink" title="向管道写数据"></a>向管道写数据</h3><p>要向管道写数据，需要访问sink通道。像这样：</p><pre><code>Pipe.SinkChannel sinkChannel = pipe.sink();</code></pre><p>通过调用SinkChannel的<code>write()</code>方法，将数据写入SinkChannel,像这样：</p><pre><code>String newData = &quot;New String to write to file...&quot; + System.currentTimeMillis();ByteBuffer buf = ByteBuffer.allocate(48);buf.clear();buf.put(newData.getBytes());buf.flip();while(buf.hasRemaining()) {    sinkChannel.write(buf);}</code></pre><h3 id="从管道读取数据"><a href="#从管道读取数据" class="headerlink" title="从管道读取数据"></a>从管道读取数据</h3><p>从读取管道的数据，需要访问source通道，像这样：</p><pre><code>Pipe.SourceChannel sourceChannel = pipe.source();</code></pre><p>调用source通道的<code>read()</code>方法来读取数据，像这样：</p><pre><code>ByteBuffer buf = ByteBuffer.allocate(48);int bytesRead = sourceChannel.read(buf);</code></pre><p><code>read()</code>方法返回的int值会告诉我们多少字节被读进了缓冲区。</p><hr><h2 id="十二、NIO与IO"><a href="#十二、NIO与IO" class="headerlink" title="十二、NIO与IO"></a>十二、NIO与IO</h2><p>当学习了Java NIO和IO的API后，一个问题马上涌入脑海： 我应该何时使用IO，何时使用NIO呢？在本文中，我会尽量清晰地解析Java NIO和IO的差异、它们的使用场景，以及它们如何影响您的代码设计。</p><h3 id="Java-NIO和IO的主要区别"><a href="#Java-NIO和IO的主要区别" class="headerlink" title="Java NIO和IO的主要区别"></a>Java NIO和IO的主要区别</h3><p>下表总结了Java NIO和IO之间的主要差别，我会更详细地描述表中每部分的差异。</p><p>IO</p><p>NIO</p><p>面向流</p><p>面向缓冲</p><p>阻塞IO</p><p>非阻塞IO</p><p>无</p><p>选择器</p><h3 id="面向流与面向缓冲"><a href="#面向流与面向缓冲" class="headerlink" title="面向流与面向缓冲"></a>面向流与面向缓冲</h3><p>Java NIO和IO之间第一个最大的区别是，IO是面向流的，NIO是面向缓冲区的。 Java IO面向流意味着每次从流中读一个或多个字节，直至读取所有字节，它们没有被缓存在任何地方。此外，它不能前后移动流中的数据。如果需要前后移动从流中读取的数据，需要先将它缓存到一个缓冲区。 Java NIO的缓冲导向方法略有不同。数据读取到一个它稍后处理的缓冲区，需要时可在缓冲区中前后移动。这就增加了处理过程中的灵活性。但是，还需要检查是否该缓冲区中包含所有您需要处理的数据。而且，需确保当更多的数据读入缓冲区时，不要覆盖缓冲区里尚未处理的数据。</p><h3 id="阻塞与非阻塞IO"><a href="#阻塞与非阻塞IO" class="headerlink" title="阻塞与非阻塞IO"></a>阻塞与非阻塞IO</h3><p>Java IO的各种流是阻塞的。这意味着，当一个线程调用<code>read()</code>或 <code>write()</code>时，该线程被阻塞，直到有一些数据被读取，或数据完全写入。该线程在此期间不能再干任何事情了。 Java NIO的非阻塞模式，使一个线程从某通道发送请求读取数据，但是它仅能得到目前可用的数据，如果目前没有数据可用时，就什么都不会获取。而不是保持线程阻塞，所以直至数据变的可以读取之前，该线程可以继续做其他的事情。 非阻塞写也是如此。一个线程请求写入一些数据到某通道，但不需要等待它完全写入，这个线程同时可以去做别的事情。 线程通常将非阻塞IO的空闲时间用于在其它通道上执行IO操作，所以一个单独的线程现在可以管理多个输入和输出通道（channel）。</p><h3 id="选择器（Selectors）"><a href="#选择器（Selectors）" class="headerlink" title="选择器（Selectors）"></a>选择器（Selectors）</h3><p>Java NIO的选择器允许一个单独的线程来监视多个输入通道，你可以注册多个通道使用一个选择器，然后使用一个单独的线程来“选择”通道：这些通道里已经有可以处理的输入，或者选择已准备写入的通道。这种选择机制，使得一个单独的线程很容易来管理多个通道。</p><h3 id="NIO和IO如何影响应用程序的设计"><a href="#NIO和IO如何影响应用程序的设计" class="headerlink" title="NIO和IO如何影响应用程序的设计"></a>NIO和IO如何影响应用程序的设计</h3><p>无论您选择IO或NIO工具箱，可能会影响您应用程序设计的以下几个方面：</p><ol><li>对NIO或IO类的API调用。</li><li>数据处理。</li><li>用来处理数据的线程数。</li></ol><h4 id="API调用"><a href="#API调用" class="headerlink" title="API调用"></a>API调用</h4><p>当然，使用NIO的API调用时看起来与使用IO时有所不同，但这并不意外，因为并不是仅从一个InputStream逐字节读取，而是数据必须先读入缓冲区再处理。</p><h4 id="数据处理"><a href="#数据处理" class="headerlink" title="数据处理"></a>数据处理</h4><p>使用纯粹的NIO设计相较IO设计，数据处理也受到影响。 在IO设计中，我们从InputStream或 Reader逐字节读取数据。假设你正在处理一基于行的文本数据流，例如：</p><pre><code>Name: AnnaAge: 25Email: anna@mailserver.comPhone: 1234567890</code></pre><p>该文本行的流可以这样处理：</p><pre><code>InputStream input = ... ; // get the InputStream from the client socketBufferedReader reader = new BufferedReader(new InputStreamReader(input));String nameLine = reader.readLine();String ageLine = reader.readLine();String emailLine = reader.readLine();String phoneLine = reader.readLine();</code></pre><p>请注意处理状态由程序执行多久决定。换句话说，一旦<code>reader.readLine()</code>方法返回，你就知道肯定文本行就已读完， readline()阻塞直到整行读完，这就是原因。你也知道此行包含名称；同样，第二个<code>readline()</code>调用返回的时候，你知道这行包含年龄等。 正如你可以看到，该处理程序仅在有新数据读入时运行，并知道每步的数据是什么。一旦正在运行的线程已处理过读入的某些数据，该线程不会再回退数据（大多如此）。下图也说明了这条原则：</p><p><img data-src="https://cdn.javacodes.cn/files/2017/03/2017-03-14_17-35-14.jpg" alt="">￼</p><p><strong>Java IO: 从一个阻塞的流中读数据</strong></p><p>而一个NIO的实现会有所不同，下面是一个简单的例子：</p><pre><code>ByteBuffer buffer = ByteBuffer.allocate(48);int bytesRead = inChannel.read(buffer);</code></pre><p>注意第二行，从通道读取字节到ByteBuffer。当这个方法调用返回时，你不知道你所需的所有数据是否在缓冲区内。你所知道的是，该缓冲区包含一些字节，这使得处理有点困难。 假设第一次<code>read(buffer)</code>调用后，读入缓冲区的数据只有半行，例如，“Name:An”，你能处理数据吗？显然不能，需要等待，直到整行数据读入缓存，在此之前，对数据的任何处理毫无意义。 所以，你怎么知道是否该缓冲区包含足够的数据可以处理呢？好了，你不知道。发现的方法只能查看缓冲区中的数据。其结果是，在你知道所有数据都在缓冲区里之前，你必须检查几次缓冲区的数据。这不仅效率低下，而且可以使程序设计方案杂乱不堪。例如：</p><pre><code>ByteBuffer buffer = ByteBuffer.allocate(48);int bytesRead = inChannel.read(buffer);while(! bufferFull(bytesRead) ) {    bytesRead = inChannel.read(buffer);}</code></pre><p><code>bufferFull()</code>方法必须跟踪有多少数据读入缓冲区，并返回真或假，这取决于缓冲区是否已满。换句话说，如果缓冲区准备好被处理，那么表示缓冲区满了。 <code>bufferFull()</code>方法扫描缓冲区，但必须保持在<code>bufferFull()</code>方法被调用之前状态相同。如果没有，下一个读入缓冲区的数据可能无法读到正确的位置。这是不可能的，但却是需要注意的又一问题。 如果缓冲区已满，它可以被处理。如果它不满，并且在你的实际案例中有意义，你或许能处理其中的部分数据。但是许多情况下并非如此。 下图展示了“缓冲区数据循环就绪”：</p><p><img data-src="https://cdn.javacodes.cn/files/2017/03/2017-03-14_17-35-14-4.jpg" alt="">￼</p><p><strong>Java NIO:从一个通道里读数据，直到所有的数据都读到缓冲区里</strong></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>NIO可让您只使用一个（或几个）单线程管理多个通道（网络连接或文件），但付出的代价是解析数据可能会比从一个阻塞流中读取数据更复杂。 如果需要管理同时打开的成千上万个连接，这些连接每次只是发送少量的数据，例如聊天服务器，实现NIO的服务器可能是一个优势。同样，如果你需要维持许多打开的连接到其他计算机上，如P2P网络中，使用一个单独的线程来管理你所有出站连接，可能是一个优势。一个线程多个连接的设计方案如下图所示：</p><p><img data-src="https://cdn.javacodes.cn/files/2017/03/2017-03-14_17-35-14-1.jpg" alt="">￼</p><p><strong>Java NIO: 单线程管理多个连接</strong></p><p>如果你有少量的连接使用非常高的带宽，一次发送大量的数据，也许典型的IO服务器实现可能非常契合。下图说明了一个典型的IO服务器设计：</p><p><img data-src="https://cdn.javacodes.cn/files/2017/03/2017-03-14_17-35-15.jpg" alt="">￼</p><p><strong>Java IO: 一个典型的IO服务器设计- 一个连接通过一个线程处理</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;英文原文地址：&lt;a href=&quot;http://tutorials.jenkov.com/java-nio/index.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://tutorials.jenkov.com/java-nio/index.html&lt;/a&gt; 中文来源地址：&lt;a href=&quot;http://ifeve.com/java-nio-all/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://ifeve.com/java-nio-all/&lt;/a&gt; 作者：Jakob Jenkov 译者：郭蕾 校对：方腾飞 本文由&lt;a href=&quot;https://cdn.javacodes.cn&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;老H博客&lt;/a&gt;整理修订&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;[TOC] Java NIO(New IO)是一个可以替代标准Java IO API的IO API（从Java 1.4开始)，Java NIO提供了与标准IO不同的IO工作方式。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Java NIO: Channels and Buffers（通道和缓冲区）&lt;/strong&gt;：标准的IO基于字节流和字符流进行操作的，而NIO是基于通道（Channel）和缓冲区（Buffer）进行操作，数据总是从通道读取到缓冲区中，或者从缓冲区写入到通道中。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Java NIO: Non-blocking IO（非阻塞IO）&lt;/strong&gt;：Java NIO可以让你非阻塞的使用IO，例如：当线程从通道读取数据到缓冲区时，线程还是可以进行其他事情。当数据被写入到缓冲区时，线程可以继续处理它。从缓冲区写入通道也类似。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Java NIO: Selectors（选择器）&lt;/strong&gt;：Java NIO引入了选择器的概念，选择器用于监听多个通道的事件（比如：连接打开，数据到达）。因此，单个的线程可以监听多个数据通道。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="JAVA" scheme="http://yoursite.com/categories/JAVA/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="NIO" scheme="http://yoursite.com/tags/NIO/"/>
    
  </entry>
  
  <entry>
    <title>Java中的Copy-On-Write容器</title>
    <link href="http://yoursite.com/2017/03/15/Java%E4%B8%AD%E7%9A%84Copy-On-Write%E5%AE%B9%E5%99%A8/"/>
    <id>http://yoursite.com/2017/03/15/Java%E4%B8%AD%E7%9A%84Copy-On-Write%E5%AE%B9%E5%99%A8/</id>
    <published>2017-03-14T17:16:23.000Z</published>
    <updated>2020-06-06T22:26:01.817Z</updated>
    
    <content type="html"><![CDATA[<p>Copy-On-Write简称COW，是一种用于程序设计中的优化策略。其基本思路是，从一开始大家都在共享同一个内容，当某个人想要修改这个内容的时候，才会真正把内容Copy出去形成一个新的内容然后再改，这是一种延时懒惰策略。从JDK1.5开始Java并发包里提供了两个使用CopyOnWrite机制实现的并发容器,它们是CopyOnWriteArrayList和CopyOnWriteArraySet。CopyOnWrite容器非常有用，可以在非常多的并发场景中使用到。</p><a id="more"></a><h2 id="什么是CopyOnWrite容器"><a href="#什么是CopyOnWrite容器" class="headerlink" title="什么是CopyOnWrite容器"></a>什么是CopyOnWrite容器</h2><p>CopyOnWrite容器即写时复制的容器。通俗的理解是当我们往一个容器添加元素的时候，不直接往当前容器添加，而是先将当前容器进行Copy，复制出一个新的容器，然后新的容器里添加元素，添加完元素之后，再将原容器的引用指向新的容器。这样做的好处是我们可以对CopyOnWrite容器进行并发的读，而不需要加锁，因为当前容器不会添加任何元素。所以CopyOnWrite容器也是一种读写分离的思想，读和写不同的容器。</p><h2 id="CopyOnWriteArrayList的实现原理"><a href="#CopyOnWriteArrayList的实现原理" class="headerlink" title="CopyOnWriteArrayList的实现原理"></a>CopyOnWriteArrayList的实现原理</h2><p>在使用CopyOnWriteArrayList之前，我们先阅读其源码了解下它是如何实现的。以下代码是向ArrayList里添加元素，可以发现在添加的时候是需要加锁的，否则多线程写的时候会Copy出N个副本出来。</p><pre><code>public boolean add(T e) {    final ReentrantLock lock = this.lock;    lock.lock();    try {        Object[] elements = getArray();        int len = elements.length;        // 复制出新数组        Object[] newElements = Arrays.copyOf(elements, len + 1);        // 把新元素添加到新数组里        newElements[len] = e;        // 把原数组引用指向新数组        setArray(newElements);        return true;    } finally {        lock.unlock();    }}final void setArray(Object[] a) {    array = a;}</code></pre><p>读的时候不需要加锁，如果读的时候有多个线程正在向ArrayList添加数据，读还是会读到旧的数据，因为写的时候不会锁住旧的ArrayList。</p><pre><code>public E get(int index) {    return get(getArray(), index);}</code></pre><p>JDK中并没有提供CopyOnWriteMap，我们可以参考CopyOnWriteArrayList来实现一个，基本代码如下：</p><pre><code>import java.util.Collection;import java.util.Map;import java.util.Set;public class CopyOnWriteMap&lt;K, V&gt; implements Map&lt;K, V&gt;, Cloneable {    private volatile Map&lt;K, V&gt; internalMap;    public CopyOnWriteMap() {        internalMap = new HashMap&lt;K, V&gt;();    }    public V put(K key, V value) {        synchronized (this) {            Map&lt;K, V&gt; newMap = new HashMap&lt;K, V&gt;(internalMap);            V val = newMap.put(key, value);            internalMap = newMap;            return val;        }    }    public V get(Object key) {        return internalMap.get(key);    }    public void putAll(Map&lt;? extends K, ? extends V&gt; newData) {        synchronized (this) {            Map&lt;K, V&gt; newMap = new HashMap&lt;K, V&gt;(internalMap);            newMap.putAll(newData);            internalMap = newMap;        }    }}</code></pre><p>实现很简单，只要了解了CopyOnWrite机制，我们可以实现各种CopyOnWrite容器，并且在不同的应用场景中使用。</p><h2 id="CopyOnWrite的应用场景"><a href="#CopyOnWrite的应用场景" class="headerlink" title="CopyOnWrite的应用场景"></a>CopyOnWrite的应用场景</h2><p>CopyOnWrite并发容器用于读多写少的并发场景。比如白名单，黑名单，商品类目的访问和更新场景，假如我们有一个搜索网站，用户在这个网站的搜索框中，输入关键字搜索内容，但是某些关键字不允许被搜索。这些不能被搜索的关键字会被放在一个黑名单当中，黑名单每天晚上更新一次。当用户搜索时，会检查当前关键字在不在黑名单当中，如果在，则提示不能搜索。实现代码如下：</p><pre><code>package com.ifeve.book;import java.util.Map;import com.ifeve.book.forkjoin.CopyOnWriteMap;/** * 黑名单服务 * * @author fangtengfei * */public class BlackListServiceImpl {    private static CopyOnWriteMap&lt;String, Boolean&gt; blackListMap = new CopyOnWriteMap&lt;String, Boolean&gt;(            1000);    public static boolean isBlackList(String id) {        return blackListMap.get(id) == null ? false : true;    }    public static void addBlackList(String id) {        blackListMap.put(id, Boolean.TRUE);    }    /**     * 批量添加黑名单     *     * @param ids     */    public static void addBlackList(Map&lt;String,Boolean&gt; ids) {        blackListMap.putAll(ids);    }}</code></pre><p>代码很简单，但是使用CopyOnWriteMap需要注意两件事情：</p><ol><li>减少扩容开销。根据实际需要，初始化CopyOnWriteMap的大小，避免写时CopyOnWriteMap扩容的开销。</li><li>使用批量添加。因为每次添加，容器每次都会进行复制，所以减少添加次数，可以减少容器的复制次数。如使用上面代码里的addBlackList方法。</li></ol><h2 id="CopyOnWrite的缺点"><a href="#CopyOnWrite的缺点" class="headerlink" title="CopyOnWrite的缺点"></a>CopyOnWrite的缺点</h2><p>CopyOnWrite容器有很多优点，但是同时也存在两个问题，即内存占用问题和数据一致性问题。所以在开发的时候需要注意一下。</p><ul><li><strong>内存占用问题</strong>：因为CopyOnWrite的写时复制机制，所以在进行写操作的时候，内存里会同时驻扎两个对象的内存，旧的对象和新写入的对象（注意:在复制的时候只是复制容器里的引用，只是在写的时候会创建新对象添加到新容器里，而旧容器的对象还在使用，所以有两份对象内存）。如果这些对象占用的内存比较大，比如说200M左右，那么再写入100M数据进去，内存就会占用300M，那么这个时候很有可能造成频繁的Yong GC和Full GC。之前我们系统中使用了一个服务由于每晚使用CopyOnWrite机制更新大对象，造成了每晚15秒的Full GC，应用响应时间也随之变长。</li></ul><p>针对内存占用问题，可以通过压缩容器中的元素的方法来减少大对象的内存消耗，比如，如果元素全是10进制的数字，可以考虑把它压缩成36进制或64进制。或者不使用CopyOnWrite容器，而使用其他的并发容器，如ConcurrentHashMap。</p><ul><li><strong>数据一致性问题</strong>：CopyOnWrite容器只能保证数据的最终一致性，不能保证数据的实时一致性。所以如果你希望写入的的数据，马上能读到，请不要使用CopyOnWrite容器。</li></ul><p>关于C++的STL中，曾经也有过Copy-On-Write的玩法，参见陈皓的《C++ STL String类中的Copy-On-Write》，后来，因为有很多线程安全上的事，就被去掉了。</p><blockquote><p>转载自<a href="http://ifeve.com/" target="_blank" rel="noopener">并发编程网 – ifeve.com</a> 本文链接地址: <a href="http://ifeve.com/java-copy-on-write/" target="_blank" rel="noopener">聊聊并发-Java中的Copy-On-Write容器</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Copy-On-Write简称COW，是一种用于程序设计中的优化策略。其基本思路是，从一开始大家都在共享同一个内容，当某个人想要修改这个内容的时候，才会真正把内容Copy出去形成一个新的内容然后再改，这是一种延时懒惰策略。从JDK1.5开始Java并发包里提供了两个使用CopyOnWrite机制实现的并发容器,它们是CopyOnWriteArrayList和CopyOnWriteArraySet。CopyOnWrite容器非常有用，可以在非常多的并发场景中使用到。&lt;/p&gt;
    
    </summary>
    
    
      <category term="JAVA" scheme="http://yoursite.com/categories/JAVA/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="并发" scheme="http://yoursite.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="CopyOnWrite" scheme="http://yoursite.com/tags/CopyOnWrite/"/>
    
  </entry>
  
  <entry>
    <title>ConcurrentLinkedQueue的实现原理分析</title>
    <link href="http://yoursite.com/2017/03/15/ConcurrentLinkedQueue%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2017/03/15/ConcurrentLinkedQueue%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/</id>
    <published>2017-03-14T17:10:55.000Z</published>
    <updated>2020-06-06T22:26:01.817Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>在并发编程中我们有时候需要使用线程安全的队列。如果我们要实现一个线程安全的队列有两种实现方式：一种是使用阻塞算法，另一种是使用非阻塞算法。使用阻塞算法的队列可以用一个锁（入队和出队用同一把锁）或两个锁（入队和出队用不同的锁）等方式来实现，而非阻塞的实现方式则可以使用循环CAS的方式来实现，本文让我们一起来研究下Doug Lea是如何使用非阻塞的方式来实现线程安全队列ConcurrentLinkedQueue的，相信从大师身上我们能学到不少并发编程的技巧。</p><a id="more"></a><h2 id="ConcurrentLinkedQueue的介绍"><a href="#ConcurrentLinkedQueue的介绍" class="headerlink" title="ConcurrentLinkedQueue的介绍"></a>ConcurrentLinkedQueue的介绍</h2><p>ConcurrentLinkedQueue是一个基于链接节点的无界线程安全队列，它采用先进先出的规则对节点进行排序，当我们添加一个元素的时候，它会添加到队列的尾部，当我们获取一个元素时，它会返回队列头部的元素。它采用了“wait－free”算法来实现，该算法在Michael &amp; Scott算法上进行了一些修改, Michael &amp; Scott算法的详细信息可以参见参考资料一。</p><h2 id="ConcurrentLinkedQueue的结构"><a href="#ConcurrentLinkedQueue的结构" class="headerlink" title="ConcurrentLinkedQueue的结构"></a>ConcurrentLinkedQueue的结构</h2><p>我们通过ConcurrentLinkedQueue的类图来分析一下它的结构。 <img data-src="https://cdn.javacodes.cn/files/2017/03/2017-03-14_17-06-25.jpg" alt="">￼ （图1） ConcurrentLinkedQueue由head节点和tair节点组成，每个节点（Node）由节点元素（item）和指向下一个节点的引用(next)组成，节点与节点之间就是通过这个next关联起来，从而组成一张链表结构的队列。默认情况下head节点存储的元素为空，tair节点等于head节点。</p><pre><code>private transient volatile Node&lt;E&gt; tail = head;</code></pre><h2 id="入队列"><a href="#入队列" class="headerlink" title="入队列"></a>入队列</h2><p>入队列就是将入队节点添加到队列的尾部。为了方便理解入队时队列的变化，以及head节点和tair节点的变化，每添加一个节点我就做了一个队列的快照图。 <img data-src="https://cdn.javacodes.cn/files/2017/03/2017-03-14_17-06-26-1.jpg" alt="">￼ （图二）</p><ul><li>第一步添加元素1。队列更新head节点的next节点为元素1节点。又因为tail节点默认情况下等于head节点，所以它们的next节点都指向元素1节点。</li><li>第二步添加元素2。队列首先设置元素1节点的next节点为元素2节点，然后更新tail节点指向元素2节点。</li><li>第三步添加元素3，设置tail节点的next节点为元素3节点。</li><li>第四步添加元素4，设置元素3的next节点为元素4节点，然后将tail节点指向元素4节点。</li></ul><p>通过debug入队过程并观察head节点和tail节点的变化，发现入队主要做两件事情，第一是将入队节点设置成当前队列尾节点的下一个节点。第二是更新tail节点，如果tail节点的next节点不为空，则将入队节点设置成tail节点，如果tail节点的next节点为空，则将入队节点设置成tail的next节点，所以tail节点不总是尾节点，理解这一点对于我们研究源码会非常有帮助。 上面的分析让我们从单线程入队的角度来理解入队过程，但是多个线程同时进行入队情况就变得更加复杂，因为可能会出现其他线程插队的情况。如果有一个线程正在入队，那么它必须先获取尾节点，然后设置尾节点的下一个节点为入队节点，但这时可能有另外一个线程插队了，那么队列的尾节点就会发生变化，这时当前线程要暂停入队操作，然后重新获取尾节点。让我们再通过源码来详细分析下它是如何使用CAS算法来入队的。</p><pre><code>public boolean offer(E e) {    if (e == null) throw new NullPointerException();    //入队前，创建一个入队节点    Node&lt;E&gt; n = new Node&lt;E&gt;(e);    retry:    //死循环，入队不成功反复入队。    for (;;) {        //创建一个指向tail节点的引用        Node&lt;E&gt; t = tail;        //p用来表示队列的尾节点，默认情况下等于tail节点。        Node&lt;E&gt; p = t;        for (int hops = 0; ; hops++) {        //获得p节点的下一个节点。            Node&lt;E&gt; next = succ(p);        //next节点不为空，说明p不是尾节点，需要更新p后在将它指向next节点            if (next != null) {               //循环了两次及其以上，并且当前节点还是不等于尾节点                if (hops &gt; HOPS &amp;&amp; t != tail)                    continue retry;                 p = next;            }             //如果p是尾节点，则设置p节点的next节点为入队节点。            else if (p.casNext(null, n)) {              //如果tail节点有大于等于1个next节点，则将入队节点设置成tair节点，更新失败了也没关系，因为失败了表示有其他线程成功更新了tair节点。                if (hops &gt;= HOPS)                    casTail(t, n); // 更新tail节点，允许失败                return true;              }            // p有next节点,表示p的next节点是尾节点，则重新设置p节点            else {                p = succ(p);            }        }    }}</code></pre><p><strong>从源代码角度来看整个入队过程主要做二件事情</strong>。第一是定位出尾节点，第二是使用CAS算法能将入队节点设置成尾节点的next节点，如不成功则重试。 <strong>第一步定位尾节点</strong>。tail节点并不总是尾节点，所以每次入队都必须先通过tail节点来找到尾节点，尾节点可能就是tail节点，也可能是tail节点的next节点。代码中循环体中的第一个if就是判断tail是否有next节点，有则表示next节点可能是尾节点。获取tail节点的next节点需要注意的是p节点等于p的next节点的情况，只有一种可能就是p节点和p的next节点都等于空，表示这个队列刚初始化，正准备添加第一次节点，所以需要返回head节点。获取p节点的next节点代码如下</p><pre><code>final Node&lt;E&gt; succ(Node&lt;E&gt; p) {         Node&lt;E&gt; next = p.getNext();         return (p == next) ? head : next;     }</code></pre><p><strong>第二步设置入队节点为尾节点</strong>。p.casNext(null, n)方法用于将入队节点设置为当前队列尾节点的next节点，p如果是null表示p是当前队列的尾节点，如果不为null表示有其他线程更新了尾节点，则需要重新获取当前队列的尾节点。 <strong>hops的设计意图</strong>。上面分析过对于先进先出的队列入队所要做的事情就是将入队节点设置成尾节点，doug lea写的代码和逻辑还是稍微有点复杂。那么我用以下方式来实现行不行？</p><pre><code>public boolean offer(E e) {        if (e == null)            throw new NullPointerException();        Node&lt;E&gt; n = new Node&lt;E&gt;(e);        for (;;) {            Node&lt;E&gt; t = tail;            if (t.casNext(null, n) &amp;&amp; casTail(t, n)) {                return true;            }        }    }</code></pre><p>让tail节点永远作为队列的尾节点，这样实现代码量非常少，而且逻辑非常清楚和易懂。但是这么做有个缺点就是每次都需要使用循环CAS更新tail节点。如果能减少CAS更新tail节点的次数，就能提高入队的效率，所以doug lea使用hops变量来控制并减少tail节点的更新频率，并不是每次节点入队后都将 tail节点更新成尾节点，而是当 tail节点和尾节点的距离大于等于常量HOPS的值（默认等于1）时才更新tail节点，tail和尾节点的距离越长使用CAS更新tail节点的次数就会越少，但是距离越长带来的负面效果就是每次入队时定位尾节点的时间就越长，因为循环体需要多循环一次来定位出尾节点，但是这样仍然能提高入队的效率，因为从本质上来看它通过增加对volatile变量的读操作来减少了对volatile变量的写操作，而对volatile变量的写操作开销要远远大于读操作，所以入队效率会有所提升。</p><pre><code>private static final int HOPS = 1;</code></pre><p>还有一点需要注意的是入队方法永远返回true，所以不要通过返回值判断入队是否成功。</p><h2 id="出队列"><a href="#出队列" class="headerlink" title="出队列"></a>出队列</h2><p>出队列的就是从队列里返回一个节点元素，并清空该节点对元素的引用。让我们通过每个节点出队的快照来观察下head节点的变化。 <img data-src="https://cdn.javacodes.cn/files/2017/03/2017-03-14_17-06-26.jpg" alt="">￼ 从上图可知，并不是每次出队时都更新head节点，当head节点里有元素时，直接弹出head节点里的元素，而不会更新head节点。只有当head节点里没有元素时，出队操作才会更新head节点。这种做法也是通过hops变量来减少使用CAS更新head节点的消耗，从而提高出队效率。让我们再通过源码来深入分析下出队过程。</p><pre><code>public E poll() {    Node&lt;E&gt; h = head;   // p表示头节点，需要出队的节点    Node&lt;E&gt; p = h;    for (int hops = 0;; hops++) {        // 获取p节点的元素        E item = p.getItem();        // 如果p节点的元素不为空，使用CAS设置p节点引用的元素为null,如果成功则返回p节点的元素。        if (item != null &amp;&amp; p.casItem(item, null)) {            if (hops &gt;= HOPS) {                //将p节点下一个节点设置成head节点                Node&lt;E&gt; q = p.getNext();                updateHead(h, (q != null) ? q : p);            }            return item;        }        // 如果头节点的元素为空或头节点发生了变化，这说明头节点已经被另外一个线程修改了。那么获取p节点的下一个节点         Node&lt;&gt; next = succ(p);        // 如果p的下一个节点也为空，说明这个队列已经空了        if (next == null) {          // 更新头节点。            updateHead(h, p);            break;        }        // 如果下一个元素不为空，则将头节点的下一个节点设置成头节点        p = next;    }    return null;}</code></pre><p>首先获取头节点的元素，然后判断头节点元素是否为空，如果为空，表示另外一个线程已经进行了一次出队操作将该节点的元素取走，如果不为空，则使用CAS的方式将头节点的引用设置成null，如果CAS成功，则直接返回头节点的元素，如果不成功，表示另外一个线程已经进行了一次出队操作更新了head节点，导致元素发生了变化，需要重新获取头节点。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li>简单，快速和实用的阻塞和非阻塞并发队列算法。</li><li>非阻塞算法在容器里的实现。</li><li>JDK1.6中ConcurrentLinkedQueue源码和注释。</li></ol><blockquote><p>转载自<a href="http://ifeve.com/" target="_blank" rel="noopener">并发编程网 – ifeve.com</a> 本文链接地址: <a href="http://ifeve.com/concurrentlinkedqueue/" target="_blank" rel="noopener">聊聊并发（六）ConcurrentLinkedQueue的实现原理分析</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;&lt;p&gt;在并发编程中我们有时候需要使用线程安全的队列。如果我们要实现一个线程安全的队列有两种实现方式：一种是使用阻塞算法，另一种是使用非阻塞算法。使用阻塞算法的队列可以用一个锁（入队和出队用同一把锁）或两个锁（入队和出队用不同的锁）等方式来实现，而非阻塞的实现方式则可以使用循环CAS的方式来实现，本文让我们一起来研究下Doug Lea是如何使用非阻塞的方式来实现线程安全队列ConcurrentLinkedQueue的，相信从大师身上我们能学到不少并发编程的技巧。&lt;/p&gt;
    
    </summary>
    
    
      <category term="JAVA" scheme="http://yoursite.com/categories/JAVA/"/>
    
    
      <category term="ConcurrentLinkedQueue" scheme="http://yoursite.com/tags/ConcurrentLinkedQueue/"/>
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="并发" scheme="http://yoursite.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>深入剖析 ConcurrentHashMap</title>
    <link href="http://yoursite.com/2017/03/14/%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90%20ConcurrentHashMap/"/>
    <id>http://yoursite.com/2017/03/14/%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90%20ConcurrentHashMap/</id>
    <published>2017-03-14T14:31:36.000Z</published>
    <updated>2020-06-06T22:26:01.821Z</updated>
    
    <content type="html"><![CDATA[<h3 id="术语定义"><a href="#术语定义" class="headerlink" title="术语定义"></a>术语定义</h3><p>术语</p><p>英文</p><p>解释</p><p>哈希算法</p><p>hash algorithm</p><p>是一种将任意内容的输入转换成相同长度输出的加密方式，其输出被称为哈希值。 </p><a id="more"></a><p>哈希表</p><p>hash table</p><p>根据设定的哈希函数H(key)和处理冲突方法将一组关键字映象到一个有限的地址区间上，并以关键字在地址区间中的象作为记录在表中的存储位置，这种表称为哈希表或散列，所得存储位置称为哈希地址或散列地址。</p><h3 id="线程不安全的HashMap"><a href="#线程不安全的HashMap" class="headerlink" title="线程不安全的HashMap"></a>线程不安全的HashMap</h3><p>因为多线程环境下，使用HashMap进行put操作会引起死循环，导致CPU利用率接近100%，所以在并发情况下不能使用HashMap，如以下代码</p><pre><code>final HashMap&lt;String, String&gt; map = new HashMap&lt;String, String&gt;(2);Thread t = new Thread(new Runnable() {    @Override    public void run() {        for (int i = 0; i &lt; 10000; i++) {            new Thread(new Runnable() {                @Override                public void run() {                    map.put(UUID.randomUUID().toString(), &quot;&quot;);                }            }, &quot;ftf&quot; + i).start();        }    }}, &quot;ftf&quot;);t.start();t.join();</code></pre><h3 id="效率低下的HashTable容器"><a href="#效率低下的HashTable容器" class="headerlink" title="效率低下的HashTable容器"></a>效率低下的HashTable容器</h3><p>HashTable容器使用synchronized来保证线程安全，但在线程竞争激烈的情况下HashTable的效率非常低下。因为当一个线程访问HashTable的同步方法时，其他线程访问HashTable的同步方法时，可能会进入阻塞或轮询状态。如线程1使用put进行添加元素，线程2不但不能使用put方法添加元素，并且也不能使用get方法来获取元素，所以竞争越激烈效率越低。</p><h3 id="锁分段技术"><a href="#锁分段技术" class="headerlink" title="锁分段技术"></a>锁分段技术</h3><p>HashTable容器在竞争激烈的并发环境下表现出效率低下的原因是所有访问HashTable的线程都必须竞争同一把锁，那假如容器里有多把锁，每一把锁用于锁容器其中一部分数据，那么当多线程访问容器里不同数据段的数据时，线程间就不会存在锁竞争，从而可以有效的提高并发访问效率，这就是ConcurrentHashMap所使用的锁分段技术，首先将数据分成一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问。</p><h3 id="ConcurrentHashMap的结构"><a href="#ConcurrentHashMap的结构" class="headerlink" title="ConcurrentHashMap的结构"></a>ConcurrentHashMap的结构</h3><p>我们通过ConcurrentHashMap的类图来分析ConcurrentHashMap的结构。 <img data-src="https://cdn.javacodes.cn/files/2017/03/2017-03-14_15-20-05.jpg" alt="">￼ ConcurrentHashMap是由Segment数组结构和HashEntry数组结构组成。Segment是一种可重入锁ReentrantLock，在ConcurrentHashMap里扮演锁的角色，HashEntry则用于存储键值对数据。一个ConcurrentHashMap里包含一个Segment数组，Segment的结构和HashMap类似，是一种数组和链表结构， 一个Segment里包含一个HashEntry数组，每个HashEntry是一个链表结构的元素， 每个Segment守护者一个HashEntry数组里的元素,当对HashEntry数组的数据进行修改时，必须首先获得它对应的Segment锁。 <img data-src="https://cdn.javacodes.cn/files/2017/03/2017-03-14_15-20-04.jpg" alt="">￼</p><h3 id="ConcurrentHashMap的初始化"><a href="#ConcurrentHashMap的初始化" class="headerlink" title="ConcurrentHashMap的初始化"></a>ConcurrentHashMap的初始化</h3><p>ConcurrentHashMap初始化方法是通过initialCapacity，loadFactor, concurrencyLevel几个参数来初始化segments数组，段偏移量segmentShift，段掩码segmentMask和每个segment里的HashEntry数组 。 初始化segments数组。让我们来看一下初始化segmentShift，segmentMask和segments数组的源代码。</p><pre><code>if (concurrencyLevel &gt; MAX_SEGMENTS)    concurrencyLevel = MAX_SEGMENTS;// Find power-of-two sizes best matching argumentsint sshift = 0;int ssize = 1;while (ssize &lt; concurrencyLevel) {    ++sshift;    ssize &lt;&lt;= 1;}segmentShift = 32 - sshift;segmentMask = ssize - 1;this.segments = Segment.newArray(ssize);</code></pre><p>由上面的代码可知segments数组的长度ssize通过concurrencyLevel计算得出。为了能通过按位与的哈希算法来定位segments数组的索引，必须保证segments数组的长度是2的N次方（power-of-two size），所以必须计算出一个是大于或等于concurrencyLevel的最小的2的N次方值来作为segments数组的长度。假如concurrencyLevel等于14，15或16，ssize都会等于16，即容器里锁的个数也是16。注意concurrencyLevel的最大大小是65535，意味着segments数组的长度最大为65536，对应的二进制是16位。 初始化segmentShift和segmentMask。这两个全局变量在定位segment时的哈希算法里需要使用，sshift等于ssize从1向左移位的次数，在默认情况下concurrencyLevel等于16，1需要向左移位移动4次，所以sshift等于4。segmentShift用于定位参与hash运算的位数，segmentShift等于32减sshift，所以等于28，这里之所以用32是因为ConcurrentHashMap里的hash()方法输出的最大数是32位的，后面的测试中我们可以看到这点。segmentMask是哈希运算的掩码，等于ssize减1，即15，掩码的二进制各个位的值都是1。因为ssize的最大长度是65536，所以segmentShift最大值是16，segmentMask最大值是65535，对应的二进制是16位，每个位都是1。 初始化每个Segment。输入参数initialCapacity是ConcurrentHashMap的初始化容量，loadfactor是每个segment的负载因子，在构造方法里需要通过这两个参数来初始化数组中的每个segment。</p><pre><code>if (initialCapacity &gt; MAXIMUM_CAPACITY)    initialCapacity = MAXIMUM_CAPACITY;int c = initialCapacity / ssize;if (c * ssize &lt; initialCapacity)    ++c;int cap = 1;while (cap &lt; c)    cap &lt;&lt;= 1;for (int i = 0; i &lt; this.segments.length; ++i)    this.segments[i] = new Segment&lt;K,V&gt;(cap, loadFactor);</code></pre><p>上面代码中的变量cap就是segment里HashEntry数组的长度，它等于initialCapacity除以ssize的倍数c，如果c大于1，就会取大于等于c的2的N次方值，所以cap不是1，就是2的N次方。segment的容量threshold＝(int)cap*loadFactor，默认情况下initialCapacity等于16，loadfactor等于0.75，通过运算cap等于1，threshold等于零。</p><h3 id="定位Segment"><a href="#定位Segment" class="headerlink" title="定位Segment"></a>定位Segment</h3><p>既然ConcurrentHashMap使用分段锁Segment来保护不同段的数据，那么在插入和获取元素的时候，必须先通过哈希算法定位到Segment。可以看到ConcurrentHashMap会首先使用Wang/Jenkins hash的变种算法对元素的hashCode进行一次再哈希。</p><pre><code>private static int hash(int h) {        h += (h &lt;&lt; 15) ^ 0xffffcd7d;        h ^= (h &gt;&gt;&gt; 10);        h += (h &lt;&lt; 3);        h ^= (h &gt;&gt;&gt; 6);        h += (h &lt;&lt; 2) + (h &lt;&lt; 14);        return h ^ (h &gt;&gt;&gt; 16);    }</code></pre><p>之所以进行再哈希，其目的是为了减少哈希冲突，使元素能够均匀的分布在不同的Segment上，从而提高容器的存取效率。假如哈希的质量差到极点，那么所有的元素都在一个Segment中，不仅存取元素缓慢，分段锁也会失去意义。我做了一个测试，不通过再哈希而直接执行哈希计算。</p><pre><code>System.out.println(Integer.parseInt(&quot;0001111&quot;, 2) &amp; 15);System.out.println(Integer.parseInt(&quot;0011111&quot;, 2) &amp; 15);System.out.println(Integer.parseInt(&quot;0111111&quot;, 2) &amp; 15);System.out.println(Integer.parseInt(&quot;1111111&quot;, 2) &amp; 15);</code></pre><p>计算后输出的哈希值全是15，通过这个例子可以发现如果不进行再哈希，哈希冲突会非常严重，因为只要低位一样，无论高位是什么数，其哈希值总是一样。我们再把上面的二进制数据进行再哈希后结果如下，为了方便阅读，不足32位的高位补了0，每隔四位用竖线分割下。</p><pre><code>0100｜0111｜0110｜0111｜1101｜1010｜0100｜11101111｜0111｜0100｜0011｜0000｜0001｜1011｜10000111｜0111｜0110｜1001｜0100｜0110｜0011｜11101000｜0011｜0000｜0000｜1100｜1000｜0001｜1010</code></pre><p>可以发现每一位的数据都散列开了，通过这种再哈希能让数字的每一位都能参加到哈希运算当中，从而减少哈希冲突。ConcurrentHashMap通过以下哈希算法定位segment。</p><pre><code>final Segment&lt;K,V&gt; segmentFor(int hash) {        return segments[(hash &gt;&gt;&gt; segmentShift) &amp; segmentMask];    }</code></pre><p>默认情况下segmentShift为28，segmentMask为15，再哈希后的数最大是32位二进制数据，向右无符号移动28位，意思是让高4位参与到hash运算中， (hash &gt;&gt;&gt; segmentShift) &amp; segmentMask的运算结果分别是4，15，7和8，可以看到hash值没有发生冲突。</p><h3 id="ConcurrentHashMap的get操作"><a href="#ConcurrentHashMap的get操作" class="headerlink" title="ConcurrentHashMap的get操作"></a>ConcurrentHashMap的get操作</h3><p>Segment的get操作实现非常简单和高效。先经过一次再哈希，然后使用这个哈希值通过哈希运算定位到segment，再通过哈希算法定位到元素，代码如下：</p><pre><code>public V get(Object key) {    int hash = hash(key.hashCode());    return segmentFor(hash).get(key, hash);}</code></pre><p>get操作的高效之处在于整个get过程不需要加锁，除非读到的值是空的才会加锁重读，我们知道HashTable容器的get方法是需要加锁的，那么ConcurrentHashMap的get操作是如何做到不加锁的呢？原因是它的get方法里将要使用的共享变量都定义成volatile，如用于统计当前Segement大小的count字段和用于存储值的HashEntry的value。定义成volatile的变量，能够在线程之间保持可见性，能够被多线程同时读，并且保证不会读到过期的值，但是只能被单线程写（有一种情况可以被多线程写，就是写入的值不依赖于原值），在get操作里只需要读不需要写共享变量count和value，所以可以不用加锁。之所以不会读到过期的值，是根据java内存模型的happen before原则，对volatile字段的写入操作先于读操作，即使两个线程同时修改和获取volatile变量，get操作也能拿到最新的值，这是用volatile替换锁的经典应用场景。</p><pre><code>transient volatile int count;volatile V value;</code></pre><p>在定位元素的代码里我们可以发现定位HashEntry和定位Segment的哈希算法虽然一样，都与数组的长度减去一相与，但是相与的值不一样，定位Segment使用的是元素的hashcode通过再哈希后得到的值的高位，而定位HashEntry直接使用的是再哈希后的值。其目的是避免两次哈希后的值一样，导致元素虽然在Segment里散列开了，但是却没有在HashEntry里散列开。</p><pre><code>hash &gt;&gt;&gt; segmentShift) &amp; segmentMask//定位Segment所使用的hash算法int index = hash &amp; (tab.length - 1);// 定位HashEntry所使用的hash算法</code></pre><h3 id="ConcurrentHashMap的Put操作"><a href="#ConcurrentHashMap的Put操作" class="headerlink" title="ConcurrentHashMap的Put操作"></a>ConcurrentHashMap的Put操作</h3><p>由于put方法里需要对共享变量进行写入操作，所以为了线程安全，在操作共享变量时必须得加锁。Put方法首先定位到Segment，然后在Segment里进行插入操作。插入操作需要经历两个步骤，第一步判断是否需要对Segment里的HashEntry数组进行扩容，第二步定位添加元素的位置然后放在HashEntry数组里。 是否需要扩容。在插入元素前会先判断Segment里的HashEntry数组是否超过容量（threshold），如果超过阀值，数组进行扩容。值得一提的是，Segment的扩容判断比HashMap更恰当，因为HashMap是在插入元素后判断元素是否已经到达容量的，如果到达了就进行扩容，但是很有可能扩容之后没有新元素插入，这时HashMap就进行了一次无效的扩容。 如何扩容。扩容的时候首先会创建一个两倍于原容量的数组，然后将原数组里的元素进行再hash后插入到新的数组里。为了高效ConcurrentHashMap不会对整个容器进行扩容，而只对某个segment进行扩容。</p><h3 id="ConcurrentHashMap的size操作"><a href="#ConcurrentHashMap的size操作" class="headerlink" title="ConcurrentHashMap的size操作"></a>ConcurrentHashMap的size操作</h3><p>如果我们要统计整个ConcurrentHashMap里元素的大小，就必须统计所有Segment里元素的大小后求和。Segment里的全局变量count是一个volatile变量，那么在多线程场景下，我们是不是直接把所有Segment的count相加就可以得到整个ConcurrentHashMap大小了呢？不是的，虽然相加时可以获取每个Segment的count的最新值，但是拿到之后可能累加前使用的count发生了变化，那么统计结果就不准了。所以最安全的做法，是在统计size的时候把所有Segment的put，remove和clean方法全部锁住，但是这种做法显然非常低效。 因为在累加count操作过程中，之前累加过的count发生变化的几率非常小，所以ConcurrentHashMap的做法是先尝试2次通过不锁住Segment的方式来统计各个Segment大小，如果统计的过程中，容器的count发生了变化，则再采用加锁的方式来统计所有Segment的大小。 那么ConcurrentHashMap是如何判断在统计的时候容器是否发生了变化呢？使用modCount变量，在put , remove和clean方法里操作元素前都会将变量modCount进行加1，那么在统计size前后比较modCount是否发生变化，从而得知容器的大小是否发生变化。 参考资料</p><ol><li>JDK1.6源代码。</li><li>《Java并发编程实践》。</li><li>Java并发编程之ConcurrentHashMap 。</li></ol><blockquote><p>转载自<a href="http://ifeve.com/" target="_blank" rel="noopener">并发编程网 – ifeve.com</a> 本文链接地址: <a href="http://ifeve.com/concurrenthashmap/" target="_blank" rel="noopener">聊聊并发（四）深入分析ConcurrentHashMap</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;术语定义&quot;&gt;&lt;a href=&quot;#术语定义&quot; class=&quot;headerlink&quot; title=&quot;术语定义&quot;&gt;&lt;/a&gt;术语定义&lt;/h3&gt;&lt;p&gt;术语&lt;/p&gt;
&lt;p&gt;英文&lt;/p&gt;
&lt;p&gt;解释&lt;/p&gt;
&lt;p&gt;哈希算法&lt;/p&gt;
&lt;p&gt;hash algorithm&lt;/p&gt;
&lt;p&gt;是一种将任意内容的输入转换成相同长度输出的加密方式，其输出被称为哈希值。 &lt;/p&gt;
    
    </summary>
    
    
      <category term="JAVA" scheme="http://yoursite.com/categories/JAVA/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="并发" scheme="http://yoursite.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="ConcurrentHashMap" scheme="http://yoursite.com/tags/ConcurrentHashMap/"/>
    
  </entry>
  
  <entry>
    <title>HashMap实现原理及源码分析</title>
    <link href="http://yoursite.com/2017/03/12/HashMap%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%8F%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2017/03/12/HashMap%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%8F%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</id>
    <published>2017-03-12T10:28:32.000Z</published>
    <updated>2020-06-06T22:26:01.817Z</updated>
    
    <content type="html"><![CDATA[<p>哈希表（hash table）也叫散列表，是一种非常重要的数据结构，应用场景及其丰富，许多缓存技术（比如memcached）的核心其实就是在内存中维护一张大的哈希表，而HashMap的实现原理也常常出现在各类的面试题中，重要性可见一斑。本文会对java集合框架中的对应实现HashMap的实现原理进行讲解，然后会对JDK7的HashMap源码进行分析。</p><a id="more"></a><h1 id="一、什么是哈希表"><a href="#一、什么是哈希表" class="headerlink" title="一、什么是哈希表"></a>一、什么是哈希表</h1><p>在讨论哈希表之前，我们先大概了解下其他数据结构在新增，查找等基础操作执行性能 <strong>数组</strong>：采用一段连续的存储单元来存储数据。对于指定下标的查找，时间复杂度为O(1)；通过给定值进行查找，需要遍历数组，逐一比对给定关键字和数组元素，时间复杂度为O(n)，当然，对于有序数组，则可采用二分查找，插值查找，斐波那契查找等方式，可将查找复杂度提高为O(logn)；对于一般的插入删除操作，涉及到数组元素的移动，其平均复杂度也为O(n) <strong>线性链表</strong>：对于链表的新增，删除等操作（在找到指定操作位置后），仅需处理结点间的引用即可，时间复杂度为O(1)，而查找操作需要遍历链表逐一进行比对，复杂度为O(n) <strong>二叉树</strong>：对一棵相对平衡的有序二叉树，对其进行插入，查找，删除等操作，平均复杂度均为O(logn)。 <strong>哈希表</strong>：相比上述几种数据结构，在哈希表中进行添加，删除，查找等操作，性能十分之高，不考虑哈希冲突的情况下，仅需一次定位即可完成，时间复杂度为O(1)，接下来我们就来看看哈希表是如何实现达到惊艳的常数阶O(1)的。 我们知道，数据结构的物理存储结构只有两种：<strong>顺序存储结构</strong>和<strong>链式存储结构</strong>（像栈，队列，树，图等是从逻辑结构去抽象的，映射到内存中，也这两种物理组织形式），而在上面我们提到过，在数组中根据下标查找某个元素，一次定位就可以达到，哈希表利用了这种特性，<strong>哈希表的主干就是数组</strong>。 比如我们要新增或查找某个元素，我们通过把当前元素的关键字 通过某个函数映射到数组中的某个位置，通过数组下标一次定位就可完成操作。  <strong>存储位置 = f(关键字)</strong> 　其中，这个函数f一般称为<strong>哈希函数</strong>，这个函数的设计好坏会直接影响到哈希表的优劣。举个例子，比如我们要在哈希表中执行插入操作： <img data-src="https://cdn.javacodes.cn/files/2017/03/2017-03-12_10-28-32.png" alt=""> 查找操作同理，先通过哈希函数计算出实际存储地址，然后从数组中对应地址取出即可。 <strong>哈希冲突</strong> 然而万事无完美，如果两个不同的元素，通过哈希函数得出的实际存储地址相同怎么办？也就是说，当我们对某个元素进行哈希运算，得到一个存储地址，然后要进行插入的时候，发现已经被其他元素占用了，其实这就是所谓的<strong>哈希冲突</strong>，也叫哈希碰撞。前面我们提到过，哈希函数的设计至关重要，好的哈希函数会尽可能地保证 <strong>计算简单</strong>和<strong>散列地址分布均匀,</strong>但是，我们需要清楚的是，数组是一块连续的固定长度的内存空间，再好的哈希函数也不能保证得到的存储地址绝对不发生冲突。那么哈希冲突如何解决呢？哈希冲突的解决方案有多种:开放定址法（发生冲突，继续寻找下一块未被占用的存储地址），再散列函数法，链地址法，而HashMap即是采用了链地址法，也就是<strong>数组+链表</strong>的方式，</p><h1 id="二、HashMap实现原理"><a href="#二、HashMap实现原理" class="headerlink" title="二、HashMap实现原理"></a>二、HashMap实现原理</h1><p>HashMap的主干是一个Entry数组。Entry是HashMap的基本组成单元，每一个Entry包含一个key-value键值对。</p><pre><code>//HashMap的主干数组，可以看到就是一个Entry数组，初始值为空数组{}，主干数组的长度一定是2的次幂，至于为什么这么做，后面会有详细分析。transient Entry&lt;K,V&gt;[] table = (Entry&lt;K,V&gt;[]) EMPTY_TABLE;</code></pre><p>Entry是HashMap中的一个静态内部类。代码如下</p><pre><code>static class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; {    final K key;    V value;    Entry&lt;K,V&gt; next;//存储指向下一个Entry的引用，单链表结构    int hash;//对key的hashcode值进行hash运算后得到的值，存储在Entry，避免重复计算    /**     * Creates new entry.     */    Entry(int h, K k, V v, Entry&lt;K,V&gt; n) {        value = v;        next = n;        key = k;        hash = h;    }</code></pre><p>所以，HashMap的整体结构如下 <img data-src="https://cdn.javacodes.cn/files/2017/03/2017-03-12_10-28-34.png" alt=""> <strong>简单来说，HashMap由数组+链表组成的，数组是HashMap的主体，链表则是主要为了解决哈希冲突而存在的，如果定位到的数组位置不含链表（当前entry的next指向null）,那么对于查找，添加等操作很快，仅需一次寻址即可；如果定位到的数组包含链表，对于添加操作，其时间复杂度依然为O(1)，因为最新的Entry会插入链表头部，急需要简单改变引用链即可，而对于查找操作来讲，此时就需要遍历链表，然后通过key对象的equals方法逐一比对查找。所以，性能考虑，HashMap中的链表出现越少，性能才会越好。</strong> 其他几个重要字段</p><pre><code>//实际存储的key-value键值对的个数transient int size;//阈值，当table == {}时，该值为初始容量（初始容量默认为16）；当table被填充了，也就是为table分配内存空间后，threshold一般为 capacity*loadFactory。HashMap在进行扩容时需要参考threshold，后面会详细谈到int threshold;//负载因子，代表了table的填充度有多少，默认是0.75final float loadFactor;//用于快速失败，由于HashMap非线程安全，在对HashMap进行迭代时，如果期间其他线程的参与导致HashMap的结构发生变化了（比如put，remove等操作），需要抛出异常ConcurrentModificationExceptiontransient int modCount;</code></pre><p>HashMap有4个构造器，其他构造器如果用户没有传入initialCapacity 和loadFactor这两个参数，会使用默认值 initialCapacity默认为16，loadFactory默认为0.75 我们看下其中一个</p><pre><code>public HashMap(int initialCapacity, float loadFactor) {　　　　　//此处对传入的初始容量进行校验，最大不能超过MAXIMUM_CAPACITY = 1&lt;&lt;30(2&lt;sup&gt;30&lt;/sup&gt;)        if (initialCapacity &lt; 0)            throw new IllegalArgumentException(&quot;Illegal initial capacity: &quot; +                                               initialCapacity);        if (initialCapacity &gt; MAXIMUM_CAPACITY)            initialCapacity = MAXIMUM_CAPACITY;        if (loadFactor &lt;= 0 || Float.isNaN(loadFactor))            throw new IllegalArgumentException(&quot;Illegal load factor: &quot; +                                               loadFactor);        this.loadFactor = loadFactor;        threshold = initialCapacity;　　　　　        init();//init方法在HashMap中没有实际实现，不过在其子类如 linkedHashMap中就会有对应实现    }</code></pre><p>从上面这段代码我们可以看出，<strong>在常规构造器中，没有为数组table分配内存空间（有一个入参为指定Map的构造器例外），而是在执行put操作的时候才真正构建table数组</strong> OK,接下来我们来看看put操作的实现吧</p><pre><code>public V put(K key, V value) {    //如果table数组为空数组{}，进行数组填充（为table分配实际内存空间），入参为threshold，此时threshold为initialCapacity 默认是1&lt;&lt;4(2&lt;sup&gt;4&lt;/sup&gt;=16)    if (table == EMPTY_TABLE) {        inflateTable(threshold);    }   //如果key为null，存储位置为table[0]或table[0]的冲突链上    if (key == null)        return putForNullKey(value);    int hash = hash(key);//对key的hashcode进一步计算，确保散列均匀    int i = indexFor(hash, table.length);//获取在table中的实际位置    for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) {    //如果该对应数据已存在，执行覆盖操作。用新value替换旧value，并返回旧value        Object k;        if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) {            V oldValue = e.value;            e.value = value;            e.recordAccess(this);            return oldValue;        }    }    modCount++;//保证并发访问时，若HashMap内部结构发生变化，快速响应失败    addEntry(hash, key, value, i);//新增一个entry    return null;}</code></pre><p> 先来看看inflateTable这个方法</p><pre><code>private void inflateTable(int toSize) {        int capacity = roundUpToPowerOf2(toSize);//capacity一定是2的次幂        threshold = (int) Math.min(capacity * loadFactor, MAXIMUM_CAPACITY + 1);//此处为threshold赋值，取capacity*loadFactor和MAXIMUM_CAPACITY+1的最小值，capaticy一定不会超过MAXIMUM_CAPACITY，除非loadFactor大于1        table = new Entry[capacity];        initHashSeedAsNeeded(capacity);    }</code></pre><p>inflateTable这个方法用于为主干数组table在内存中分配存储空间，通过roundUpToPowerOf2(toSize)可以确保capacity为大于或等于toSize的最接近toSize的二次幂，比如toSize=13,则capacity=16;to_size=16,capacity=16;to_size=17,capacity=32.</p><pre><code>private static int roundUpToPowerOf2(int number) {       // assert number &gt;= 0 : &quot;number must be non-negative&quot;;       return number &gt;= MAXIMUM_CAPACITY               ? MAXIMUM_CAPACITY               : (number &gt; 1) ? Integer.highestOneBit((number - 1) &lt;&lt; 1) : 1;   }</code></pre><p>roundUpToPowerOf2中的这段处理使得数组长度一定为2的次幂，Integer.highestOneBit是用来获取最左边的bit（其他bit位为0）所代表的数值. hash函数</p><pre><code>//这是一个神奇的函数，用了很多的异或，移位等运算，对key的hashcode进一步进行计算以及二进制位的调整等来保证最终获取的存储位置尽量分布均匀final int hash(Object k) {        int h = hashSeed;        if (0 != h &amp;&amp; k instanceof String) {            return sun.misc.Hashing.stringHash32((String) k);        }        h ^= k.hashCode();        h ^= (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12);        return h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4);    }</code></pre><p>以上hash函数计算出的值，通过indexFor进一步处理来获取实际的存储位置</p><pre><code>/**   * 返回数组下标   */  static int indexFor(int h, int length) {      return h &amp; (length-1);  }</code></pre><p>h&amp;（length-1）保证获取的index一定在数组范围内，举个例子，默认容量16，length-1=15，h=18,转换成二进制计算为</p><pre><code>    1  0  0  1  0&amp;   0  1  1  1  1__________________    0  0  0  1  0    = 2</code></pre><p>最终计算出的index=2。有些版本的对于此处的计算会使用 取模运算，也能保证index一定在数组范围内，不过位运算对计算机来说，性能更高一些（HashMap中有大量位运算） 所以最终存储位置的确定流程是这样的： <img data-src="https://cdn.javacodes.cn/files/2017/03/2017-03-12_10-28-34-1.png" alt=""> 再来看看addEntry的实现：</p><pre><code>void addEntry(int hash, K key, V value, int bucketIndex) {        if ((size &gt;= threshold) &amp;&amp; (null != table[bucketIndex])) {            resize(2 * table.length);//当size超过临界阈值threshold，并且即将发生哈希冲突时进行扩容            hash = (null != key) ? hash(key) : 0;            bucketIndex = indexFor(hash, table.length);        }        createEntry(hash, key, value, bucketIndex);    }</code></pre><p>通过以上代码能够得知，当发生哈希冲突并且size大于阈值的时候，需要进行数组扩容，扩容时，需要新建一个长度为之前数组2倍的新的数组，然后将当前的Entry数组中的元素全部传输过去，扩容后的新数组长度为之前的2倍，所以扩容相对来说是个耗资源的操作。</p><h1 id="三、为何HashMap的数组长度一定是2的次幂？"><a href="#三、为何HashMap的数组长度一定是2的次幂？" class="headerlink" title="三、为何HashMap的数组长度一定是2的次幂？"></a>三、为何HashMap的数组长度一定是2的次幂？</h1><p>我们来继续看上面提到的resize方法</p><pre><code>void resize(int newCapacity) {       Entry[] oldTable = table;       int oldCapacity = oldTable.length;       if (oldCapacity == MAXIMUM_CAPACITY) {           threshold = Integer.MAX_VALUE;           return;       }       Entry[] newTable = new Entry[newCapacity];       transfer(newTable, initHashSeedAsNeeded(newCapacity));       table = newTable;       threshold = (int)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + 1);   }</code></pre><p>如果数组进行扩容，数组长度发生变化，而存储位置 index = h&amp;(length-1),index也可能会发生变化，需要重新计算index，我们先来看看transfer这个方法</p><pre><code>void transfer(Entry[] newTable, boolean rehash) {        int newCapacity = newTable.length;　　　　　//for循环中的代码，逐个遍历链表，重新计算索引位置，将老数组数据复制到新数组中去（数组不存储实际数据，所以仅仅是拷贝引用而已）        for (Entry&lt;K,V&gt; e : table) {            while(null != e) {                Entry&lt;K,V&gt; next = e.next;                if (rehash) {                    e.hash = null == e.key ? 0 : hash(e.key);                }                int i = indexFor(e.hash, newCapacity);　　　　　　　　　 //将当前entry的next链指向新的索引位置,newTable[i]有可能为空，有可能也是个entry链，如果是entry链，直接在链表头部插入。                e.next = newTable[i];                newTable[i] = e;                e = next;            }        }    }</code></pre><p>这个方法将老数组中的数据逐个链表地遍历，扔到新的扩容后的数组中，我们的数组索引位置的计算是通过 对key值的hashcode进行hash扰乱运算后，再通过和 length-1进行位运算得到最终数组索引位置。 hashMap的数组长度一定保持2的次幂，比如16的二进制表示为 10000，那么length-1就是15，二进制为01111，同理扩容后的数组长度为32，二进制表示为100000，length-1为31，二进制表示为011111。从下图可以我们也能看到这样会保证低位全为1，而扩容后只有一位差异，也就是多出了最左位的1，这样在通过 h&amp;(length-1)的时候，只要h对应的最左边的那一个差异位为0，就能保证得到的新的数组索引和老数组索引一致(大大减少了之前已经散列良好的老数组的数据位置重新调换)，个人理解。 <img data-src="https://cdn.javacodes.cn/files/2017/03/2017-03-12_10-28-35.png" alt=""> 还有，数组长度保持2的次幂，length-1的低位都为1，会使得获得的数组索引index更加均匀，比如： <img data-src="https://cdn.javacodes.cn/files/2017/03/2017-03-12_10-28-35-1.png" alt=""> 我们看到，上面的&amp;运算，高位是不会对结果产生影响的（hash函数采用各种位运算可能也是为了使得低位更加散列），我们只关注低位bit，如果低位全部为1，那么对于h低位部分来说，任何一位的变化都会对结果产生影响，也就是说，要得到index=21这个存储位置，h的低位只有这一种组合。这也是数组长度设计为必须为2的次幂的原因。 <img data-src="https://cdn.javacodes.cn/files/2017/03/2017-03-12_10-28-35-2.png" alt=""> 如果不是2的次幂，也就是低位不是全为1此时，要使得index=21，h的低位部分不再具有唯一性了，哈希冲突的几率会变的更大，同时，index对应的这个bit位无论如何不会等于1了，而对应的那些数组位置也就被白白浪费了。 get方法</p><pre><code>public V get(Object key) {　　　　 //如果key为null,则直接去table[0]处去检索即可。       if (key == null)           return getForNullKey();       Entry&lt;K,V&gt; entry = getEntry(key);       return null == entry ? null : entry.getValue();}</code></pre><p>get方法通过key值返回对应value，如果key为null，直接去table[0]处检索。我们再看一下getEntry这个方法</p><pre><code>final Entry&lt;K,V&gt; getEntry(Object key) {        if (size == 0) {            return null;        }        //通过key的hashcode值计算hash值        int hash = (key == null) ? 0 : hash(key);        //indexFor (hash&amp;length-1) 获取最终数组索引，然后遍历链表，通过equals方法比对找出对应记录        for (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)];             e != null;             e = e.next) {            Object k;            if (e.hash == hash &amp;&amp;                 ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))                return e;        }        return null;    }</code></pre><p>可以看出，get方法的实现相对简单，key(hashcode)–&gt;hash–&gt;indexFor–&gt;最终索引位置，找到对应位置table[i]，再查看是否有链表，遍历链表，通过key的equals方法比对查找对应的记录。要注意的是，有人觉得上面在定位到数组位置之后然后遍历链表的时候，e.hash == hash这个判断没必要，仅通过equals判断就可以。其实不然，试想一下，如果传入的key对象重写了equals方法却没有重写hashCode，而恰巧此对象定位到这个数组位置，如果仅仅用equals判断可能是相等的，但其hashCode和当前对象不一致，这种情况，根据Object的hashCode的约定，不能返回当前对象，而应该返回null，后面的例子会做出进一步解释。</p><h1 id="四、重写equals方法需同时重写hashCode方法"><a href="#四、重写equals方法需同时重写hashCode方法" class="headerlink" title="四、重写equals方法需同时重写hashCode方法"></a>四、重写equals方法需同时重写hashCode方法</h1><p>关于HashMap的源码分析就介绍到这儿了，最后我们再聊聊老生常谈的一个问题，各种资料上都会提到，“重写equals时也要同时覆盖hashcode”，我们举个小例子来看看，如果重写了equals而不重写hashcode会发生什么样的问题</p><pre><code>/** * Created by chengxiao on 2016/11/15. */public class MyTest {    private static class Person{        int idCard;        String name;        public Person(int idCard, String name) {            this.idCard = idCard;            this.name = name;        }        @Override        public boolean equals(Object o) {            if (this == o) {                return true;            }            if (o == null || getClass() != o.getClass()){                return false;            }            Person person = (Person) o;            //两个对象是否等值，通过idCard来确定            return this.idCard == person.idCard;        }    }    public static void main(String []args){        HashMap&lt;Person,String&gt; map = new HashMap&lt;Person, String&gt;();        Person person = new Person(1234,&quot;乔峰&quot;);        //put到hashmap中去        map.put(person,&quot;天龙八部&quot;);        //get取出，从逻辑上讲应该能输出“天龙八部”        System.out.println(&quot;结果:&quot;+map.get(new Person(1234,&quot;萧峰&quot;)));    }}</code></pre><p>实际输出结果：</p><p>结果：null</p><p>如果我们已经对HashMap的原理有了一定了解，这个结果就不难理解了。尽管我们在进行get和put操作的时候，使用的key从逻辑上讲是等值的（通过equals比较是相等的），但由于没有重写hashCode方法，所以put操作时，key(hashcode1)–&gt;hash–&gt;indexFor–&gt;最终索引位置 ，而通过key取出value的时候 key(hashcode1)–&gt;hash–&gt;indexFor–&gt;最终索引位置，由于hashcode1不等于hashcode2，导致没有定位到一个数组位置而返回逻辑上错误的值null（也有可能碰巧定位到一个数组位置，但是也会判断其entry的hash值是否相等，上面get方法中有提到。） 所以，在重写equals的方法的时候，必须注意重写hashCode方法，同时还要保证通过equals判断相等的两个对象，调用hashCode方法要返回同样的整数值。而如果equals判断不相等的两个对象，其hashCode可以相同（只不过会发生哈希冲突，应尽量避免）。</p><h1 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h1><p>本文描述了HashMap的实现原理，并结合源码做了进一步的分析，也涉及到一些源码细节设计缘由，最后简单介绍了为什么重写equals的时候需要重写hashCode方法。希望本篇文章能帮助到大家，同时也欢迎讨论指正，谢谢支持！</p><p>作者： <a href="http://www.cnblogs.com/chengxiao/" target="_blank" rel="noopener">dreamcatcher-cx</a> 出处： <a href="http://www.cnblogs.com/chengxiao/" target="_blank" rel="noopener"><a href="http://www.cnblogs.com/chengxiao/" target="_blank" rel="noopener">http://www.cnblogs.com/chengxiao/</a></a> 本文版权归作者和博客园共有，欢迎转载，但未经作者同意必须保留此段声明，且在页面明显位置给出原文链接。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;哈希表（hash table）也叫散列表，是一种非常重要的数据结构，应用场景及其丰富，许多缓存技术（比如memcached）的核心其实就是在内存中维护一张大的哈希表，而HashMap的实现原理也常常出现在各类的面试题中，重要性可见一斑。本文会对java集合框架中的对应实现HashMap的实现原理进行讲解，然后会对JDK7的HashMap源码进行分析。&lt;/p&gt;
    
    </summary>
    
    
      <category term="JAVA" scheme="http://yoursite.com/categories/JAVA/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="HashMap" scheme="http://yoursite.com/tags/HashMap/"/>
    
  </entry>
  
  <entry>
    <title>Java类加载机制-类加载器（ClassLoader）与双亲委派模型</title>
    <link href="http://yoursite.com/2017/03/12/Java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%EF%BC%88ClassLoader%EF%BC%89%E4%B8%8E%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B/"/>
    <id>http://yoursite.com/2017/03/12/Java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%EF%BC%88ClassLoader%EF%BC%89%E4%B8%8E%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B/</id>
    <published>2017-03-12T08:34:51.000Z</published>
    <updated>2020-06-06T22:26:01.817Z</updated>
    
    <content type="html"><![CDATA[<p>Java虚拟机类加载过程中的“加载”阶段第一步就是“通过一个类的全限定名来获取描述此类的二级制字节流”，这个动作由Java虚拟机外部实现，以便让应用程序自己决定如何去获取所需要的类，实现这个动作的模块叫做“类加载器”。</p><a id="more"></a><h2 id="类与类加载器"><a href="#类与类加载器" class="headerlink" title="类与类加载器"></a>类与类加载器</h2><p>类加载器虽然只用于实现类的加载动作，但它在Java程序中的作用远不限于此。</p><blockquote><p>对于任意一个类，都需要由<strong>加载它的类加载器</strong>和这个<strong>类本身</strong>一同确立其在Java虚拟机中的唯一性，每一个类加载器，都拥有一个独立的类命名空间。</p></blockquote><p>换言之，比较两个类“相等”，只有在两个类是由<strong>同一个类加载器</strong>加载的前提下才有意义，否则，即使这两个类来源于同一个Class文件，被同一个虚拟机加载，只要加载它们的类加载器不同，那这两个类就必定不相等。</p><h2 id="Java中的类加载器"><a href="#Java中的类加载器" class="headerlink" title="Java中的类加载器"></a>Java中的类加载器</h2><p>Java虚拟机只有两种不同的类加载器：</p><ul><li><strong>启动类加载器（Bootstrap ClassLoader）</strong>：使用C++语言（HotSpot）实现，是虚拟机的一部分，该类加载器实例无法被用户获取；</li><li><strong>所有其它的类加载器</strong>：均由Java语言实现，独立于虚拟机外部，并且全部继承自抽象类java.lang.ClassLoader；</li></ul><p>从Java程序员的角度，类加载器还可以继续细化，绝大部分Java程序都会使用到以下3种类加载器。</p><ul><li><strong>启动类加载器 （Bootstrap ClassLoader）</strong>：这个类加载器负责将存放在<code>&lt;JAVA_HOME&gt;\lib</code>目录中的，或者被<code>-Xbootclasspath</code>参数所指定的目录中的，并且是虚拟机识别的（仅按照文件名识别，例如rt.jar）类库加载到虚拟机内存中。 启动类加载器无法被Java程序直接引用，用户在编写自定义加载器时，如果需要把加载请求委托给引导类加载器，直接使用null代替即可。</li><li><strong>扩展类加载器（Extension ClassLoader）</strong>：这个加载器由<code>sun.misc.Launcher$ExtClassLoader</code>实现，他负责加载<code>&lt;JAVA_HOME&gt;\lib\ext</code>目录中的，或者被<code>java.ext.dirs</code>系统变量所指定的路径中的所有类库，开发者可以直接使用扩展类加载器。</li><li><strong>应用程序类加载器（Application ClassLoader）</strong>：这个类加载器由<code>sun.misc.Launcher$AppClassLoader</code>实现。该类是ClassLoader中的<code>getSystemClassLoader()</code>方法的返回值，因此也称作“<strong>系统类加载器</strong>”。它负责用户类路径（ClassPath）上所指定的类库，开发者可以直接使用这个类加载器，如果应用程序中没有定义过自己的类加载器，一般情况下这个就是程序的默认类加载器。</li></ul><p>应用程序一般由这3中类加载器相互配合加载，如果有必要，还可以加入自己定义的类加载器，集成。</p><h3 id="自定义类加载器"><a href="#自定义类加载器" class="headerlink" title="自定义类加载器"></a>自定义类加载器</h3><p>自定义类加载器可以直接或间接继承自类<code>java.lang.ClassLoader</code>。在<code>java.lang.ClassLoader</code>类的常用方法中，一般来说，自己开发的类加载器只需要覆写 <code>findClass(String name)</code>方法即可。 java.lang.ClassLoader类的方法 loadClass()封装了代理模式的实现。</p><ul><li>该方法会首先调用 findLoadedClass()方法来检查该类是否已经被加载过；</li><li>如果没有加载过的话，会调用父类加载器的 loadClass()方法来尝试加载该类；</li><li>如果父类加载器无法加载该类的话，就调用 findClass()方法来查找该类。</li></ul><p>因此，为了保证类加载器都正确实现代理模式，在开发自己的类加载器时，最好不要覆写 loadClass()方法，而是覆写 findClass()方法。 下面是一个文件系统类加载器的例子：</p><p>public class FileSystemClassLoader extends ClassLoader {<br>    private String rootDir;<br>    public FileSystemClassLoader(String rootDir) {<br>        this.rootDir = rootDir;<br>    }<br>    protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException {<br>        byte[] classData = getClassData(name);<br>        if (classData == null) {<br>            throw new ClassNotFoundException();<br>        }<br>        else {<br>            return defineClass(name, classData, 0, classData.length);<br>        }<br>    }<br>    private byte[] getClassData(String className) {<br>        String path = classNameToPath(className);<br>        try {<br>            InputStream ins = new FileInputStream(path);<br>            ByteArrayOutputStream baos = new ByteArrayOutputStream();<br>            int bufferSize = 4096;<br>            byte[] buffer = new byte[bufferSize];<br>            int bytesNumRead = 0;<br>            while ((bytesNumRead = ins.read(buffer)) != -1) {<br>                baos.write(buffer, 0, bytesNumRead);<br>            }<br>            return baos.toByteArray();<br>        } catch (IOException e) {<br>            e.printStackTrace();<br>        }<br>        return null;<br>    }<br>    private String classNameToPath(String className) {<br>        return rootDir + File.separatorChar<br>                + className.replace(‘.’, File.separatorChar) + “.class”;<br>    }<br> }</p><h2 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h2><p>下图展示的类加载器之间的层次关系，称为类加载器的“双亲委派模型”。双亲委派模型要求除了顶层的启动类加载器外，其它类加载器必须有自己的父加载器。</p><p><img data-src="https://cdn.javacodes.cn/files/2017/03/2017-03-12_08-34-52.png" alt=""></p><blockquote><p>这里的类加载器之间的父子关系一般不通过继承（Inheritance）来实现，而是通过组合（Composition）关系来服用父加载器代码。 双亲委派模型并不是一个强制性约束，而是Java设计者推荐给开发者的一种类加载实现方式。</p></blockquote><h3 id="双亲委派模型的工作过程"><a href="#双亲委派模型的工作过程" class="headerlink" title="双亲委派模型的工作过程"></a>双亲委派模型的工作过程</h3><ul><li>如果一个类加载器收到了类加载的请求，它不会先自己尝试处理这个请求，而是委派给它的父类加载器，所有的请求最终都会传送到顶层的启动类加载器</li><li>只有当父类反馈自己无法完成该请求（它的搜索范围中没有找到所需的类，即抛出ClassNotFoundException）时，子加载器才会尝试自己加载。</li></ul><h3 id="为什么使用双亲委派模型？"><a href="#为什么使用双亲委派模型？" class="headerlink" title="为什么使用双亲委派模型？"></a>为什么使用双亲委派模型？</h3><p>使用双亲委派模型可以使得Java类随着它的类加载器一起具备了一种<strong>带有优先级的层次关系</strong>。 例如类<code>java.lang.Object</code>，它存放在rt.jar中，无论哪一个类加载器要加载这个类，最终都是委派给处于模型最顶端的启动类加载器加载，因此Objcet类在程序中的各种类加载器环境中都是同一个类。 如果没有使用双亲委派模型，那么如果用户自己写了一个称为<code>“java.lang.Object”</code>的类，并放在程序的classpath中，那么系统将产生多个不同的Object类，可想而知，程序将一片混乱。</p><h3 id="双亲委派模型的实现"><a href="#双亲委派模型的实现" class="headerlink" title="双亲委派模型的实现"></a>双亲委派模型的实现</h3><p>双亲委派模型的实现非常简单，几乎所有的代码仅在<code>loadClass()</code>方法中实现，下面是一个简单的例子：</p><p>//双亲委派模型的实现源码<br>protected synchronized Class&lt;?&gt; loadClass(String name, Boolean resolve)  throws ClassNotFoundException{<br>    // 1、首先检查请求的类是否已经被加载过<br>    Class c = findLoadedClass(name);<br>    if(c == null){<br>        try{<br>            if(parent != null){    // 2、如果没有则调用父加载器的loadClass()方法<br>                c = parent.loadClass(name, false);  </p><pre><code>        // 3、如果父加载器为空则默认使用启动类加载器作为父加载器          } else{              c = findBootstrapClassOrNull(name);          }      }catch(ClassNotFoundException e){          // 4、如果父类加载器加载失败，则先抛出ClassNotFoundException      }      // 5、然后再调用自己的findClass()方法进行加载      if(c == null){          c = findClass(name);      }  }  if(resolve){      resolveClass(c);  }  return c;  </code></pre><p>}</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Java虚拟机类加载过程中的“加载”阶段第一步就是“通过一个类的全限定名来获取描述此类的二级制字节流”，这个动作由Java虚拟机外部实现，以便让应用程序自己决定如何去获取所需要的类，实现这个动作的模块叫做“类加载器”。&lt;/p&gt;
    
    </summary>
    
    
      <category term="JAVA" scheme="http://yoursite.com/categories/JAVA/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
      <category term="ClassLoader" scheme="http://yoursite.com/tags/ClassLoader/"/>
    
      <category term="类加载" scheme="http://yoursite.com/tags/%E7%B1%BB%E5%8A%A0%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title>Java类加载机制-类加载的时机和过程</title>
    <link href="http://yoursite.com/2017/03/12/Java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E7%9A%84%E6%97%B6%E6%9C%BA%E5%92%8C%E8%BF%87%E7%A8%8B/"/>
    <id>http://yoursite.com/2017/03/12/Java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E7%9A%84%E6%97%B6%E6%9C%BA%E5%92%8C%E8%BF%87%E7%A8%8B/</id>
    <published>2017-03-12T05:33:28.000Z</published>
    <updated>2020-06-06T22:26:01.817Z</updated>
    
    <content type="html"><![CDATA[<h2 id="类加载的时机"><a href="#类加载的时机" class="headerlink" title="类加载的时机"></a>类加载的时机</h2><p>类从被加载到虚拟机开始，到卸载为止，生命周期如图所示： <img data-src="https://cdn.javacodes.cn/files/2017/03/2017-03-12_05-33-29.png" alt=""> 其中，加载、验证、准备、初始化、卸载这五个阶段的顺序是确定的，类的加载过程必须按照这种顺序按部就班的开始（开始不代表完成，通常为交叉混合运行），而解析阶段不一定：它在某些情况下可以在初始化阶段之后再开始。 </p><a id="more"></a><p>Java虚拟机规定有且只有5种情况必须立即对类进行“初始化”：</p><ol><li>遇到<strong>new、getstatic、putstatic或invokestatic</strong>这4条字节码指令（new实例化对象、读取或设置静态字段、调用静态方法）；</li><li>使用java.lang.reflect包的方法进行<strong>反射</strong>调用；</li><li>初始化一个类时，其父类如未初始化，则需要先初始化其<strong>父类</strong>；</li><li>虚拟机启动时，用户指定的要执行的<strong>主类</strong>（包含main方法的那个类）；</li><li>使用JDK1.7的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果<strong>REF_getStatic、REF_putStatic、REF_invokeStatic</strong>的方法句柄，并且句柄所对应的类没有进行初始化；</li></ol><h2 id="类加载的过程"><a href="#类加载的过程" class="headerlink" title="类加载的过程"></a>类加载的过程</h2><h3 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h3><p>“加载”阶段，虚拟机需要完成下面3件事情：</p><ol><li>通过一个类的全限定名来获取定义此类的二进制字节流</li><li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构</li><li>在内存中生成一个代表该类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口</li></ol><blockquote><p>注意：加载阶段尚未完成，连接阶段可能已经开始。</p></blockquote><h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>验证是连接阶段的第一步，目的是确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会威胁虚拟机自身的安全。 验证阶段大致上会完成下面4个阶段的检验动作：文件格式验证、元数据验证、字节码验证、符号引用验证。</p><ol><li>文件格式验证：验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理，通过验证后字节流进入方法区；</li><li>元数据验证：对字节码描述的信息进行语义分析，保证其描述的信息符合Java语言规范的要求；</li><li>字节码验证：最复杂，通过数据流和控制流分析确定程序语义是否合法、符合逻辑；</li><li>符号引用验证：该验证发生在虚拟机将符号引用转化为直接引用时，该动作发生在解析阶段。可以看做是对类自身以外的信息进行匹配性校验；</li></ol><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>正式为类变量（static修饰的变量）分配内存并设置初始值的阶段，这些变量所使用的内存将在方法区中进行分配。 通常情况下是对应类型的“零值”，真正的用户定义的初值要在初始化阶段完成。例如： <code>public static int value = 123;</code> 变量value在准备阶段过后的初始值将是0而不是123，因为这是并未执行任何java方法，而是把value赋值为123的putstatic指令是程序编译后，存放于类构造器<clinit>()方法中，因此该动作在初始化阶段才会执行。</p><blockquote><p>注意：这里是指“通常情况”，如果字段的字段属性表中存在ConstantValue属性，那在准备阶段变量就将被赋予ConstantValue属性所指的值，例如：<code>public static final int value = 123;</code>， 编译的时候javac会为value生成ConstantValue属性，在准备阶段虚拟机会根据ConstantValue的设置将value赋值为123.</p></blockquote><h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。</p><ul><li>符号引用：是一组符号来描述所引用的目标，其字面量形式明确定义在Java虚拟机规范的Class文件格式中；</li><li>直接引用：可以是直接指向目标的指针、相对偏移量或一个能间接定位到目标的句柄。</li></ul><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>类初始化阶段是类加载过程的最后一步，在准备阶段变量已经被附过一次系统要求的初始值（通常为“零值”）,而在初始化阶段，则根据程序员通过程序制定的主观计划去初始化类变量和其它资源。换言之，初始化阶段就是<strong>执行类构造器<clinit>()方法</strong>的过程。</p><ul><li><clinit>()方法是由编译器自动收集类中的所有变量的赋值动作和静态语句块（static{}块）中的语句合并产生的，编译器收集的顺序是语句在源文件中出现的顺序决定的，静态语句块中只能访问到定义在静态语句块之前的变量，定义在它之后的变量在之前可以访问但不能赋值；</li><li><clinit>()方法与类构造函数（或者说实例构造器<init>()方法）不同，它不需要显示调用父类构造器，虚拟机会保证在子类的<clinit>()方法执行之前父类的已经执行完毕，因此虚拟机中第一个被执行的<clinit>()方法一定是java.lang.Object；</li><li>由于父类的<clinit>()方法先执行，意味着父类中定义的静态语句块要优先于子类的变量赋值操作；</li><li><clinit>()方法对于类或者接口不是必须的，如果一个类没有静态语句块和变量的赋值操作，那编译器就可以不为这个类生成<clinit>()方法；</li><li>接口中不能使用静态语句块，但仍然有变量初始化的赋值操作，因此接口也会生成<clinit>()方法。但接口不需要先执行父接口的<clinti>()方法，只有当父接口中定义的变量使用时，父接口才会初始化。接口的实现类初始化时一样不会执行接口的<clinit>()方法；</li><li>虚拟机会保证一个类的<clinit>()方法在多线程环境中被正确的加锁、同步。如果多线程同时执行某一个类的<clinit>()方法，那么只会有一个线程去执行，其它线程将会阻塞等待，直到活动线程执行完毕，需要注意的是，当活动线程执行完毕后，其它线程唤醒之后并不会再次进入<clinit>()方法。同一个类加载器下，一个类型只会被初始化一次。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;类加载的时机&quot;&gt;&lt;a href=&quot;#类加载的时机&quot; class=&quot;headerlink&quot; title=&quot;类加载的时机&quot;&gt;&lt;/a&gt;类加载的时机&lt;/h2&gt;&lt;p&gt;类从被加载到虚拟机开始，到卸载为止，生命周期如图所示： &lt;img data-src=&quot;https://cdn.javacodes.cn/files/2017/03/2017-03-12_05-33-29.png&quot; alt=&quot;&quot;&gt; 其中，加载、验证、准备、初始化、卸载这五个阶段的顺序是确定的，类的加载过程必须按照这种顺序按部就班的开始（开始不代表完成，通常为交叉混合运行），而解析阶段不一定：它在某些情况下可以在初始化阶段之后再开始。 &lt;/p&gt;
    
    </summary>
    
    
      <category term="JAVA" scheme="http://yoursite.com/categories/JAVA/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
      <category term="ClassLoader" scheme="http://yoursite.com/tags/ClassLoader/"/>
    
      <category term="类加载" scheme="http://yoursite.com/tags/%E7%B1%BB%E5%8A%A0%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title>Java垃圾回收机制（GC）</title>
    <link href="http://yoursite.com/2017/03/11/Java%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%EF%BC%88GC%EF%BC%89/"/>
    <id>http://yoursite.com/2017/03/11/Java%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%EF%BC%88GC%EF%BC%89/</id>
    <published>2017-03-11T12:38:18.000Z</published>
    <updated>2020-06-06T22:26:01.817Z</updated>
    
    <content type="html"><![CDATA[<h3 id="判断对象是否可回收的常见方法"><a href="#判断对象是否可回收的常见方法" class="headerlink" title="判断对象是否可回收的常见方法"></a>判断对象是否可回收的常见方法</h3><h4 id="引用计数算法（Reference-Counting）"><a href="#引用计数算法（Reference-Counting）" class="headerlink" title="引用计数算法（Reference Counting）"></a>引用计数算法（Reference Counting）</h4><p>给对象中添加一个引用计数器，每当有一个地方引用时，计数器加1；当引用失效时，计数器减1；任何时刻计数器为0的对象就是不可能再被使用的。</p><ul><li><p>优点：实现简单，判定效率高；</p></li><li><p>缺点：很难解决对象之间的循环引用问题；</p></li></ul><p>JVM并不使用这种算法。</p><a id="more"></a><h4 id="可达性分析算法（Reachability-Analysis）"><a href="#可达性分析算法（Reachability-Analysis）" class="headerlink" title="可达性分析算法（Reachability Analysis）"></a>可达性分析算法（Reachability Analysis）</h4><p>通过一些列称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径叫做引用链，当一个对象到GC Roots没有任何引用链与之相连时，则证明该对象是不可用的。 <img data-src="https://cdn.javacodes.cn/files/2017/03/2017-03-11_12-38-18.png" alt=""></p><p>在Java语言中，可作为GC Roots的对象包括：</p><ul><li><p>虚拟机栈（栈帧中的本地变量表）中引用的对象；</p></li><li><p>方法区中静态属性引用的对象；</p></li><li><p>方法区中常量引用的对象；</p></li><li><p>本地方法栈中JNI（Native方法）引用的对象；</p></li></ul><h4 id="二次标记"><a href="#二次标记" class="headerlink" title="二次标记"></a>二次标记</h4><p>如果一个对象真正宣告“死亡”，至少要经过两次标记过程：</p><ul><li><p>如果一个对象经过可达性分析算法判定为可回收对象，则它将会被第一次标记并进行一次筛选，筛选的条件是判断该对象是否有必要执行finalize()方法。当对象没有覆盖finalize()方法或者已经执行过一次finalize()方法，则虚拟将将判定为“没有必要执行”。如果判定为“有必要执行finalize()方法”，那么这个对象将被置入F-Queue队列，并在稍后由一个虚拟机自动建立的、低优先级的Finalizer线程区执行（仅仅是触发）它。</p></li><li><p>finalize()方法是逃脱死亡的最后机会，稍后GC将堆F-Queue队列进行再一次的小规模标记，如果对象在finalize()方法中重新与引用链上的任何一个对象建立关联，那么在第二次标记的时候将会被移除“即将回收”的集合；如果对象这时候还没有逃脱，那么基本上对象宣告“死亡”并将被回收。</p></li></ul><h3 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h3><h4 id="标记-清除算法（Mark-Sweep）"><a href="#标记-清除算法（Mark-Sweep）" class="headerlink" title="标记-清除算法（Mark-Sweep）"></a>标记-清除算法（Mark-Sweep）</h4><p><img data-src="https://cdn.javacodes.cn/files/2017/03/2017-03-11_12-38-20.png" alt=""></p><p>算法分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收掉所有被标记的对象。 <img data-src="https://cdn.javacodes.cn/files/2017/03/2017-03-11_12-38-21.png" alt=""> 主要缺点：</p><ul><li>效率问题，标记和清除过程的<strong>效率都不高</strong>；</li><li>空间问题，标记清除之后会产生大量<strong>不连续的内存碎片</strong>，空间碎片太多可能会导致，当程序在以后的运行过程中需要分配较大对象时无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作；</li></ul><h4 id="复制算法（Copying）"><a href="#复制算法（Copying）" class="headerlink" title="复制算法（Copying）"></a>复制算法（Copying）</h4><p>它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。</p><p><img data-src="https://cdn.javacodes.cn/files/2017/03/2017-03-11_12-38-21-1.png" alt=""></p><p>这样使得每次都是对其中的一块进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。只是这种算法的代价是将内存缩小为原来的一半，未免太高了一点。</p><p><img data-src="https://cdn.javacodes.cn/files/2017/03/2017-03-11_12-38-22.png" alt=""></p><p>现在的商业虚拟机都采用这种收集算法来<strong>回收新生代</strong>，新生代中的对象98%是朝生夕死的，所以并不需要按照1∶1的比例来划分内存空间，而是将内存分为<strong>一块较大的Eden空间</strong>和<strong>两块较小的Survivor空间</strong>，每次使用Eden和其中的一块Survivor。</p><p>当回收时，将Eden和Survivor中还存活着的对象一次性地拷贝到另外一块Survivor空间上，最后清理掉Eden和刚才用过的Survivor的空间。HotSpot虚拟机默认Eden和Survivor的大小比例是8∶1，也就是每次新生代中可用内存空间为整个新生代容量的90%（80%+10%），只有10%的内存是会被“浪费”的。</p><p>当然，98%的对象可回收只是一般场景下的数据，我们没有办法保证每次回收都只有不多于10%的对象存活，当Survivor空间不够用时，需要依赖其他内存（这里指老年代）进行分配担保（Handle Promotion）。如果另外一块Survivor空间没有足够的空间存放上一次新生代收集下来的存活对象，这些对象将直接通过分配担保机制进入老年代。</p><h4 id="标记整理算法（Mark-Compact）"><a href="#标记整理算法（Mark-Compact）" class="headerlink" title="标记整理算法（Mark-Compact）"></a>标记整理算法（Mark-Compact）</h4><p>复制收集算法在对象存活率较高时就要执行较多的复制操作，效率将会变低。更关键的是，如果不想浪费50%的空间，就需要有额外的空间进行分配担保，以应对被使用的内存中所有对象都100%存活的极端情况，所以在老年代一般不能直接选用这种算法。</p><p><img data-src="https://cdn.javacodes.cn/files/2017/03/2017-03-11_12-38-23.png" alt=""></p><p>根据<strong>老年代</strong>的特点，有人提出了另外一种“<strong>标记-整理</strong>”（Mark-Compact）算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。</p><p><img data-src="https://cdn.javacodes.cn/files/2017/03/2017-03-11_12-38-24.png" alt=""></p><h4 id="分代收集算法（Generational-Collection）"><a href="#分代收集算法（Generational-Collection）" class="headerlink" title="分代收集算法（Generational Collection）"></a>分代收集算法（Generational Collection）</h4><p>当前商业虚拟机的垃圾收集都采用“分代收集”（Generational Collection）算法，这种算法并没有什么新的思想，只是根据对象的存活周期的不同将内存划分为几块。 一般是把Java堆分为<strong>新生代</strong>和<strong>老年代</strong>，这样就可以根据各个年代的特点采用最适当的收集算法。</p><ul><li><p>新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。</p></li><li><p>老年代中，因为对象存活率高、没有额外空间对它进行分配担保，就必须使用“标记-清理”或“标记-整理”算法来进行回收。</p></li></ul><h3 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h3><p>Java虚拟机规范中对垃圾收集器应该如何实现并没有任何规定，因此不同的厂商、不同版本的虚拟机所提供的垃圾收集器都可能会有很大的差别，并且一般都会提供参数供用户根据自己的应用特点和要求组合出各个年代所使用的收集器。</p><ul><li><p><strong>Serial收集器（复制算法)：</strong>新生代单线程收集器，标记和清理都是单线程，优点是简单高效。</p></li><li><p><strong>Serial Old收集器(标记-整理算法)：</strong>老年代单线程收集器，Serial收集器的老年代版本。</p></li><li><p><strong>ParNew收集器(停止-复制算法)：</strong>新生代收集器，可以认为是Serial收集器的多线程版本,在多核CPU环境下有着比Serial更好的表现。</p></li><li><p><strong>Parallel Scavenge收集器(停止-复制算法)：</strong>并行收集器，追求高吞吐量，高效利用CPU。吞吐量一般为99%， 吞吐量= 用户线程时间/(用户线程时间+GC线程时间)。适合后台应用等对交互相应要求不高的场景。</p></li><li><p><strong>Parallel Old收集器(停止-复制算法)：</strong>Parallel Scavenge收集器的老年代版本，并行收集器，吞吐量优先</p></li><li><p><strong>CMS(Concurrent Mark Sweep)收集器（标记-清理算法）**</strong>：**高并发、低停顿，追求最短GC回收停顿时间，cpu占用比较高，响应时间快，停顿时间短，多核cpu 追求高响应时间的选择</p><p><img data-src="https://cdn.javacodes.cn/files/2017/03/2017-03-11_12-38-24-1.png" alt=""></p></li></ul><h4 id="1-Serial-Garbage-Collector"><a href="#1-Serial-Garbage-Collector" class="headerlink" title="1. Serial Garbage Collector"></a>1. Serial Garbage Collector</h4><p>Serial Garbage Collector通过暂停所有应用的线程来工作。它是为单线程工作环境而设计的。它中使用一个线程来进行垃圾回收。这种暂停应用线程来进行垃圾回收的方式可能不太适应服务器环境。它最适合简单的命令行程序。通过 -XX:+UseSerialGC 参数来选用Serial Garbage Collector。</p><h4 id="2-Parallel-Garbage-Collector"><a href="#2-Parallel-Garbage-Collector" class="headerlink" title="2. Parallel Garbage Collector"></a>2. Parallel Garbage Collector</h4><p>Parallel Garbage Collector也被称为吞吐量收集器（throughput collector）。它是Java虚拟机的默认垃圾收集器。与Serial Garbage Collector不同，Parallel Garbage Collector使用多个线程进行垃圾回收。与Serial Garbage Collector相似的地方时，它也是暂停所有的应用线程来进行垃圾回收。</p><h4 id="3-CMS-Garbage-Collector"><a href="#3-CMS-Garbage-Collector" class="headerlink" title="3. CMS Garbage Collector"></a>3. CMS Garbage Collector</h4><p>Concurrent Mark Sweep (CMS) Garbage Collector使用多个线程来扫描堆内存来标记需要回收的实例，然后再清除被标记的实例。CMS Garbage Collector只有在如下两种情景才会暂停所有的应用线程：</p><ul><li>当标记永久代内存空间中的对象时；</li><li>当进行垃圾回收时，堆内存同步发生了一些变化。</li></ul><p>相比Parallel Garbage Collector，CMS Garbage Collector使用更多的CPU资源来确保应用有一个更好的吞吐量。如果分配更多的CPU资源可以获得更好的性能，那么CMS Garbage Collector是一个更好的选择。 通过 XX:+USeParNewGC 参数来选用CMS Garbage Collector。</p><h4 id="4-G1-Garbage-Collector"><a href="#4-G1-Garbage-Collector" class="headerlink" title="4. G1 Garbage Collector"></a>4. G1 Garbage Collector</h4><p>G1 Garbage Collector用于大的堆内存区域。它将堆内存分割成多个独立区域（Region），然后并发地对它们进行垃圾回收。在释放内存后，G1还可以压缩空闲的堆内存。但是，CMS Garbage Collector是通过“Stop The World (STW)”来进行内存压缩的。G1优先收集可回收更多内存的区域。Java 8 的改进：在用G1 Garbage Collector时，可以开启 -XX:+UseStringDeduplication 参数。它通过将重复的字符串移动到同一个 char 数组中来优化堆内存的使用。该选项在Java 8u20时引用进来。 通过 –XX:+UseG1GC 参数来选用G1 Garbage Collector。</p><h3 id="Java虚拟机中的垃圾回收选项配置"><a href="#Java虚拟机中的垃圾回收选项配置" class="headerlink" title="Java虚拟机中的垃圾回收选项配置"></a>Java虚拟机中的垃圾回收选项配置</h3><p>下面是与Java收集器相关的Java虚拟机选项。</p><h4 id="垃圾收集器选择"><a href="#垃圾收集器选择" class="headerlink" title="垃圾收集器选择"></a>垃圾收集器选择</h4><p><strong>Option</strong></p><p><strong>Description</strong></p><p>-XX:+UseSerialGC</p><p>Serial Garbage Collector</p><p>-XX:+UseParallelGC</p><p>Parallel Garbage Collector</p><p>-XX:+UseConcMarkSweepGC</p><p>CMS Garbage Collector</p><p>-XX:ParallelCMSThreads=</p><p>CMS Collector – 使用的线程数</p><p>-XX:+UseG1GC</p><p>G1 Gargbage Collector</p><h4 id="垃圾回收优化选项"><a href="#垃圾回收优化选项" class="headerlink" title="垃圾回收优化选项"></a>垃圾回收优化选项</h4><p><strong>Option</strong></p><p><strong>Description</strong></p><p>-Xms</p><p>堆内存初始化尺寸</p><p>-Xmx</p><p>堆内存最大尺寸</p><p>-Xmn</p><p>新生代（Young Generation）的尺寸</p><p>-XX:PermSize</p><p>永久代（Permanent Generation）初始化尺寸</p><p>-XX:MaxPermSize</p><p>永久代（Permanent Generation）最大尺寸</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;判断对象是否可回收的常见方法&quot;&gt;&lt;a href=&quot;#判断对象是否可回收的常见方法&quot; class=&quot;headerlink&quot; title=&quot;判断对象是否可回收的常见方法&quot;&gt;&lt;/a&gt;判断对象是否可回收的常见方法&lt;/h3&gt;&lt;h4 id=&quot;引用计数算法（Reference-Counting）&quot;&gt;&lt;a href=&quot;#引用计数算法（Reference-Counting）&quot; class=&quot;headerlink&quot; title=&quot;引用计数算法（Reference Counting）&quot;&gt;&lt;/a&gt;引用计数算法（Reference Counting）&lt;/h4&gt;&lt;p&gt;给对象中添加一个引用计数器，每当有一个地方引用时，计数器加1；当引用失效时，计数器减1；任何时刻计数器为0的对象就是不可能再被使用的。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;优点：实现简单，判定效率高；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;缺点：很难解决对象之间的循环引用问题；&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;JVM并不使用这种算法。&lt;/p&gt;
    
    </summary>
    
    
      <category term="JAVA" scheme="http://yoursite.com/categories/JAVA/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
      <category term="GC" scheme="http://yoursite.com/tags/GC/"/>
    
      <category term="垃圾回收" scheme="http://yoursite.com/tags/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"/>
    
  </entry>
  
  <entry>
    <title>常用JVM启动参数</title>
    <link href="http://yoursite.com/2017/03/11/%E5%B8%B8%E7%94%A8JVM%E5%90%AF%E5%8A%A8%E5%8F%82%E6%95%B0/"/>
    <id>http://yoursite.com/2017/03/11/%E5%B8%B8%E7%94%A8JVM%E5%90%AF%E5%8A%A8%E5%8F%82%E6%95%B0/</id>
    <published>2017-03-11T10:20:57.000Z</published>
    <updated>2020-06-06T22:26:01.821Z</updated>
    
    <content type="html"><![CDATA[<h3 id="verbose"><a href="#verbose" class="headerlink" title="-verbose"></a>-verbose</h3><p>java -verbose[:class|gc|jni] 在输出设备上显示虚拟机运行信息。</p><ul><li>-verbose:class：监视输出运行期间的类加载情况</li><li>-verbose:gc：监视输出运行期间的内存回收GC情况</li><li>-verbose:jni：监视输出native方法调用的相关情况，一般用于诊断jni调用错误信息。</li></ul><a id="more"></a><h3 id="堆设置"><a href="#堆设置" class="headerlink" title="堆设置"></a>堆设置</h3><ul><li><strong>-Xms:</strong>初始堆大小</li><li><strong>-Xmx:</strong>最大堆大小</li><li><strong>-XX:NewSize=n:</strong>设置年轻代大小</li><li><strong>-XX:NewRatio=n:</strong>设置年轻代和年老代的比值。如:为3，表示年轻代与年老代比值为1：3，年轻代占整个年轻代年老代和的1/4</li><li><strong>-XX:SurvivorRatio=n:</strong>年轻代中Eden区与两个Survivor区的比值。注意Survivor区有两个。如：3，表示Eden：Survivor=3：2，一个Survivor区占整个年轻代的1/5</li><li><strong>-XX:MaxPermSize=n:</strong>设置持久代大小</li></ul><h3 id="收集器设置"><a href="#收集器设置" class="headerlink" title="收集器设置"></a>收集器设置</h3><ul><li><strong>-XX:+UseSerialGC:</strong>设置串行收集器</li><li><strong>-XX:+UseParallelGC:</strong>设置并行收集器</li><li><strong>-XX:+UseParalledlOldGC:</strong>设置并行年老代收集器</li><li><strong>-XX:+UseConcMarkSweepGC:</strong>设置并发收集器</li></ul><h3 id="垃圾回收统计信息"><a href="#垃圾回收统计信息" class="headerlink" title="垃圾回收统计信息"></a>垃圾回收统计信息</h3><ul><li><strong>-XX:+PrintGC</strong></li><li><strong>-XX:+PrintGCDetails</strong></li><li><strong>-XX:+PrintGCTimeStamps</strong></li><li><strong>-Xloggc:filename</strong></li></ul><h3 id="并行收集器设置"><a href="#并行收集器设置" class="headerlink" title="并行收集器设置"></a>并行收集器设置</h3><ul><li><strong>-XX:ParallelGCThreads=n:</strong>设置并行收集器收集时使用的CPU数。并行收集线程数。</li><li><strong>-XX:MaxGCPauseMillis=n:</strong>设置并行收集最大暂停时间</li><li><strong>-XX:GCTimeRatio=n:</strong>设置垃圾回收时间占程序运行时间的百分比。公式为1/(1+n)</li></ul><h3 id="并发收集器设置"><a href="#并发收集器设置" class="headerlink" title="并发收集器设置"></a>并发收集器设置</h3><ul><li><strong>-XX:+CMSIncrementalMode:</strong>设置为增量模式。适用于单CPU情况。</li><li><strong>-XX:ParallelGCThreads=n:</strong>设置并发收集器年轻代收集方式为并行收集时，使用的CPU数。并行收集线程数。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;verbose&quot;&gt;&lt;a href=&quot;#verbose&quot; class=&quot;headerlink&quot; title=&quot;-verbose&quot;&gt;&lt;/a&gt;-verbose&lt;/h3&gt;&lt;p&gt;java -verbose[:class|gc|jni] 在输出设备上显示虚拟机运行信息。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;-verbose:class：监视输出运行期间的类加载情况&lt;/li&gt;
&lt;li&gt;-verbose:gc：监视输出运行期间的内存回收GC情况&lt;/li&gt;
&lt;li&gt;-verbose:jni：监视输出native方法调用的相关情况，一般用于诊断jni调用错误信息。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="JAVA" scheme="http://yoursite.com/categories/JAVA/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>JVM内存划分</title>
    <link href="http://yoursite.com/2017/03/11/JVM%E5%86%85%E5%AD%98%E5%88%92%E5%88%86/"/>
    <id>http://yoursite.com/2017/03/11/JVM%E5%86%85%E5%AD%98%E5%88%92%E5%88%86/</id>
    <published>2017-03-11T05:11:49.000Z</published>
    <updated>2020-06-06T22:26:01.817Z</updated>
    
    <content type="html"><![CDATA[<p>Java虚拟机内存规范所管理的内存包括如下运行时数据区域：程序计数器、虚拟机栈、本地方法栈、Java堆、方法区等。</p><p><img data-src="https://cdn.javacodes.cn/files/2017/03/2017-03-11_05-11-49.png" alt=""></p><a id="more"></a><h3 id="程序计数器（Program-Counter-Register）"><a href="#程序计数器（Program-Counter-Register）" class="headerlink" title="程序计数器（Program Counter Register）"></a>程序计数器（Program Counter Register）</h3><p>可以看做是当前线程所执行的<strong>字节码行号指示器</strong>，每条线程都有一个独立的程序计数器（线程私有），此内存区是Java虚拟机规范中唯一没有任何OutOfMemoryError情况的区域。</p><h3 id="Java虚拟机栈（Java-Virtual-Machine-Stack）"><a href="#Java虚拟机栈（Java-Virtual-Machine-Stack）" class="headerlink" title="Java虚拟机栈（Java Virtual Machine Stack）"></a>Java虚拟机栈（Java Virtual Machine Stack）</h3><p>线程私有，描述Java方法执行的内存模型：每个方法执行时，都会创建一个栈帧用于存放<strong>局部变量表、操作数栈、动态链接、方法出口</strong>等信息。既每一个方法的执行到完成的过程，对应着栈帧的入栈和出栈的过程。</p><h4 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h4><p>局部变量表存放了编译器可知的各种<strong>基本数据类型、对象引用和returnAdress类型</strong>。</p><ul><li>其中double和long类型的数据会占用2个局部变量空间（slot），其余的类型均占用1个。</li><li>局部变量表的空间在编译器即完成分配，大小完全确定，方法运行期间不会改变局部变量表的大小。</li></ul><h4 id="两种异常情况"><a href="#两种异常情况" class="headerlink" title="两种异常情况"></a>两种异常情况</h4><p>如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverFlowError异常。</p><p>如果虚拟机栈可以动态扩展（大部分Java虚拟机都可以），如果扩展时无法申请到足够的内存，就会抛出OutOfMemoryError异常。</p><h3 id="本地方法栈（Native-Method-Stack）"><a href="#本地方法栈（Native-Method-Stack）" class="headerlink" title="本地方法栈（Native Method Stack）"></a>本地方法栈（Native Method Stack）</h3><p>与虚拟机栈的发挥作用类似，区别如下：</p><ul><li>虚拟机栈为虚拟机执行Java方法（字节码）服务。</li><li>本地方发栈为虚拟机使用到的Native方法服务。</li></ul><p>本地方法栈在不同的虚拟机有不同的实现方式，甚至Sun HotSpot虚拟机将本地方法栈和虚拟机栈合二为一。</p><p>本地方法栈同样会出现虚拟机栈存在的两种异常情况。</p><h3 id="Java堆（Java-Heap）"><a href="#Java堆（Java-Heap）" class="headerlink" title="Java堆（Java Heap）"></a>Java堆（Java Heap）</h3><p>线程共享，在虚拟机启动时创建，唯一目的是存放对象实例。几乎所有的对象实例都在堆上分配。Java堆是GC的主要区域，因此也常称为“GC堆”。</p><ul><li>从垃圾回收的角度看，由于现在的GC基本都采用分代的收集算法，因此还可以将Java堆细分为：<strong>新生代</strong>和<strong>老年代</strong>。再细致划分的话，有：Eden空间、From Survivor空间、To Suvivor空间。</li><li>从内存分配的角度看，线程共享的Java堆还可能划分成多个线程私有的分配缓冲区（TLAB）。</li></ul><p>但无论如何划分，无论哪个区域，Java堆中存储的都是对象实例，进一步划分是为了更好的回收和分配内存。</p><p>Java堆要求逻辑上连续，但物理上可以不连续。主流虚拟机在Java堆的实现上大多采用可以扩展（通过-Xms和-Xmx控制）的实现。</p><p>如果Java堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出OutOfMemoryError异常。</p><h3 id="方法区（Method-Area）"><a href="#方法区（Method-Area）" class="headerlink" title="方法区（Method Area）"></a>方法区（Method Area）</h3><p>线程共享，用于存储已被Java虚拟机<strong>加载的类信息、常量、静态变量、即时编译器编译后的代码</strong>等数据。Java虚拟机规范将其描述为堆的一个逻辑部分，但它却有个别名叫做Non-Heap（非堆），目的将其与Java堆分开。</p><ul><li>对于HotSpot虚拟机来说，通常将方法区成为“永久代”（Permanent Generation），但这种描述并不准确，只是因为HotSpot的设计团队将GC分代算法扩展到了方法区，目的是省去专门为方法区编写内存管理代码的工作。对于其它虚拟机来说是不存在永久代的概念的。通常在方法区发生的GC是比较少的，这区域的主要目标是针对常量池的回收和对类型的卸载。</li><li>HotSpot团队官方发布的路线图信息，现在也有放弃永久代并逐步改为Native Memory来实现方法区的规划。在JDK1.7的HotSpot中，已经把原本放在永久代中的字符串常量池移出。</li></ul><p>当方法区无法满足内存的分配需求时，将会抛出OutOfMemoryError异常。</p><h3 id="运行时常量池（Runtime-Constant-Pool）"><a href="#运行时常量池（Runtime-Constant-Pool）" class="headerlink" title="运行时常量池（Runtime Constant Pool）"></a>运行时常量池（Runtime Constant Pool）</h3><p>运行时常量池是方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等描述信息以外，还有一项信息是常量池，用于存放编译期生成的各种字面量和符号引用，这部分内容在类加载后进入方法区的运行时常量池中存放。</p><ul><li>对于运行时常量池，Java虚拟机规范中没有做任何细节的要求，不同的提供商实现的虚拟机可以按照自己的需要来实现这个内存区域。不过，一般来说，除了存储Class文件中描述的符号引用外，还会把翻译出来的直接引用也存储在运行时常量池中。</li><li>运行时常量池相对于Class文件常量池的另外一个重要特性是具备动态性。Java语言不要求敞亮一定要在编译期产生，也就是说并非一定要预置入Class文件中常量池的内容才能进入运行时常量池，运行期间也可能将新的敞亮放入池中，这种特性被开发人员利用的比较多的便是String类的intern()方法。</li></ul><p>当运行时常量池无法满足内存的分配需求，将会抛出OutOfMemoryError异常。</p><h3 id="直接内存（Direct-Memory）"><a href="#直接内存（Direct-Memory）" class="headerlink" title="直接内存（Direct Memory）"></a>直接内存（Direct Memory）</h3><p>直接内存不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中的内存区域，但却被频繁使用，也有可能导致OutOfMemoryError异常。</p><p>在NIO中，引入了一种基于通道（Channel）与缓冲区（Buffer）的I/O方式，可以利用Native函数库直接分配堆外内存，通过一个存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，避免了在Java堆和Native堆中来回复制数据。</p><p>直接内存不受到Java堆大小的限制，但是仍然受到本机RAM和SWAP区（或分页文件）大小以及处理器寻址空间的限制。服务器管理员在配置虚拟机参数时，常常忽略直接内存而设置-Xmx等信息，终而导致各个内存区的总大小大于物理内存限制，从而导致动态扩展时出现的OutOfMemoryError异常。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Java虚拟机内存规范所管理的内存包括如下运行时数据区域：程序计数器、虚拟机栈、本地方法栈、Java堆、方法区等。&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&quot;https://cdn.javacodes.cn/files/2017/03/2017-03-11_05-11-49.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="JAVA" scheme="http://yoursite.com/categories/JAVA/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>TCP加速锐速SS（ServerSpeeder）破解版一键安装</title>
    <link href="http://yoursite.com/2016/10/30/TCP%E5%8A%A0%E9%80%9F%E9%94%90%E9%80%9FSS%EF%BC%88ServerSpeeder%EF%BC%89%E7%A0%B4%E8%A7%A3%E7%89%88%E4%B8%80%E9%94%AE%E5%AE%89%E8%A3%85/"/>
    <id>http://yoursite.com/2016/10/30/TCP%E5%8A%A0%E9%80%9F%E9%94%90%E9%80%9FSS%EF%BC%88ServerSpeeder%EF%BC%89%E7%A0%B4%E8%A7%A3%E7%89%88%E4%B8%80%E9%94%AE%E5%AE%89%E8%A3%85/</id>
    <published>2016-10-30T07:46:21.000Z</published>
    <updated>2020-06-06T22:26:01.821Z</updated>
    
    <content type="html"><![CDATA[<p>锐速（serverspeeder），是一款TCP加速程序，能够增强VPS/服务器连接的稳定性，且有效的提高服务器的带宽利用率，进而提高访问速度。</p><a id="more"></a><p>老左经常看到论坛、群里有用户提到锐速这款软件可以提高VPS的访问速度、加速应用效率，于是今天就在VULTR VPS中进行尝试安装使用。 大概2月份的时候锐速宣布不再免费，原来宣传的永久免费20M也没了。一时间让广大vps爱好者陷入低谷，不过各路破解高手也是不断抛砖引玉，从开始的改MAC方法到后来的算lic方法，现在连一键安装包都出来了，算是比较成熟了吧。这里转载一个用的比较多的一键安装包，亲测可用，由91yun.org博主带来的。 锐速官方支持的Linux发行版列表：<a href="http://dl.serverspeeder.com/ls.do?m=availables" target="_blank" rel="noopener">http://dl.serverspeeder.com/ls.do?m=availables</a> 脚本已托管在Github：<a href="https://github.com/91yun/serverspeeder" target="_blank" rel="noopener">https://github.com/91yun/serverspeeder</a> 锐速破解版安装方法： <code>wget -N --no-check-certificate https://raw.githubusercontent.com/91yun/serverspeeder/master/serverspeeder-all.sh &amp;&amp; bash serverspeeder-all.sh</code> 锐速破解版卸载方法： <code>chattr -i /serverspeeder/etc/apx* &amp;&amp; /serverspeeder/bin/serverSpeeder.sh uninstall -f</code> 查看锐速启动状态<code>/serverspeeder/bin/serverSpeeder.sh status</code> 锐速破解版功能： 如果内核完全匹配就会自动下载安装。 如果没有完全匹配的内核，会在界面提示可选内核，可以手动选个最接近的尝试 自动下载授权文件 自动修改配置文件 已chattr +i /serverspeeder/etc/apx<em>禁止修改配置文件，可以不用加hosts了 目前只支持CentOS，ubuntu和debian。 PS：*</em>锐速不支持openvz架构**。所以你查看vps的mac地址都是0的就别试了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;锐速（serverspeeder），是一款TCP加速程序，能够增强VPS/服务器连接的稳定性，且有效的提高服务器的带宽利用率，进而提高访问速度。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux/服务器/网络" scheme="http://yoursite.com/categories/Linux-%E6%9C%8D%E5%8A%A1%E5%99%A8-%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
      <category term="ServerSpeeder" scheme="http://yoursite.com/tags/ServerSpeeder/"/>
    
      <category term="SS" scheme="http://yoursite.com/tags/SS/"/>
    
      <category term="锐速" scheme="http://yoursite.com/tags/%E9%94%90%E9%80%9F/"/>
    
  </entry>
  
  <entry>
    <title>Spring学习笔记之Bean的作用域</title>
    <link href="http://yoursite.com/2016/10/20/Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8BBean%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F/"/>
    <id>http://yoursite.com/2016/10/20/Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8BBean%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F/</id>
    <published>2016-10-20T09:31:11.000Z</published>
    <updated>2020-06-06T22:26:01.817Z</updated>
    
    <content type="html"><![CDATA[<p>在默认情况下，Spring的应用上下文中所有的bean都是单例的形式创建的。也就是说，不管给定的一个bean被注入到其它bean多少次，每次注入的都是同一个实例。</p><p>在大多数情况下，单例bean是非常理想的方案。初始化和垃圾回收对象实例所带来的成本只留给一些小规模任务，在这些任务中，让对象保持无状态并且在应用中反复重用这些对象可能并不合理。</p><p>有时候你所使用的类可能是易变的，它们会保持一些状态，比如我们在Web购物商城中常见的购物车功能，不同的用户不可能同时使用同一个购物车实例，因此重用是不安全的。</p><a id="more"></a><h3 id="（一）Spring中的作用域"><a href="#（一）Spring中的作用域" class="headerlink" title="（一）Spring中的作用域"></a>（一）Spring中的作用域</h3><p>Spring提供了多种作用域，可以基于这些作用域来创建bean，包括：</p><ul><li>单例（Singleton）：在整个应用中，只创建bean的一个实例；</li><li>原型（Prototype）：每次注入或者通过Spring上下文获取的时候，都会创建一个新的bean实例；</li><li>会话（Session）：在Web应用中，为每个会话创建一个bean实例；</li><li>请求（Request）：在Web应用中，为每次请求创建一个bean实例；</li></ul><p>如果需要自定义bean的作用域，需要使用@Scope注解，他可以与@Component或@Bean组合使用：</p><p>@Component<br>@Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)<br>public class Cake implements Dessert {<br>}</p><p>这里使用ConfigurableBeanFactory类的SCOPE_PROTOTYPE常亮设置为原型作用域。当然你也可以使用下面这种方式：</p><p>@Component<br>@Scope(“prototype”)<br>public class Cake implements Dessert {<br>}</p><p>但是尽可能使用ConfigurableBeanFactory.SCOPE_PROTOTYPE，这更不容易出错。</p><p>当然也可以在Java配置中将作用域设置为原型bean，例如：</p><pre><code>@Bean@Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)public Dessert cake(){    return new Cake();}</code></pre><p>同样，也可以在XML中配置，应用<bean>元素的scope属性：</p><p><bean id="cake" class="cn.javacodes.spring.beans.Cake" scope="prototype"></bean></p><h3 id="（二）使用会话和请求作用域"><a href="#（二）使用会话和请求作用域" class="headerlink" title="（二）使用会话和请求作用域"></a>（二）使用会话和请求作用域</h3><p>在Web应用中，我们经常需要操作两种作用域：会话和请求。</p><p>就像前面所说，在购物商城的购物车实例上，单例和原型作用域自然不能满足我们的需求，我们希望为每一个会话都创建一个购物车，那么这里会话作用域就是最完美的选择。</p><p>下面来简单模拟一下购物车的作用域场景：</p><pre><code>@Bean@Scope(    value = WebApplicationContext.SCOPE_SESSION,    proxyMode = ScopedProxyMode.INTERFACES)public ShoppingCart cart(){   // ....}</code></pre><p>这里，将value值设置成了WebApplicationContext中的SCOPTE_SESSION常量（值为session）。这会告诉Spring为Web应用中的每个会话创建一个ShoppingCart。对于每一个会话来说，这个bean实际上相当于是单例的。</p><p>这里需要注意，@Scope还有一个proxyMode属性，它被设置为ScopedProxyMode.INTERFACES。我们先不考虑这个属性，先来理解一下对Spring作用域的理解。</p><p>现在假设我们要将ShoppingCart bean注入到单例StoreService bean的Setter中，如下所示：</p><p>@Component<br>public class StoreService {</p><pre><code>private ShoppingCart shoppingCart ;@Autowiredpublic  void setShoppingCart(ShoppingCart shoppingCart){    this.shoppingCart = shoppingCart;}</code></pre><p>}</p><p>因为StoreService是一个单例bean，会在Spring上下文加载的时候创建，当它创建的时候，Spring会试图将ShoppingCart bean注入到setShoppingCart()方法中。但是ShoppingCart bean是会话作用域的，此时并不存在。直到某个用户进入系统，创建了会话以后，才会出现ShoppingCart实例。</p><p>另外，系统中将会存在多个ShoppingCart实例：每个用户一个。我们并不想让Spring注入到某个胡定的ShoppingCart实例到StoreService中。我们希望的是当StoreService处理购物车功能时，它所使用的ShoppingCart实例恰好是当前会话所对应的那一个。</p><p>Spring并不会将实际的ShoppingCart bean注入到StoreService中，Spring会注入一个到ShoppingCart bean的代理。这个代理会暴露与ShoppingCart相同的方法，所以StoreService会认为他就是一个购物车。但是，当StoreService调用ShoppingCart的方法时，代理会对其进行懒解析并将调用委托给作用域内真正的ShoppingCart bean。如下图所示：</p><p><img data-src="https://cdn.javacodes.cn/files/2016/10/2016-10-20_09-27-28.png" alt="QQ截图20161020163515"></p><p>现在我们来讨论一下proxyMode属性。我们将proxyMode属性设置为了ScopedProxyMode.INTERFACES，这表明这个代理要实现ShoppingCart接口，并将调用委托给实现bean。</p><p>这里我们的ShoppingCart是接口而不是具体的类，这当然是可以的（也是最理想的代理模式）。但如果ShoppingCart是具体的实现类而不是接口的话，Spring就没办法创建基于接口的代理了。此时必须使用CGLib来生成基于类的代理。所以，如果bean类型是具体的类的话，我们必须要将proxyMode设置为ScopedProxyMode.TARGET_CLASS，以此来表明要以生成目标类扩展的方式创建代理。</p><p>请求作用域与会话作用域十分类似，也应该以作用域代理的方式进行注入，再次不做赘述。</p><h3 id="（三）在XML中声明作用域代理"><a href="#（三）在XML中声明作用域代理" class="headerlink" title="（三）在XML中声明作用域代理"></a>（三）在XML中声明作用域代理</h3><p>在XML中设置作用域代理需要使用Spring aop命名空间的一个元素：</p><pre><code>&lt;bean id=&quot;cart&quot; class=&quot;cn.javacodes.spring.beans.ShoppingCart&quot; scope=&quot;session&quot;&gt;    &lt;aop:scoped-proxy /&gt;&lt;/bean&gt;</code></pre><p>当然了，在使用aop命名空间之前一定要在xml的顶部进行对命名空间进行声明：</p><?xml version="1.0" encoding="UTF-8"?><p><beans xmlns="http://www.springframework.org/schema/beans"       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"       xmlns:aop="http://www.springframework.org/schema/aop"       xsi:schemaLocation="       http://www.springframework.org/schema/beans       http://www.springframework.org/schema/beans/spring-beans.xsd       http://www.springframework.org/schema/aop       http://www.springframework.org/schema/aop/spring-aop.xsd"><br>    ……<br></beans></p><p>注意：在使用Spring开发web项目时，需要在web.xml中加入如下内容（web2.4以上）：</p><web-app>   ...  <listener><listener-class>org.springframework.web.context.request.RequestContextListener</listener-class>  </listener>   ...</web-app><p>web 2.4以下版本需要加入：</p><web-app> .. <filter>     <filter-name>requestContextFilter</filter-name>     <filter-class>org.springframework.web.filter.RequestContextFilter</filter-class> </filter>  <filter-mapping>     <filter-name>requestContextFilter</filter-name>     <url-pattern>/*</url-pattern> </filter-mapping>   ...</web-app><p>另外，&lt;aop:scoped-proxy /&gt;是与@Scope注解的proxyMode属性功能相同的Spring XML配置元素。它会告诉Spring为bean创建一个作用域代理。默认情况下，它会使用CGLib创建目标类的代理。但是我们也可以将proxy-target-class属性设置为false，进而要求它生成基于接口的代理：</p><bean id="cart" class="cn.javacodes.spring.beans.ShoppingCart" scope="session">        <aop:scoped-proxy proxy-target-class="false"/>    </bean>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在默认情况下，Spring的应用上下文中所有的bean都是单例的形式创建的。也就是说，不管给定的一个bean被注入到其它bean多少次，每次注入的都是同一个实例。&lt;/p&gt;
&lt;p&gt;在大多数情况下，单例bean是非常理想的方案。初始化和垃圾回收对象实例所带来的成本只留给一些小规模任务，在这些任务中，让对象保持无状态并且在应用中反复重用这些对象可能并不合理。&lt;/p&gt;
&lt;p&gt;有时候你所使用的类可能是易变的，它们会保持一些状态，比如我们在Web购物商城中常见的购物车功能，不同的用户不可能同时使用同一个购物车实例，因此重用是不安全的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="JAVA" scheme="http://yoursite.com/categories/JAVA/"/>
    
    
      <category term="request" scheme="http://yoursite.com/tags/request/"/>
    
      <category term="session" scheme="http://yoursite.com/tags/session/"/>
    
      <category term="Spring" scheme="http://yoursite.com/tags/Spring/"/>
    
      <category term="Spring学习笔记" scheme="http://yoursite.com/tags/Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="代理" scheme="http://yoursite.com/tags/%E4%BB%A3%E7%90%86/"/>
    
      <category term="会话" scheme="http://yoursite.com/tags/%E4%BC%9A%E8%AF%9D/"/>
    
      <category term="作用域" scheme="http://yoursite.com/tags/%E4%BD%9C%E7%94%A8%E5%9F%9F/"/>
    
      <category term="请求" scheme="http://yoursite.com/tags/%E8%AF%B7%E6%B1%82/"/>
    
  </entry>
  
  <entry>
    <title>Spring学习笔记之处理自动装配的歧义性</title>
    <link href="http://yoursite.com/2016/10/20/Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%A4%84%E7%90%86%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E7%9A%84%E6%AD%A7%E4%B9%89%E6%80%A7/"/>
    <id>http://yoursite.com/2016/10/20/Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%A4%84%E7%90%86%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E7%9A%84%E6%AD%A7%E4%B9%89%E6%80%A7/</id>
    <published>2016-10-20T09:23:41.000Z</published>
    <updated>2020-06-06T22:26:01.817Z</updated>
    
    <content type="html"><![CDATA[<p>之前的文章中已经看到了Spring的自动装配有很大的用处，它可以帮助我们快速的装配bean，但是这里存在一个问题，在之前的装配中，仅有一个bean匹配所需的结果时，自动装配才是有效的。如果不仅只有一个bean能够匹配结果的话，这就会导致Spring不知道该装配哪个bean从而导致装配失败，例如下面这个例子，我们定义了一个Dessert接口，并且有三个类实现了这个接口，分别为Cake、Cookies和IceCream：</p><p>@Component<br>public class Cookies implements Dessert {<br>}<br>@Component<br>public class Cake implements Dessert {<br>}<br>@Component<br>public class IceCream implements Dessert {<br>}</p><a id="more"></a><p>这三个类均使用了@Component注解，在组件扫描的时候，能够发现他们并将其创建为Spring上下文中的bean。下面是测试代码：</p><p>import cn.javacodes.spring.beans.Dessert;<br>import cn.javacodes.spring.configuration.SpringConfig;<br>import org.junit.runner.RunWith;<br>import org.springframework.beans.factory.annotation.Autowired;<br>import org.springframework.test.context.ContextConfiguration;<br>import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;<br>import static org.junit.Assert.assertNotNull;<br>/**<br> * Created by Eric on 2016/10/20.<br> */<br>@RunWith(SpringJUnit4ClassRunner.class)<br>@ContextConfiguration(classes = SpringConfig.class)<br>public class Test {<br>    private Dessert dessert ;<br>    @Autowired<br>    public void setDessert(Dessert dessert){<br>        this.dessert = dessert;<br>    }<br>    @org.junit.Test<br>    public void test(){<br>        assertNotNull(dessert);<br>    }<br>}</p><p>当Spring试图自动装配setDessert()中的Dessert参数时，它并没有唯一、无歧义的可选值。所以Spring会抛出一个异常：</p><p>org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name ‘Test’: Unsatisfied dependency expressed through method ‘setDessert’ parameter 0: No qualifying bean of type [cn.javacodes.spring.beans.Dessert] is defined: expected single matching bean but found 3: cake,cookies,iceCream; nested exception is org.springframework.beans.factory.NoUniqueBeanDefinitionException: No qualifying bean of type [cn.javacodes.spring.beans.Dessert] is defined: expected single matching bean but found 3: cake,cookies,iceCream</p><p>为了解决这个问题，Spring提供了多种解决方案，标示首选的bean（primary）和使用限定符（qualifier）。</p><h3 id="一、标示首选的bean"><a href="#一、标示首选的bean" class="headerlink" title="一、标示首选的bean"></a>一、标示首选的bean</h3><p>在声明bean的时候，我们可以通过将其中一个可选的bean设置为首选（primary） bean，这样就可以避免歧义性了，使用方式如下，例如我们想将IceCream作为首选bean：</p><p>@Component<br>@Primary<br>public class IceCream implements Dessert {<br>}</p><p>当然了，你也可以在显式声明bean的时候将其设置为首选bean，比如：</p><pre><code>@Bean@Primarypublic Dessert IceCream(){    return new IceCream();}</code></pre><p>当然，如果你喜欢使用XML来配置Bean，那么其方法如下：</p><pre><code>&lt;bean id=&quot;iceCream&quot; class=&quot;cn.javacodes.spring.beans.IceCream&quot;      primary=&quot;true&quot; /&gt;</code></pre><p>使用哪种方式告诉Spring首选bean的效果都是一样的，不过，如果你标示了两个或更多的首选bean，那么它就无法工作了，因为这又会带来歧义性的问题。</p><p>当然我们可以使用另一种更为强大的机制（限定符）来解决这个问题。</p><h3 id="二、使用限定符"><a href="#二、使用限定符" class="headerlink" title="二、使用限定符"></a>二、使用限定符</h3><h4 id="（一）-Qualifier注解"><a href="#（一）-Qualifier注解" class="headerlink" title="（一）@Qualifier注解"></a>（一）@Qualifier注解</h4><p>使用@Primary无法将可选方案的范围限定到唯一一个无歧义的选项，它只能标示一个优先的可选选项。当首选bean的数量超过1个时，我们并没有其它的办法将其限定到唯一的选项上。</p><p>Spring提供的限定符可以解决这个问题，@Qualifier注解是使用限定符的主要方式。它可以与@Autowired或@Inject协同使用。例如，我们想确保IceCream注入到setDessert(）之中：</p><pre><code>@Autowired@Qualifier(&quot;iceCream&quot;)public void setDessert(Dessert dessert){    this.dessert = dessert;}</code></pre><p>这是使用限定符最简单的例子了。为@Qualifier注解所设置的参数就是想要注入的bean的ID。所有使用@Component注解声明的类都会创建为bean，并且bean的ID为首字母变为小写的类名，因此这个例子中使用iceCream作为参数指向组件扫描时所创建的IceCream bean。</p><p>实际上，更准确的讲，@Qualifier(“iceCream”)所引用的bean要具有String类型的“iceCream”作为限定符。如果没有制定其他的限定符，那么所有的bean都会有一个默认的限定符，它的值为bean的ID。因此框架会将具有“iceCream”限定符的bean注入到setDessert()方法中。这恰巧就是ID为iceCream的bean。</p><p>基于默认的限定符看起来是很简单的，不过这里面存在一个问题，如果日后我们进行重构的时候，如果更改了IceCream类的类名比如更改为Gelato的话，那么自动创建的bean的ID就会变为“gelato”，这就无法匹配我们之前所写的限定符了，导致自动装配失败。</p><p>所以在这里setDessert()方法上所指定的限定符与要注入的bean的名称是紧耦合的。对类名称的任意改动都会造成限定符失效。</p><h4 id="（二）创建自定义的限定符"><a href="#（二）创建自定义的限定符" class="headerlink" title="（二）创建自定义的限定符"></a>（二）创建自定义的限定符</h4><p>我们可以为bean设置自己的限定符，而不是依赖与将bean ID作为限定符。例如：</p><p>@Component<br>@Qualifier(“cold”)<br>public class IceCream implements Dessert {<br>}</p><p>这样就解决了之前耦合类名的问题，然后就可以在需要的地方使用这个限定符了，例如：</p><pre><code>@Autowired@Qualifier(&quot;cold&quot;)public void setDessert(Dessert dessert){    this.dessert = dessert;}</code></pre><p>当然，@Qualifier注解也可以与显式装配Bean的@Bean注解组合使用，再次不做赘述。</p><h4 id="（三）使用自定义限定符的注解"><a href="#（三）使用自定义限定符的注解" class="headerlink" title="（三）使用自定义限定符的注解"></a>（三）使用自定义限定符的注解</h4><p>上面的例子中使用了“cold”作为IceCream的限定符，在这里“cold”更像是一种特性来描述这个bean，当然，面向特性的限定符比bean ID更好一些，但是如果多个bean都具有相同的特性怎么办？</p><p>比如我们新加入一个类：</p><p>@Component<br>@Qualifier(“cold”)<br>public class Popsicle implements Dessert {<br>}</p><p>现在我们有了两个带有“cold”的限定符，自动装配的时候我们再次遇到了歧义性的问题，需要更多的限定符来将其可选范围缩小，现在我们可能想到的解决办法可能是类似像下面这种方式，使用多个@Qualifier注解：</p><p>@Component<br>@Qualifier(“cold”)<br>@Qualifier(“creamy”)<br>public class IceCream implements Dessert {<br>}</p><p>但是这种方式是不行的，Java语言不允许在同一个条目上重复出现相同类型的注解（Java 8允许出现重复的注解，但是这个注解本身必须在定义的时候带有@Repeatable，可是Spring的@Qualifier注解并没有在定义时加入@Repeatable），为了解决这个问题，我们可以创建一个自定义的限定符注解，它本身需要使用@Qualifier注解来标注，例如：</p><p>@Target({ElementType.CONSTRUCTOR,ElementType.FIELD,ElementType.METHOD,ElementType.TYPE})<br>@Retention(RetentionPolicy.RUNTIME)<br>@Qualifier<br>public @interface Cold {<br>}</p><p>同样你可以在创建一个Creamy注解来替代@Qualifier(“creamy”)：</p><p>@Target({ElementType.CONSTRUCTOR, ElementType.FIELD,ElementType.METHOD,ElementType.TYPE})<br>@Retention(RetentionPolicy.RUNTIME)<br>@Qualifier<br>public @interface Creamy {<br>}</p><p>同样的原理，你还可以创建类似@Soft、@Crispy等等其它注解。通过在定义注解的时候添加@Qualifier，这些注解就具有了Qualifier的特性，他们本身世界上就是一个限定符。现在我们重新编辑一下IceCream：</p><p>@Component<br>@Cold<br>@Creamy<br>public class IceCream implements Dessert {<br>}</p><p>类似的，Popsicle类可以添加@Cold、@Fruity注解：</p><p>@Component<br>@Fruity<br>@Cold<br>public class Popsicle implements Dessert {<br>}</p><p>最终，在注入点，我们使用必要的限定符注解进行任意组合即可：</p><pre><code>@Autowired@Cold@Creamypublic void setDessert(Dessert dessert){    this.dessert = dessert;}</code></pre><p>这样我们就可以随心所欲的使用自定义限定符注解来缩小匹配范围啦！当然，还是希望Spring可以尽快在新的版本中将@Qualifier注解中加入@Repeatable注解，这样就不用这么麻烦了（我估计要很久，因为Spring还需要保证在相对旧的Java版本上做兼容，Java 8的这一特性估计不会这么快被支持的）！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前的文章中已经看到了Spring的自动装配有很大的用处，它可以帮助我们快速的装配bean，但是这里存在一个问题，在之前的装配中，仅有一个bean匹配所需的结果时，自动装配才是有效的。如果不仅只有一个bean能够匹配结果的话，这就会导致Spring不知道该装配哪个bean从而导致装配失败，例如下面这个例子，我们定义了一个Dessert接口，并且有三个类实现了这个接口，分别为Cake、Cookies和IceCream：&lt;/p&gt;
&lt;p&gt;@Component&lt;br&gt;public class Cookies implements Dessert {&lt;br&gt;}&lt;br&gt;@Component&lt;br&gt;public class Cake implements Dessert {&lt;br&gt;}&lt;br&gt;@Component&lt;br&gt;public class IceCream implements Dessert {&lt;br&gt;}&lt;/p&gt;
    
    </summary>
    
    
      <category term="JAVA" scheme="http://yoursite.com/categories/JAVA/"/>
    
    
      <category term="Spring" scheme="http://yoursite.com/tags/Spring/"/>
    
      <category term="Spring学习笔记" scheme="http://yoursite.com/tags/Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="@Qualifier" scheme="http://yoursite.com/tags/Qualifier/"/>
    
      <category term="Primary" scheme="http://yoursite.com/tags/Primary/"/>
    
      <category term="自动装配歧义性" scheme="http://yoursite.com/tags/%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E6%AD%A7%E4%B9%89%E6%80%A7/"/>
    
      <category term="首选Bean" scheme="http://yoursite.com/tags/%E9%A6%96%E9%80%89Bean/"/>
    
  </entry>
  
  <entry>
    <title>Spring学习笔记之通过XML装配Bean的一些细节</title>
    <link href="http://yoursite.com/2016/10/20/Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E9%80%9A%E8%BF%87XML%E8%A3%85%E9%85%8DBean%E7%9A%84%E4%B8%80%E4%BA%9B%E7%BB%86%E8%8A%82/"/>
    <id>http://yoursite.com/2016/10/20/Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E9%80%9A%E8%BF%87XML%E8%A3%85%E9%85%8DBean%E7%9A%84%E4%B8%80%E4%BA%9B%E7%BB%86%E8%8A%82/</id>
    <published>2016-10-20T09:13:13.000Z</published>
    <updated>2020-06-06T22:26:01.817Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、c命名空间"><a href="#一、c命名空间" class="headerlink" title="一、c命名空间"></a>一、c命名空间</h3><p>通过构造器注入Bean的时候通常需要使用到<constructor-arg>元素，作为替代的方案，可以使用Spring的c-命名空间。c-命名空间是在Spring 3.0中加入的，它是在XML中更为简洁地描述构造器参数的方式。要使用c-命名空间，必须要在XML的顶部声明其模式，如下所示：</p><?xml version="1.0" encoding="UTF-8"?><p><beans xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"       xmlns="http://www.springframework.org/schema/beans"       xmlns:c="http://www.springframework.org/schema/c"       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"><br></beans></p><a id="more"></a><p>在c-命名空间和模式声明后，就可以使用它来声明构造器参数了，如下所示：</p><p><bean id="compactDisc" class="cn.javacodes.spring.beans.soundsystem.Transfer"></bean></p><pre><code>&lt;bean id=&quot;cdPlayer&quot; class=&quot;cn.javacodes.spring.beans.soundsystem.CDPlayer&quot;      c:cd-ref=&quot;compactDisc&quot; /&gt;</code></pre><p>可以看到上面的方式也有一些问题，c:cd-ref中的cd即为构造器参数的名称，这种方式对于后期代码的重构是非常不友好的，那么为了解决这个问题，可以使用参数的索引来替代参数名称，如下所示：</p><pre><code>&lt;bean id=&quot;compactDisc&quot; class=&quot;cn.javacodes.spring.beans.soundsystem.Transfer&quot;&gt;&lt;/bean&gt;&lt;bean id=&quot;cdPlayer&quot; class=&quot;cn.javacodes.spring.beans.soundsystem.CDPlayer&quot;      c:_0-ref=&quot;compactDisc&quot; /&gt;</code></pre><p>当然如果构造器只有一个参数，可以连索引一起略去：</p><pre><code>&lt;bean id=&quot;compactDisc&quot; class=&quot;cn.javacodes.spring.beans.soundsystem.Transfer&quot;&gt;&lt;/bean&gt;&lt;bean id=&quot;cdPlayer&quot; class=&quot;cn.javacodes.spring.beans.soundsystem.CDPlayer&quot;      c:_-ref=&quot;compactDisc&quot; /&gt;</code></pre><p>不过在我的测试中，这种方式在idea中会报错。</p><h3 id="二、装配集合"><a href="#二、装配集合" class="headerlink" title="二、装配集合"></a>二、装配集合</h3><h4 id="（一）装配List和Set"><a href="#（一）装配List和Set" class="headerlink" title="（一）装配List和Set"></a>（一）装配List和Set</h4><p>BlankDisc类的代码如下：</p><p>package cn.javacodes.spring.beans.soundsystem.collections;<br>import cn.javacodes.spring.beans.soundsystem.CompactDisc;<br>import java.util.List;<br>/**<br> * Created by Eric on 2016/10/16.<br> */<br>public class BlankDisc implements CompactDisc {<br>    private String title;<br>    private String artist;<br>    private List<String> tracks;<br>    public BlankDisc(String title, String artist, List<String> tracks) {<br>        this.title = title;<br>        this.artist = artist;<br>        this.tracks = tracks;<br>    }<br>    public void play() {<br>        System.out.println(“正在播放” + artist + “的专辑：” + title);<br>        for (String track : tracks) {<br>            System.out.println(“-Track：” + track);<br>        }<br>    }<br>}</p><p>在Spring中配置这个类的bean时需要提供一个list，当然，你可以给它传递为空值：</p><pre><code>&lt;bean id=&quot;compactDisc&quot; class=&quot;cn.javacodes.spring.beans.soundsystem.collections.BlankDisc&quot;&gt;    &lt;constructor-arg value=&quot;Transfer&quot;&gt;&lt;/constructor-arg&gt;    &lt;constructor-arg value=&quot;周传雄/小刚&quot;&gt;&lt;/constructor-arg&gt;    &lt;constructor-arg&gt;&lt;null/&gt;&lt;/constructor-arg&gt;&lt;/bean&gt;</code></pre><p>不过如果传递null的话，当调用play()方法时，必然会产生NullPointerException异常，通常情况下，我们更多的给它装配一个List。</p><p>我们有很多种解决方案，首先，可以使用<list>元素将其声明为一个列表：</p><pre><code>&lt;bean id=&quot;compactDisc&quot; class=&quot;cn.javacodes.spring.beans.soundsystem.collections.BlankDisc&quot;&gt;    &lt;constructor-arg value=&quot;Transfer&quot;&gt;&lt;/constructor-arg&gt;    &lt;constructor-arg value=&quot;周传雄/小刚&quot;&gt;&lt;/constructor-arg&gt;    &lt;constructor-arg&gt;        &lt;list&gt;            &lt;value&gt;忘记&lt;/value&gt;            &lt;value&gt;出卖&lt;/value&gt;            &lt;value&gt;寂寞轰炸&lt;/value&gt;            &lt;value&gt;游戏爱情&lt;/value&gt;            &lt;value&gt;心结&lt;/value&gt;            &lt;value&gt;记事本&lt;/value&gt;            &lt;value&gt;啤酒泡泡&lt;/value&gt;            &lt;value&gt;黄昏&lt;/value&gt;            &lt;value&gt;末班车&lt;/value&gt;            &lt;value&gt;心血来潮&lt;/value&gt;            &lt;value&gt;时间&lt;/value&gt;        &lt;/list&gt;    &lt;/constructor-arg&gt;&lt;/bean&gt;</code></pre><p>当然，也可以使用<ref>来替代<value>达到引用其它bean的目的，再次不做赘述。</p><p>在我们的例子中构造器参数类型为List，因此使用<list>元素进行注入是合情合理的，尽管如此，我们仍然可以使用<set>元素来进行注入：</p><bean id="compactDisc" class="cn.javacodes.spring.beans.soundsystem.collections.BlankDisc">        <constructor-arg value="Transfer"></constructor-arg>        <constructor-arg value="周传雄/小刚"></constructor-arg>        <constructor-arg>            <set>                <value>忘记</value>                <value>出卖</value>                <value>寂寞轰炸</value>                <value>游戏爱情</value>                <value>心结</value>                <value>记事本</value>                <value>啤酒泡泡</value>                <value>黄昏</value>                <value>末班车</value>                <value>心血来潮</value>                <value>时间</value>            </set>        </constructor-arg>    </bean><p><set>和<list>元素的区别并不大，其中最重要的区别在于Spring创建要装配的集合时，所创建的是Set还是List。如果是Set的话，所有重复的值都会被忽略掉，并且存放的顺序也不会得到保证，这个相信大家对Set和List的区别都有明确的认识。不过无论哪种情况下，<set>和<list>都可以用来装配List、Set甚至数组。</p><h4 id="（二）、装配Map"><a href="#（二）、装配Map" class="headerlink" title="（二）、装配Map"></a>（二）、装配Map</h4><p>我们将上面的BlankDisc稍作改动，将原有的List改为Map：</p><pre><code>private String title;private String artist;private Map&lt;String,String&gt; tracks;public BlankDisc(String title, String artist, Map&lt;String, String&gt; tracks) {    this.title = title;    this.artist = artist;    this.tracks = tracks;}</code></pre><p>装配Map的方式如下：</p><pre><code>&lt;bean id=&quot;compactDisc&quot; class=&quot;cn.javacodes.spring.beans.soundsystem.collections.BlankDisc&quot;&gt;    &lt;constructor-arg value=&quot;Transfer&quot;&gt;&lt;/constructor-arg&gt;    &lt;constructor-arg value=&quot;周传雄/小刚&quot;&gt;&lt;/constructor-arg&gt;    &lt;constructor-arg&gt;        &lt;map&gt;            &lt;entry key=&quot;忘记&quot; value=&quot;5:12&quot;/&gt;            &lt;entry key=&quot;出卖&quot; value=&quot;4:54&quot;/&gt;            &lt;entry ……         &lt;/map&gt;    &lt;/constructor-arg&gt;&lt;/bean&gt;</code></pre><p>当然<key>和<value>元素可以分别用<key-ref>和<value-ref>元素替代用于引用其它Bean。</p><h4 id="（三）、装配Properties"><a href="#（三）、装配Properties" class="headerlink" title="（三）、装配Properties"></a>（三）、装配Properties</h4><p>Properties与Map非常类似，不过区别主要在于Map的key和Value可以是任意类型的对象，而Properties要求key和value必须都是String类型，而很多场景下我们的key和value的确都是String类型，比如数据库连接信息的配置。</p><p>为了演示Properties的相关配置，我们创建一个类DataSource：</p><p>package cn.javacodes.spring.beans.properties;<br>import java.util.Properties;<br>/**<br> * Created by Eric on 2016/10/16.<br> */<br>public class DataSource {</p><pre><code>private Properties properties;public DataSource(Properties properties) {    this.properties = properties;}public Properties getProperties() {    return properties;}public void setProperties(Properties properties) {    this.properties = properties;}</code></pre><p>}</p><p>在Spring XML配置如下：</p><pre><code>&lt;bean id=&quot;dataSource&quot; class=&quot;cn.javacodes.spring.beans.properties.DataSource&quot;&gt;    &lt;constructor-arg&gt;        &lt;props&gt;            &lt;prop key=&quot;user&quot;&gt;root&lt;/prop&gt;            &lt;prop key=&quot;password&quot;&gt;123456&lt;/prop&gt;            &lt;prop key=&quot;url&quot;&gt;jdbc:mysql:///test&lt;/prop&gt;            &lt;prop key=&quot;driver&quot;&gt;com.mysql.jdbc.Driver&lt;/prop&gt;        &lt;/props&gt;    &lt;/constructor-arg&gt;&lt;/bean&gt;</code></pre><h3 id="三、p命名空间"><a href="#三、p命名空间" class="headerlink" title="三、p命名空间"></a>三、p命名空间</h3><p>我们知道配置bean的属性时需要使用<property>元素，为了简化这种方式，与c命名空间一样，Spring为我们提供了p命名空间。为了使用p-命名空间，必须在xml顶部进行声明：</p><?xml version="1.0" encoding="UTF-8"?><p><beans xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"       xmlns="http://www.springframework.org/schema/beans"       xmlns:p="http://www.springframework.org/schema/p"       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"><br>……<br></beans></p><p>然后就可以使用p-命名空间了，使用方法如下：</p><pre><code>&lt;bean id=&quot;cdPlayer&quot; class=&quot;cn.javacodes.spring.beans.soundsystem.CDPlayer&quot;    p:cd-ref=&quot;compactDisc&quot;/&gt;</code></pre><p>属性的名称以-ref结尾的，代表Spring要进行装配的是bean的引用而不是字面值（String）。</p><h3 id="四、util命名空间"><a href="#四、util命名空间" class="headerlink" title="四、util命名空间"></a>四、util命名空间</h3><p>p-命名空间和c-命名空间都不能对集合类型进行装配，不过我们可以使用util命名空间来简化对集合的装配，声明如下：</p><?xml version="1.0" encoding="UTF-8"?><p><beans xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"       xmlns="http://www.springframework.org/schema/beans"       xmlns:p="http://www.springframework.org/schema/p"       xmlns:c="http://www.springframework.org/schema/c"       xmlns:util="http://www.springframework.org/schema/util"       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"><br></beans></p><p>现在就可以使用util命名空间了，例如：</p><pre><code>&lt;util:list id=&quot;trackList&quot;&gt;    &lt;value&gt;忘记&lt;/value&gt;    &lt;value&gt;出卖&lt;/value&gt;    &lt;value&gt;寂寞轰炸&lt;/value&gt;    &lt;value&gt;游戏爱情&lt;/value&gt;    &lt;value&gt;心结&lt;/value&gt;    &lt;value&gt;记事本&lt;/value&gt;    &lt;value&gt;啤酒泡泡&lt;/value&gt;    &lt;value&gt;黄昏&lt;/value&gt;    &lt;value&gt;末班车&lt;/value&gt;    &lt;value&gt;心血来潮&lt;/value&gt;    &lt;value&gt;时间&lt;/value&gt;&lt;/util:list&gt;</code></pre><p>然后就可以像引用其它Bean一样将list轻松引用，如下所示：</p><pre><code>&lt;bean id=&quot;compactDisc&quot; class=&quot;cn.javacodes.spring.beans.soundsystem.collections.BlankDisc&quot; c:title=&quot;Transfer&quot; c:artist=&quot;周传雄/小刚&quot; c:tracks-ref=&quot;trackList&quot;/&gt;</code></pre><p><a href="util:list">util:list</a>只是util-命名空间提供的众多元素之一，下表列出了util-命名空间提供的所有元素：</p><p>元素</p><p>描述</p><p><a href="util:constant">util:constant</a></p><p>引用某个类型的public static域，并墙漆暴露为bean</p><p><a href="util:list">util:list</a></p><p>创建一个java.util.List类型的bean，其中包含值或引用</p><p><a href="util:map">util:map</a></p><p>创建一个java.util.Map类型的bean，其中包含值或引用</p><p><a href="util:properties">util:properties</a></p><p>创建一个java.util.Properties类型的bean</p><p><a href="util:property-path">util:property-path</a></p><p>引用一个bean的属性（或内嵌属性），并将其暴露为bean</p><p><a href="util:set">util:set</a></p><p>创建一个java.util.set类型的bean，其中包含值或引用</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一、c命名空间&quot;&gt;&lt;a href=&quot;#一、c命名空间&quot; class=&quot;headerlink&quot; title=&quot;一、c命名空间&quot;&gt;&lt;/a&gt;一、c命名空间&lt;/h3&gt;&lt;p&gt;通过构造器注入Bean的时候通常需要使用到&lt;constructor-arg&gt;元素，作为替代的方案，可以使用Spring的c-命名空间。c-命名空间是在Spring 3.0中加入的，它是在XML中更为简洁地描述构造器参数的方式。要使用c-命名空间，必须要在XML的顶部声明其模式，如下所示：&lt;/p&gt;
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;p&gt;&lt;beans xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:c=&quot;http://www.springframework.org/schema/c&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;&lt;br&gt;&lt;/beans&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="JAVA" scheme="http://yoursite.com/categories/JAVA/"/>
    
    
      <category term="Spring" scheme="http://yoursite.com/tags/Spring/"/>
    
      <category term="Spring学习笔记" scheme="http://yoursite.com/tags/Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="c命名空间" scheme="http://yoursite.com/tags/c%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4/"/>
    
      <category term="p命名空间" scheme="http://yoursite.com/tags/p%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4/"/>
    
      <category term="util命名空间" scheme="http://yoursite.com/tags/util%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4/"/>
    
      <category term="装配集合" scheme="http://yoursite.com/tags/%E8%A3%85%E9%85%8D%E9%9B%86%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>Spring学习笔记之通过Java代码装配Bean</title>
    <link href="http://yoursite.com/2016/10/20/Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E9%80%9A%E8%BF%87Java%E4%BB%A3%E7%A0%81%E8%A3%85%E9%85%8DBean/"/>
    <id>http://yoursite.com/2016/10/20/Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E9%80%9A%E8%BF%87Java%E4%BB%A3%E7%A0%81%E8%A3%85%E9%85%8DBean/</id>
    <published>2016-10-20T09:03:27.000Z</published>
    <updated>2020-06-06T22:26:01.817Z</updated>
    
    <content type="html"><![CDATA[<p>虽然很多场景下可以使用组件扫描和自动装配来实现Spring的自动化配置，但有些时候自动化配置的方案是行不通的，因此需要明确配置Spring。比如你想讲第三方库中的组件装配到你的应用中，在这种情况下，你必须要显式装配。在进行显式配置的时候，有两种方案，Java和XML。</p><p>下面介绍通过Java代码显式装配Bean。</p><a id="more"></a><h3 id="一、创建配置类"><a href="#一、创建配置类" class="headerlink" title="一、创建配置类"></a>一、创建配置类</h3><p>创建配置类的关键在于@Configuration注解，@Configuration注解表明该类是一个配置类，该类包含了在Spring上下文中如何创建Bean的细节。</p><p>package cn.javacodes.spring.configuration;<br>import org.springframework.context.annotation.Configuration;<br>/**<br> * Created by Eric on 2016/10/16.<br> */<br>@Configuration<br>public class CDPlayerConfig {<br>}</p><h3 id="二、声明简单的Bean"><a href="#二、声明简单的Bean" class="headerlink" title="二、声明简单的Bean"></a>二、声明简单的Bean</h3><p>要在JavaConfig中声明Bean，我们需要写一个方法，这个方法会创建所需类型的实例，然后给这个方法添加@Bean注解。比如下面的代码声明了CompactDisc Bean：</p><pre><code>@Beanpublic CompactDisc transfer(){    return new Transfer();}</code></pre><p>@Bean注解会告诉Spring这个方法会返回一个对象，该对象要注册为Spring应用上下文中的bean。方法体中包含了最终产生bean对象的逻辑。</p><p>默认情况下，bean的ID于带有@Bean注解方法的名称是一样的。在上面的例子中，bean的名字将会是“transfer”。如果你想为它设置一个不同的名字，可以通过name属性指定它的ID：</p><pre><code>@Bean(name = &quot;transfer-cd&quot;)public CompactDisc transfer(){    return new Transfer();}</code></pre><p>另外，方法中的方法体可以是任何你想创建Bean的逻辑，比如你想在一组CD中随机选取一个CD进行播放也是可以的。</p><h3 id="三、借助JavaConfig实现注入"><a href="#三、借助JavaConfig实现注入" class="headerlink" title="三、借助JavaConfig实现注入"></a>三、借助JavaConfig实现注入</h3><p>前面声明的CompactDisc Bean是非常简单的，因为它没有任何依赖，那么现在想要声明一个CDPlayer Bean，它依赖于CompactDisc。</p><h4 id="（一）引用创建Bean的方法"><a href="#（一）引用创建Bean的方法" class="headerlink" title="（一）引用创建Bean的方法"></a>（一）引用创建Bean的方法</h4><pre><code>@Beanpublic CDPlayer cdPlayer(){    return new CDPlayer(transfer());}</code></pre><p>这里同样使用了@Bean注解，并在构造CDPlayer时将CompactDisc作为CDPlayer构造器的参数传入。</p><p>注意：这里虽然看起来是通过调用transfer()方法得到CompactDisc，但由于transfer方法使用了@Bean注解，实际上Spring会拦截所有对它的调用，并确保直接返回该方法所创建的Spring上下文中的bean，而不是每次都对其进行实际的调用。</p><p>比如说，假设你引入了另一个其他的CDPlayer Bean，它和之前的那个bean完全一样。</p><pre><code>@Beanpublic CDPlayer cdPlayer(){    return new CDPlayer(transfer());}@Beanpublic CDPlayer anotherCDPlayer(){    return new CDPlayer(transfer());}</code></pre><p>默认情况下，Spring中的bean都是单例的，我们并没有必要为第二个CDPlayer Bean创建完全相同的CompactDisc实例。Spring会拦截对@Bean注解标注方法的调用并确保返回的是Spring创建的Bean。</p><h4 id="（二）将依赖作为参数"><a href="#（二）将依赖作为参数" class="headerlink" title="（二）将依赖作为参数"></a>（二）将依赖作为参数</h4><p>可以看到通过引用创建Bean的方法来解决这个问题有些让人疑惑，下面这种方式看起来更为容易理解：</p><pre><code>@Beanpublic CDPlayer cdPlayer(CompactDisc compactDisc){    return new CDPlayer(compactDisc);}</code></pre><p>在这里，cdPlayer()方法请求一个CompactDisc作为参数。当Spring调用cdPlayer()方法创建bean的时候，它会自动装配一个CompactDisc到配置方法中。这样方法体就可以在合适的位置使用它，通过这种方式可以避免明确的调用@Bean方法。</p><p>通过这种方式来引用其它Bean是最佳的选择，因为它不要求将依赖声明到同一个配置类当中，甚至它不要求必须要在JavaConfig中声明，实际上它可以通过组件扫描功能来自动发现或者通过XML来进行配置。</p><p>本例中使用了CDPlayer的构造器实现了DI（依赖注入），但是完全可以使用其它风格的DI，比如，你可以使用setter的方式进行注入。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;虽然很多场景下可以使用组件扫描和自动装配来实现Spring的自动化配置，但有些时候自动化配置的方案是行不通的，因此需要明确配置Spring。比如你想讲第三方库中的组件装配到你的应用中，在这种情况下，你必须要显式装配。在进行显式配置的时候，有两种方案，Java和XML。&lt;/p&gt;
&lt;p&gt;下面介绍通过Java代码显式装配Bean。&lt;/p&gt;
    
    </summary>
    
    
      <category term="JAVA" scheme="http://yoursite.com/categories/JAVA/"/>
    
    
      <category term="Spring" scheme="http://yoursite.com/tags/Spring/"/>
    
      <category term="Spring学习笔记" scheme="http://yoursite.com/tags/Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Java代码装配Bean" scheme="http://yoursite.com/tags/Java%E4%BB%A3%E7%A0%81%E8%A3%85%E9%85%8DBean/"/>
    
  </entry>
  
  <entry>
    <title>Java实现数据统计的常用算法</title>
    <link href="http://yoursite.com/2016/09/27/Java%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E7%BB%9F%E8%AE%A1%E7%9A%84%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2016/09/27/Java%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E7%BB%9F%E8%AE%A1%E7%9A%84%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/</id>
    <published>2016-09-27T15:28:29.000Z</published>
    <updated>2020-06-06T22:26:01.817Z</updated>
    
    <content type="html"><![CDATA[<p>做数据处理的人可能经常用到一些比如求中位数、众数、均值等等的常用数学方法，下面整理一些算法，由于都比较简单，不做过多的解释了，直接拿去用就好啦！</p><a id="more"></a><p>package cn.javacodes.utils;</p><p>import java.util.Arrays;<br>import java.util.HashMap;<br>import java.util.Iterator;<br>import java.util.Map;</p><p>/**<br> * 数据统计工具类<br> * @author 胡湛霏<br> * @since 2016-09-27<br> <em>/<br>public class DataStatisticsUtils {<br>    /*\</em><br>     * 求和<br>     *<br>     * @param arr<br>     * @return<br>     */<br>    public static double getSum(double[] arr) {<br>        double sum = 0;<br>        for (double num : arr) {<br>            sum += num;<br>        }<br>        return sum;<br>    }</p><pre><code>/\*\* \* 求均值 \* \* @param arr \* @return */public static double getMean(double\[\] arr) {    return getSum(arr) / arr.length;}/\*\* \* 求众数 \* \* @param arr \* @return */public static double getMode(double\[\] arr) {    Map&lt;Double, Integer&gt; map = new HashMap&lt;Double, Integer&gt;();    for (int i = 0; i &lt; arr.length; i++) {        if (map.containsKey(arr\[i\])) {            map.put(arr\[i\], map.get(arr\[i\]) + 1);        } else {            map.put(arr\[i\], 1);        }    }    int maxCount = 0;    double mode = -1;    Iterator&lt;Double&gt; iter = map.keySet().iterator();    while (iter.hasNext()) {        double num = iter.next();        int count = map.get(num);        if (count &gt; maxCount) {            maxCount = count;            mode = num;        }    }    return mode;}/\*\* \* 求中位数 \* \* @param arr \* @return */public static double getMedian(double\[\] arr) {    double\[\] tempArr = Arrays.copyOf(arr, arr.length);    Arrays.sort(tempArr);    if (tempArr.length % 2 == 0) {        return (tempArr\[tempArr.length &gt;&gt; 1\] + tempArr\[(tempArr.length &gt;&gt; 1) - 1\]) / 2;    } else {        return tempArr\[(tempArr.length &gt;&gt; 1)\];    }}/\*\* \* 求中列数 \* \* @param arr \* @return */public static double getMidrange(double\[\] arr) {    double max = arr\[0\], min = arr\[0\];    for (int i = 0; i &lt; arr.length; i++) {        if (arr\[i\] &gt; max) {            max = arr\[i\];        }        if (arr\[i\] &lt; min) {            min = arr\[i\];        }    }    return (min + max) / 2;}/\*\* \* 求四分位数 \* \* @param arr \* @return 存放三个四分位数的数组 */public static double\[\] getQuartiles(double\[\] arr) {    double\[\] tempArr = Arrays.copyOf(arr, arr.length);    Arrays.sort(tempArr);    double\[\] quartiles = new double\[3\];    // 第二四分位数（中位数）    quartiles\[1\] = getMedian(tempArr);    // 求另外两个四分位数    if (tempArr.length % 2 == 0) {        quartiles\[0\] = getMedian(Arrays.copyOfRange(tempArr, 0, tempArr.length / 2));        quartiles\[2\] = getMedian(Arrays.copyOfRange(tempArr, tempArr.length / 2, tempArr.length));    } else {        quartiles\[0\] = getMedian(Arrays.copyOfRange(tempArr, 0, tempArr.length / 2));        quartiles\[2\] = getMedian(Arrays.copyOfRange(tempArr, tempArr.length / 2 + 1, tempArr.length));    }    return quartiles;}/\*\* \* 求极差 \* \* @param arr \* @return */public static double getRange(double\[\] arr) {    double max = arr\[0\], min = arr\[0\];    for (int i = 0; i &lt; arr.length; i++) {        if (arr\[i\] &gt; max) {            max = arr\[i\];        }        if (arr\[i\] &lt; min) {            min = arr\[i\];        }    }    return max - min;}/\*\* \* 求四分位数极差 \* \* @param arr \* @return */public static double getQuartilesRange(double\[\] arr) {    return getRange(getQuartiles(arr));}/\*\* \* 求截断均值 \* \* @param arr 求值数组 \* @param p   截断量p，例如p的值为20，则截断20%（高10%，低10%） \* @return */public static double getTrimmedMean(double\[\] arr, int p) {    int tmp = arr.length * p / 100;    double\[\] tempArr = Arrays.copyOfRange(arr, tmp, arr.length + 1 - tmp);    return getMean(tempArr);}/\*\* \* 求方差 \* \* @param arr \* @return */public static double getVariance(double\[\] arr) {    double variance = 0;    double sum = 0, sum2 = 0;    for (int i = 0; i &lt; arr.length; i++) {        sum += arr\[i\];        sum2 += arr\[i\] * arr\[i\];    }    variance = sum2 / arr.length - (sum / arr.length) * (sum / arr.length);    return variance;}/\*\* \* 求绝对平均偏差(AAD) \* \* @param arr \* @return */public static double getAbsoluteAverageDeviation(double\[\] arr) {    double sum = 0;    double mean = getMean(arr);    for (int i = 0; i &lt; arr.length; i++) {        sum += Math.abs(arr\[i\] - mean);    }    return sum / arr.length;}/\*\* \* 求中位数绝对偏差(MAD) \* \* @param arr \* @return */public static double getMedianAbsoluteDeviation(double\[\] arr) {    double\[\] tempArr = new double\[arr.length\];    double median = getMedian(arr);    for (int i = 0; i &lt; arr.length; i++) {        tempArr\[i\] = Math.abs(arr\[i\] - median);    }    return getMedian(tempArr);}/\*\* \* 求标准差 \* @param arr \* @return */public static double getStandardDevition(double\[\] arr) {    double sum = 0;    double mean = getMean(arr);    for (int i = 0; i &lt; arr.length; i++) {        sum += Math.sqrt((arr\[i\] - mean) * (arr\[i\] - mean));    }    return (sum / (arr.length - 1));}</code></pre><p>}</p><p>下面还有一些做数据规范化的代码整理：</p><p>package cn.javacodes.utils;</p><p>import java.util.Arrays;</p><p>/**<br> * 数据变化-规范化工具类<br> * @author 胡湛霏<br> * @since 2016-09-27<br> */<br>public class DataConversionUtils {</p><pre><code>/\*\* \* 最小\-最大规范化 \* \* @param arr \* @return 规范化后的数组 */public static double\[\] minMaxNormalize(double\[\] arr) {    // 拷贝数组    double\[\] tempArr = Arrays.copyOf(arr, arr.length);    // 找到最大值和最小值    double max = tempArr\[0\], min = tempArr\[0\];    for (int i = 0; i &lt; tempArr.length; i++) {        if (tempArr\[i\] &gt; max) {            max = tempArr\[i\];        }        if (tempArr\[i\] &lt; min) {            min = tempArr\[i\];        }    }    // 规范化    for (int i = 0; i &lt; tempArr.length; i++) {        tempArr\[i\] = (tempArr\[i\] - min) / (max - min);    }    return tempArr;}/\*\* \* Z-score规范化 \* @param arr \* @return 规范化后的数组 */public static double\[\] zScoreNormalize(double\[\] arr) {    // 拷贝数组    double\[\] tempArr = Arrays.copyOf(arr, arr.length);    // 求均值    double sum = 0;    for (double num : tempArr) {        sum += num;    }    double mean = sum / tempArr.length;    // 求标准差    double sum2 = 0;    for (int i = 0; i &lt; tempArr.length; i++) {        sum2 += Math.sqrt((tempArr\[i\] - mean) * (tempArr\[i\] - mean));    }    double standardDivition = sum2 / (tempArr.length - 1);    // 标准化    for (int i = 0; i &lt; tempArr.length; i++) {        tempArr\[i\] = (tempArr\[i\] - mean) / standardDivition;    }    return tempArr;}/\*\* \* 小数定标规范化 \* @param arr \* @return 规范化后的数组 */public static double\[\] decimalsNormalize(double\[\] arr){    // 拷贝数组    double\[\] tempArr = Arrays.copyOf(arr, arr.length);    // 找到最大值    double max = tempArr\[0\];    for (int i = 0; i &lt; tempArr.length; i++) {        if (tempArr\[i\] &gt; max) {            max = tempArr\[i\];        }    }    // 确定j的值（j为使max(|v&apos;|)&lt;1的最小整数）    int j = 0;    while (Math.abs(max/Math.pow(10,j))&gt;=1){        j++;    }    // 规范化    for (int i = 0; i &lt; tempArr.length; i++) {        tempArr\[i\] = tempArr\[i\] / Math.pow(10,j);    }    return tempArr;}</code></pre><p>}</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;做数据处理的人可能经常用到一些比如求中位数、众数、均值等等的常用数学方法，下面整理一些算法，由于都比较简单，不做过多的解释了，直接拿去用就好啦！&lt;/p&gt;
    
    </summary>
    
    
      <category term="JAVA" scheme="http://yoursite.com/categories/JAVA/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="中位数" scheme="http://yoursite.com/tags/%E4%B8%AD%E4%BD%8D%E6%95%B0/"/>
    
      <category term="众数" scheme="http://yoursite.com/tags/%E4%BC%97%E6%95%B0/"/>
    
      <category term="四分位数" scheme="http://yoursite.com/tags/%E5%9B%9B%E5%88%86%E4%BD%8D%E6%95%B0/"/>
    
      <category term="常用算法" scheme="http://yoursite.com/tags/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据处理" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/"/>
    
      <category term="方差" scheme="http://yoursite.com/tags/%E6%96%B9%E5%B7%AE/"/>
    
      <category term="极差" scheme="http://yoursite.com/tags/%E6%9E%81%E5%B7%AE/"/>
    
      <category term="标准差" scheme="http://yoursite.com/tags/%E6%A0%87%E5%87%86%E5%B7%AE/"/>
    
  </entry>
  
</feed>
