<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ByteLife</title>
  
  <subtitle>技术交流与学习自留地</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://bytelife.net/"/>
  <updated>2020-06-08T16:30:46.311Z</updated>
  <id>https://bytelife.net/</id>
  
  <author>
    <name>Jeffrey Hu</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>动态规划算法问题（经典找零案例）</title>
    <link href="https://bytelife.net/articles/dong-tai-gui-hua-suan-fa-wen-ti-jing-dian-zhao-ling-an-li.html"/>
    <id>https://bytelife.net/articles/dong-tai-gui-hua-suan-fa-wen-ti-jing-dian-zhao-ling-an-li.html</id>
    <published>2017-03-19T17:51:28.000Z</published>
    <updated>2020-06-08T16:30:46.311Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;问题： 给定数组arr，arr中的所有的值都为正数且不重复。每个值代表一种面值的货币，每种面值的货币可以使用任意张，再给定一个整数aim代表要找的钱数，求换钱有多少种方法。&lt;/p&gt;
    
    </summary>
    
    
      <category term="JAVA" scheme="https://bytelife.net/categories/JAVA/"/>
    
    
      <category term="动态规划" scheme="https://bytelife.net/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="算法" scheme="https://bytelife.net/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>浅析ClassNotFoundException与NoClassDefFoundError</title>
    <link href="https://bytelife.net/articles/qian-xi-classnotfoundexception-yu-noclassdeffounderror.html"/>
    <id>https://bytelife.net/articles/qian-xi-classnotfoundexception-yu-noclassdeffounderror.html</id>
    <published>2017-03-18T02:57:13.000Z</published>
    <updated>2020-06-08T16:30:46.311Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;最近接到电话面试中，面试官问我ClassNotFoundException与NoClassDefFoundError有什么样的区别，至于前者经常遇到，我还是能答上一些，至于后者，完全没遇到过啊，只好瞎编了，都忘记当时是怎么回答的。然后面试官问我他们都会出现在哪些情况，ClassNotFoundException我还可以说出几种情况，可是后者这下不能编了，只好求饶。结果面试官还给我讲解了一下，感觉非常尴尬。 回来以后又查阅了一些相关的资料，并尝试了一下，整理分享给网友。&lt;/p&gt;
    
    </summary>
    
    
      <category term="JAVA" scheme="https://bytelife.net/categories/JAVA/"/>
    
    
      <category term="Java" scheme="https://bytelife.net/tags/Java/"/>
    
      <category term="类加载" scheme="https://bytelife.net/tags/%E7%B1%BB%E5%8A%A0%E8%BD%BD/"/>
    
      <category term="异常" scheme="https://bytelife.net/tags/%E5%BC%82%E5%B8%B8/"/>
    
  </entry>
  
  <entry>
    <title>ThreadLocal 详解</title>
    <link href="https://bytelife.net/articles/threadlocal-xiang-jie.html"/>
    <id>https://bytelife.net/articles/threadlocal-xiang-jie.html</id>
    <published>2017-03-15T15:34:01.000Z</published>
    <updated>2020-06-08T16:30:46.307Z</updated>
    
    <summary type="html">
    
      &lt;h2 id=&quot;ThreadLocal是什么&quot;&gt;&lt;a href=&quot;#ThreadLocal是什么&quot; class=&quot;headerlink&quot; title=&quot;ThreadLocal是什么&quot;&gt;&lt;/a&gt;ThreadLocal是什么&lt;/h2&gt;&lt;p&gt;　　早在JDK 1.2的版本中就提供Java.lang.ThreadLocal，ThreadLocal为解决多线程程序的并发问题提供了一种新的思路。使用这个工具类可以很简洁地编写出优美的多线程程序。 　　 　　当使用ThreadLocal维护变量时，ThreadLocal为每个使用该变量的线程提供独立的变量副本，所以每一个线程都可以独立地改变自己的副本，而不会影响其它线程所对应的副本。 　　 　　从线程的角度看，目标变量就象是线程的本地变量，这也是类名中“Local”所要表达的意思。 　　 　　所以，在Java中编写线程局部变量的代码相对来说要笨拙一些，因此造成线程局部变量没有在Java开发者中得到很好的普及。 　　&lt;/p&gt;
    
    </summary>
    
    
      <category term="JAVA" scheme="https://bytelife.net/categories/JAVA/"/>
    
    
      <category term="Java" scheme="https://bytelife.net/tags/Java/"/>
    
      <category term="并发" scheme="https://bytelife.net/tags/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="ThreadLocal" scheme="https://bytelife.net/tags/ThreadLocal/"/>
    
  </entry>
  
  <entry>
    <title>Java NIO 教程详解</title>
    <link href="https://bytelife.net/articles/java-nio-jiao-cheng-xiang-jie.html"/>
    <id>https://bytelife.net/articles/java-nio-jiao-cheng-xiang-jie.html</id>
    <published>2017-03-14T17:34:53.000Z</published>
    <updated>2020-06-08T16:30:46.307Z</updated>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;英文原文地址：&lt;a href=&quot;http://tutorials.jenkov.com/java-nio/index.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://tutorials.jenkov.com/java-nio/index.html&lt;/a&gt; 中文来源地址：&lt;a href=&quot;http://ifeve.com/java-nio-all/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://ifeve.com/java-nio-all/&lt;/a&gt; 作者：Jakob Jenkov 译者：郭蕾 校对：方腾飞 本文由&lt;a href=&quot;https://cdn.javacodes.cn&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;老H博客&lt;/a&gt;整理修订&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;[TOC] Java NIO(New IO)是一个可以替代标准Java IO API的IO API（从Java 1.4开始)，Java NIO提供了与标准IO不同的IO工作方式。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Java NIO: Channels and Buffers（通道和缓冲区）&lt;/strong&gt;：标准的IO基于字节流和字符流进行操作的，而NIO是基于通道（Channel）和缓冲区（Buffer）进行操作，数据总是从通道读取到缓冲区中，或者从缓冲区写入到通道中。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Java NIO: Non-blocking IO（非阻塞IO）&lt;/strong&gt;：Java NIO可以让你非阻塞的使用IO，例如：当线程从通道读取数据到缓冲区时，线程还是可以进行其他事情。当数据被写入到缓冲区时，线程可以继续处理它。从缓冲区写入通道也类似。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Java NIO: Selectors（选择器）&lt;/strong&gt;：Java NIO引入了选择器的概念，选择器用于监听多个通道的事件（比如：连接打开，数据到达）。因此，单个的线程可以监听多个数据通道。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="JAVA" scheme="https://bytelife.net/categories/JAVA/"/>
    
    
      <category term="Java" scheme="https://bytelife.net/tags/Java/"/>
    
      <category term="NIO" scheme="https://bytelife.net/tags/NIO/"/>
    
  </entry>
  
  <entry>
    <title>Java中的Copy-On-Write容器</title>
    <link href="https://bytelife.net/articles/java-zhong-de-copy-on-write-rong-qi.html"/>
    <id>https://bytelife.net/articles/java-zhong-de-copy-on-write-rong-qi.html</id>
    <published>2017-03-14T17:16:23.000Z</published>
    <updated>2020-06-08T16:30:46.307Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;Copy-On-Write简称COW，是一种用于程序设计中的优化策略。其基本思路是，从一开始大家都在共享同一个内容，当某个人想要修改这个内容的时候，才会真正把内容Copy出去形成一个新的内容然后再改，这是一种延时懒惰策略。从JDK1.5开始Java并发包里提供了两个使用CopyOnWrite机制实现的并发容器,它们是CopyOnWriteArrayList和CopyOnWriteArraySet。CopyOnWrite容器非常有用，可以在非常多的并发场景中使用到。&lt;/p&gt;
    
    </summary>
    
    
      <category term="JAVA" scheme="https://bytelife.net/categories/JAVA/"/>
    
    
      <category term="Java" scheme="https://bytelife.net/tags/Java/"/>
    
      <category term="并发" scheme="https://bytelife.net/tags/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="CopyOnWrite" scheme="https://bytelife.net/tags/CopyOnWrite/"/>
    
  </entry>
  
  <entry>
    <title>ConcurrentLinkedQueue的实现原理分析</title>
    <link href="https://bytelife.net/articles/concurrentlinkedqueue-de-shi-xian-yuan-li-fen-xi.html"/>
    <id>https://bytelife.net/articles/concurrentlinkedqueue-de-shi-xian-yuan-li-fen-xi.html</id>
    <published>2017-03-14T17:10:55.000Z</published>
    <updated>2020-06-08T16:30:46.307Z</updated>
    
    <summary type="html">
    
      &lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;&lt;p&gt;在并发编程中我们有时候需要使用线程安全的队列。如果我们要实现一个线程安全的队列有两种实现方式：一种是使用阻塞算法，另一种是使用非阻塞算法。使用阻塞算法的队列可以用一个锁（入队和出队用同一把锁）或两个锁（入队和出队用不同的锁）等方式来实现，而非阻塞的实现方式则可以使用循环CAS的方式来实现，本文让我们一起来研究下Doug Lea是如何使用非阻塞的方式来实现线程安全队列ConcurrentLinkedQueue的，相信从大师身上我们能学到不少并发编程的技巧。&lt;/p&gt;
    
    </summary>
    
    
      <category term="JAVA" scheme="https://bytelife.net/categories/JAVA/"/>
    
    
      <category term="ConcurrentLinkedQueue" scheme="https://bytelife.net/tags/ConcurrentLinkedQueue/"/>
    
      <category term="Java" scheme="https://bytelife.net/tags/Java/"/>
    
      <category term="并发" scheme="https://bytelife.net/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>深入剖析 ConcurrentHashMap</title>
    <link href="https://bytelife.net/articles/shen-ru-pou-xi-concurrenthashmap.html"/>
    <id>https://bytelife.net/articles/shen-ru-pou-xi-concurrenthashmap.html</id>
    <published>2017-03-14T14:31:36.000Z</published>
    <updated>2020-06-08T16:30:46.311Z</updated>
    
    <summary type="html">
    
      &lt;h3 id=&quot;术语定义&quot;&gt;&lt;a href=&quot;#术语定义&quot; class=&quot;headerlink&quot; title=&quot;术语定义&quot;&gt;&lt;/a&gt;术语定义&lt;/h3&gt;&lt;p&gt;术语&lt;/p&gt;
&lt;p&gt;英文&lt;/p&gt;
&lt;p&gt;解释&lt;/p&gt;
&lt;p&gt;哈希算法&lt;/p&gt;
&lt;p&gt;hash algorithm&lt;/p&gt;
&lt;p&gt;是一种将任意内容的输入转换成相同长度输出的加密方式，其输出被称为哈希值。 &lt;/p&gt;
    
    </summary>
    
    
      <category term="JAVA" scheme="https://bytelife.net/categories/JAVA/"/>
    
    
      <category term="Java" scheme="https://bytelife.net/tags/Java/"/>
    
      <category term="并发" scheme="https://bytelife.net/tags/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="ConcurrentHashMap" scheme="https://bytelife.net/tags/ConcurrentHashMap/"/>
    
  </entry>
  
  <entry>
    <title>HashMap实现原理及源码分析</title>
    <link href="https://bytelife.net/articles/hashmap-shi-xian-yuan-li-ji-yuan-ma-fen-xi.html"/>
    <id>https://bytelife.net/articles/hashmap-shi-xian-yuan-li-ji-yuan-ma-fen-xi.html</id>
    <published>2017-03-12T10:28:32.000Z</published>
    <updated>2020-06-08T16:30:46.307Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;哈希表（hash table）也叫散列表，是一种非常重要的数据结构，应用场景及其丰富，许多缓存技术（比如memcached）的核心其实就是在内存中维护一张大的哈希表，而HashMap的实现原理也常常出现在各类的面试题中，重要性可见一斑。本文会对java集合框架中的对应实现HashMap的实现原理进行讲解，然后会对JDK7的HashMap源码进行分析。&lt;/p&gt;
    
    </summary>
    
    
      <category term="JAVA" scheme="https://bytelife.net/categories/JAVA/"/>
    
    
      <category term="Java" scheme="https://bytelife.net/tags/Java/"/>
    
      <category term="HashMap" scheme="https://bytelife.net/tags/HashMap/"/>
    
  </entry>
  
  <entry>
    <title>Java类加载机制-类加载器（ClassLoader）与双亲委派模型</title>
    <link href="https://bytelife.net/articles/java-lei-jia-zai-ji-zhi-lei-jia-zai-qi-classloader-yu-shuang-qin-wei-pai-mo-xing.html"/>
    <id>https://bytelife.net/articles/java-lei-jia-zai-ji-zhi-lei-jia-zai-qi-classloader-yu-shuang-qin-wei-pai-mo-xing.html</id>
    <published>2017-03-12T08:34:51.000Z</published>
    <updated>2020-06-08T16:30:46.307Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;Java虚拟机类加载过程中的“加载”阶段第一步就是“通过一个类的全限定名来获取描述此类的二级制字节流”，这个动作由Java虚拟机外部实现，以便让应用程序自己决定如何去获取所需要的类，实现这个动作的模块叫做“类加载器”。&lt;/p&gt;
    
    </summary>
    
    
      <category term="JAVA" scheme="https://bytelife.net/categories/JAVA/"/>
    
    
      <category term="Java" scheme="https://bytelife.net/tags/Java/"/>
    
      <category term="JVM" scheme="https://bytelife.net/tags/JVM/"/>
    
      <category term="ClassLoader" scheme="https://bytelife.net/tags/ClassLoader/"/>
    
      <category term="类加载" scheme="https://bytelife.net/tags/%E7%B1%BB%E5%8A%A0%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title>Java类加载机制-类加载的时机和过程</title>
    <link href="https://bytelife.net/articles/java-lei-jia-zai-ji-zhi-lei-jia-zai-de-shi-ji-he-guo-cheng.html"/>
    <id>https://bytelife.net/articles/java-lei-jia-zai-ji-zhi-lei-jia-zai-de-shi-ji-he-guo-cheng.html</id>
    <published>2017-03-12T05:33:28.000Z</published>
    <updated>2020-06-08T16:30:46.307Z</updated>
    
    <summary type="html">
    
      &lt;h2 id=&quot;类加载的时机&quot;&gt;&lt;a href=&quot;#类加载的时机&quot; class=&quot;headerlink&quot; title=&quot;类加载的时机&quot;&gt;&lt;/a&gt;类加载的时机&lt;/h2&gt;&lt;p&gt;类从被加载到虚拟机开始，到卸载为止，生命周期如图所示： &lt;img src=&quot;https://cdn.javacodes.cn/files/2017/03/2017-03-12_05-33-29.png&quot; srcset=&quot;/img/loading.gif&quot; alt=&quot;&quot;&gt; 其中，加载、验证、准备、初始化、卸载这五个阶段的顺序是确定的，类的加载过程必须按照这种顺序按部就班的开始（开始不代表完成，通常为交叉混合运行），而解析阶段不一定：它在某些情况下可以在初始化阶段之后再开始。 &lt;/p&gt;
    
    </summary>
    
    
      <category term="JAVA" scheme="https://bytelife.net/categories/JAVA/"/>
    
    
      <category term="Java" scheme="https://bytelife.net/tags/Java/"/>
    
      <category term="JVM" scheme="https://bytelife.net/tags/JVM/"/>
    
      <category term="ClassLoader" scheme="https://bytelife.net/tags/ClassLoader/"/>
    
      <category term="类加载" scheme="https://bytelife.net/tags/%E7%B1%BB%E5%8A%A0%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title>Java垃圾回收机制（GC）</title>
    <link href="https://bytelife.net/articles/java-la-ji-hui-shou-ji-zhi-gc.html"/>
    <id>https://bytelife.net/articles/java-la-ji-hui-shou-ji-zhi-gc.html</id>
    <published>2017-03-11T12:38:18.000Z</published>
    <updated>2020-06-08T16:30:46.307Z</updated>
    
    <summary type="html">
    
      &lt;h3 id=&quot;判断对象是否可回收的常见方法&quot;&gt;&lt;a href=&quot;#判断对象是否可回收的常见方法&quot; class=&quot;headerlink&quot; title=&quot;判断对象是否可回收的常见方法&quot;&gt;&lt;/a&gt;判断对象是否可回收的常见方法&lt;/h3&gt;&lt;h4 id=&quot;引用计数算法（Reference-Counting）&quot;&gt;&lt;a href=&quot;#引用计数算法（Reference-Counting）&quot; class=&quot;headerlink&quot; title=&quot;引用计数算法（Reference Counting）&quot;&gt;&lt;/a&gt;引用计数算法（Reference Counting）&lt;/h4&gt;&lt;p&gt;给对象中添加一个引用计数器，每当有一个地方引用时，计数器加1；当引用失效时，计数器减1；任何时刻计数器为0的对象就是不可能再被使用的。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;优点：实现简单，判定效率高；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;缺点：很难解决对象之间的循环引用问题；&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;JVM并不使用这种算法。&lt;/p&gt;
    
    </summary>
    
    
      <category term="JAVA" scheme="https://bytelife.net/categories/JAVA/"/>
    
    
      <category term="Java" scheme="https://bytelife.net/tags/Java/"/>
    
      <category term="JVM" scheme="https://bytelife.net/tags/JVM/"/>
    
      <category term="GC" scheme="https://bytelife.net/tags/GC/"/>
    
      <category term="垃圾回收" scheme="https://bytelife.net/tags/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"/>
    
  </entry>
  
  <entry>
    <title>常用JVM启动参数</title>
    <link href="https://bytelife.net/articles/chang-yong-jvm-qi-dong-can-shu.html"/>
    <id>https://bytelife.net/articles/chang-yong-jvm-qi-dong-can-shu.html</id>
    <published>2017-03-11T10:20:57.000Z</published>
    <updated>2020-06-08T16:30:46.311Z</updated>
    
    <summary type="html">
    
      &lt;h3 id=&quot;verbose&quot;&gt;&lt;a href=&quot;#verbose&quot; class=&quot;headerlink&quot; title=&quot;-verbose&quot;&gt;&lt;/a&gt;-verbose&lt;/h3&gt;&lt;p&gt;java -verbose[:class|gc|jni] 在输出设备上显示虚拟机运行信息。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;-verbose:class：监视输出运行期间的类加载情况&lt;/li&gt;
&lt;li&gt;-verbose:gc：监视输出运行期间的内存回收GC情况&lt;/li&gt;
&lt;li&gt;-verbose:jni：监视输出native方法调用的相关情况，一般用于诊断jni调用错误信息。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="JAVA" scheme="https://bytelife.net/categories/JAVA/"/>
    
    
      <category term="Java" scheme="https://bytelife.net/tags/Java/"/>
    
      <category term="JVM" scheme="https://bytelife.net/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>JVM内存划分</title>
    <link href="https://bytelife.net/articles/jvm-nei-cun-hua-fen.html"/>
    <id>https://bytelife.net/articles/jvm-nei-cun-hua-fen.html</id>
    <published>2017-03-11T05:11:49.000Z</published>
    <updated>2020-06-08T16:30:46.307Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;Java虚拟机内存规范所管理的内存包括如下运行时数据区域：程序计数器、虚拟机栈、本地方法栈、Java堆、方法区等。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.javacodes.cn/files/2017/03/2017-03-11_05-11-49.png&quot; srcset=&quot;/img/loading.gif&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="JAVA" scheme="https://bytelife.net/categories/JAVA/"/>
    
    
      <category term="Java" scheme="https://bytelife.net/tags/Java/"/>
    
      <category term="JVM" scheme="https://bytelife.net/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>TCP加速锐速SS（ServerSpeeder）破解版一键安装</title>
    <link href="https://bytelife.net/articles/tcp-jia-su-rui-su-ss-serverspeeder-po-jie-ban-yi-jian-an-zhuang.html"/>
    <id>https://bytelife.net/articles/tcp-jia-su-rui-su-ss-serverspeeder-po-jie-ban-yi-jian-an-zhuang.html</id>
    <published>2016-10-30T07:46:21.000Z</published>
    <updated>2020-06-08T16:30:46.307Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;锐速（serverspeeder），是一款TCP加速程序，能够增强VPS/服务器连接的稳定性，且有效的提高服务器的带宽利用率，进而提高访问速度。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux/服务器/网络" scheme="https://bytelife.net/categories/Linux-%E6%9C%8D%E5%8A%A1%E5%99%A8-%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="Linux" scheme="https://bytelife.net/tags/Linux/"/>
    
      <category term="ServerSpeeder" scheme="https://bytelife.net/tags/ServerSpeeder/"/>
    
      <category term="SS" scheme="https://bytelife.net/tags/SS/"/>
    
      <category term="锐速" scheme="https://bytelife.net/tags/%E9%94%90%E9%80%9F/"/>
    
  </entry>
  
  <entry>
    <title>Spring学习笔记之Bean的作用域</title>
    <link href="https://bytelife.net/articles/spring-xue-xi-bi-ji-zhi-bean-de-zuo-yong-yu.html"/>
    <id>https://bytelife.net/articles/spring-xue-xi-bi-ji-zhi-bean-de-zuo-yong-yu.html</id>
    <published>2016-10-20T09:31:11.000Z</published>
    <updated>2020-06-08T16:30:46.307Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;在默认情况下，Spring的应用上下文中所有的bean都是单例的形式创建的。也就是说，不管给定的一个bean被注入到其它bean多少次，每次注入的都是同一个实例。&lt;/p&gt;
&lt;p&gt;在大多数情况下，单例bean是非常理想的方案。初始化和垃圾回收对象实例所带来的成本只留给一些小规模任务，在这些任务中，让对象保持无状态并且在应用中反复重用这些对象可能并不合理。&lt;/p&gt;
&lt;p&gt;有时候你所使用的类可能是易变的，它们会保持一些状态，比如我们在Web购物商城中常见的购物车功能，不同的用户不可能同时使用同一个购物车实例，因此重用是不安全的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="JAVA" scheme="https://bytelife.net/categories/JAVA/"/>
    
    
      <category term="request" scheme="https://bytelife.net/tags/request/"/>
    
      <category term="session" scheme="https://bytelife.net/tags/session/"/>
    
      <category term="Spring" scheme="https://bytelife.net/tags/Spring/"/>
    
      <category term="Spring学习笔记" scheme="https://bytelife.net/tags/Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="代理" scheme="https://bytelife.net/tags/%E4%BB%A3%E7%90%86/"/>
    
      <category term="会话" scheme="https://bytelife.net/tags/%E4%BC%9A%E8%AF%9D/"/>
    
      <category term="作用域" scheme="https://bytelife.net/tags/%E4%BD%9C%E7%94%A8%E5%9F%9F/"/>
    
      <category term="请求" scheme="https://bytelife.net/tags/%E8%AF%B7%E6%B1%82/"/>
    
  </entry>
  
  <entry>
    <title>Spring学习笔记之处理自动装配的歧义性</title>
    <link href="https://bytelife.net/articles/spring-xue-xi-bi-ji-zhi-chu-li-zi-dong-zhuang-pei-de-qi-yi-xing.html"/>
    <id>https://bytelife.net/articles/spring-xue-xi-bi-ji-zhi-chu-li-zi-dong-zhuang-pei-de-qi-yi-xing.html</id>
    <published>2016-10-20T09:23:41.000Z</published>
    <updated>2020-06-08T16:30:46.307Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;之前的文章中已经看到了Spring的自动装配有很大的用处，它可以帮助我们快速的装配bean，但是这里存在一个问题，在之前的装配中，仅有一个bean匹配所需的结果时，自动装配才是有效的。如果不仅只有一个bean能够匹配结果的话，这就会导致Spring不知道该装配哪个bean从而导致装配失败，例如下面这个例子，我们定义了一个Dessert接口，并且有三个类实现了这个接口，分别为Cake、Cookies和IceCream：&lt;/p&gt;
&lt;p&gt;@Component&lt;br&gt;public class Cookies implements Dessert {&lt;br&gt;}&lt;br&gt;@Component&lt;br&gt;public class Cake implements Dessert {&lt;br&gt;}&lt;br&gt;@Component&lt;br&gt;public class IceCream implements Dessert {&lt;br&gt;}&lt;/p&gt;
    
    </summary>
    
    
      <category term="JAVA" scheme="https://bytelife.net/categories/JAVA/"/>
    
    
      <category term="Spring" scheme="https://bytelife.net/tags/Spring/"/>
    
      <category term="Spring学习笔记" scheme="https://bytelife.net/tags/Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="@Qualifier" scheme="https://bytelife.net/tags/Qualifier/"/>
    
      <category term="Primary" scheme="https://bytelife.net/tags/Primary/"/>
    
      <category term="自动装配歧义性" scheme="https://bytelife.net/tags/%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E6%AD%A7%E4%B9%89%E6%80%A7/"/>
    
      <category term="首选Bean" scheme="https://bytelife.net/tags/%E9%A6%96%E9%80%89Bean/"/>
    
  </entry>
  
  <entry>
    <title>Spring学习笔记之通过XML装配Bean的一些细节</title>
    <link href="https://bytelife.net/articles/spring-xue-xi-bi-ji-zhi-tong-guo-xml-zhuang-pei-bean-de-yi-xie-xi-jie.html"/>
    <id>https://bytelife.net/articles/spring-xue-xi-bi-ji-zhi-tong-guo-xml-zhuang-pei-bean-de-yi-xie-xi-jie.html</id>
    <published>2016-10-20T09:13:13.000Z</published>
    <updated>2020-06-08T16:30:46.307Z</updated>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一、c命名空间&quot;&gt;&lt;a href=&quot;#一、c命名空间&quot; class=&quot;headerlink&quot; title=&quot;一、c命名空间&quot;&gt;&lt;/a&gt;一、c命名空间&lt;/h3&gt;&lt;p&gt;通过构造器注入Bean的时候通常需要使用到&lt;constructor-arg&gt;元素，作为替代的方案，可以使用Spring的c-命名空间。c-命名空间是在Spring 3.0中加入的，它是在XML中更为简洁地描述构造器参数的方式。要使用c-命名空间，必须要在XML的顶部声明其模式，如下所示：&lt;/constructor-arg&gt;&lt;/p&gt;
&lt;!--?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?--&gt;
&lt;p&gt;&lt;beans xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:c=&quot;http://www.springframework.org/schema/c&quot; xsi:schemalocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;&lt;br&gt;&lt;/beans&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="JAVA" scheme="https://bytelife.net/categories/JAVA/"/>
    
    
      <category term="Spring" scheme="https://bytelife.net/tags/Spring/"/>
    
      <category term="Spring学习笔记" scheme="https://bytelife.net/tags/Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="c命名空间" scheme="https://bytelife.net/tags/c%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4/"/>
    
      <category term="p命名空间" scheme="https://bytelife.net/tags/p%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4/"/>
    
      <category term="util命名空间" scheme="https://bytelife.net/tags/util%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4/"/>
    
      <category term="装配集合" scheme="https://bytelife.net/tags/%E8%A3%85%E9%85%8D%E9%9B%86%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>Spring学习笔记之通过Java代码装配Bean</title>
    <link href="https://bytelife.net/articles/spring-xue-xi-bi-ji-zhi-tong-guo-java-dai-ma-zhuang-pei-bean.html"/>
    <id>https://bytelife.net/articles/spring-xue-xi-bi-ji-zhi-tong-guo-java-dai-ma-zhuang-pei-bean.html</id>
    <published>2016-10-20T09:03:27.000Z</published>
    <updated>2020-06-08T16:30:46.307Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;虽然很多场景下可以使用组件扫描和自动装配来实现Spring的自动化配置，但有些时候自动化配置的方案是行不通的，因此需要明确配置Spring。比如你想讲第三方库中的组件装配到你的应用中，在这种情况下，你必须要显式装配。在进行显式配置的时候，有两种方案，Java和XML。&lt;/p&gt;
&lt;p&gt;下面介绍通过Java代码显式装配Bean。&lt;/p&gt;
    
    </summary>
    
    
      <category term="JAVA" scheme="https://bytelife.net/categories/JAVA/"/>
    
    
      <category term="Spring" scheme="https://bytelife.net/tags/Spring/"/>
    
      <category term="Spring学习笔记" scheme="https://bytelife.net/tags/Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Java代码装配Bean" scheme="https://bytelife.net/tags/Java%E4%BB%A3%E7%A0%81%E8%A3%85%E9%85%8DBean/"/>
    
  </entry>
  
  <entry>
    <title>Java实现数据统计的常用算法</title>
    <link href="https://bytelife.net/articles/java-shi-xian-shu-ju-tong-ji-de-chang-yong-suan-fa.html"/>
    <id>https://bytelife.net/articles/java-shi-xian-shu-ju-tong-ji-de-chang-yong-suan-fa.html</id>
    <published>2016-09-27T15:28:29.000Z</published>
    <updated>2020-06-08T16:30:46.307Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;做数据处理的人可能经常用到一些比如求中位数、众数、均值等等的常用数学方法，下面整理一些算法，由于都比较简单，不做过多的解释了，直接拿去用就好啦！&lt;/p&gt;
    
    </summary>
    
    
      <category term="JAVA" scheme="https://bytelife.net/categories/JAVA/"/>
    
    
      <category term="Java" scheme="https://bytelife.net/tags/Java/"/>
    
      <category term="中位数" scheme="https://bytelife.net/tags/%E4%B8%AD%E4%BD%8D%E6%95%B0/"/>
    
      <category term="众数" scheme="https://bytelife.net/tags/%E4%BC%97%E6%95%B0/"/>
    
      <category term="四分位数" scheme="https://bytelife.net/tags/%E5%9B%9B%E5%88%86%E4%BD%8D%E6%95%B0/"/>
    
      <category term="常用算法" scheme="https://bytelife.net/tags/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据处理" scheme="https://bytelife.net/tags/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/"/>
    
      <category term="方差" scheme="https://bytelife.net/tags/%E6%96%B9%E5%B7%AE/"/>
    
      <category term="极差" scheme="https://bytelife.net/tags/%E6%9E%81%E5%B7%AE/"/>
    
      <category term="标准差" scheme="https://bytelife.net/tags/%E6%A0%87%E5%87%86%E5%B7%AE/"/>
    
  </entry>
  
  <entry>
    <title>IntelliJ Idea 常用快捷键列表</title>
    <link href="https://bytelife.net/articles/intellij-idea-chang-yong-kuai-jie-jian-lie-biao.html"/>
    <id>https://bytelife.net/articles/intellij-idea-chang-yong-kuai-jie-jian-lie-biao.html</id>
    <published>2016-09-26T16:36:21.000Z</published>
    <updated>2020-06-08T16:30:46.307Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;Ctrl+Shift + Enter，语句完成 “！”，否定完成，输入表达式时按 “！”键&lt;br&gt;Ctrl+E，最近的文件&lt;br&gt;Ctrl+Shift+E，最近更改的文件 Shift+Click，可以关闭文件&lt;br&gt;Ctrl+[ OR ]，可以跑到大括号的开头与结尾&lt;br&gt;Ctrl+F12，可以显示当前文件的结构&lt;br&gt;Ctrl+F7，可以查询当前元素在当前文件中的引用，然后按 F3 可以选择&lt;br&gt;Ctrl+N，可以快速打开类 &lt;/p&gt;
    
    </summary>
    
    
      <category term="JAVA" scheme="https://bytelife.net/categories/JAVA/"/>
    
    
      <category term="IntelliJ Idea" scheme="https://bytelife.net/tags/IntelliJ-Idea/"/>
    
      <category term="常用快捷键" scheme="https://bytelife.net/tags/%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
    
  </entry>
  
</feed>
