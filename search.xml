<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>AJAX技术入门详解</title>
    <url>/2016/07/23/AJAX%E6%8A%80%E6%9C%AF%E5%85%A5%E9%97%A8%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<blockquote>
<p>前言：Ajax是当今Web应用程序开发过程中必不可少的一种技术，使用它可以通过异步处理的方式极大的提高用户体验，这篇文章将以简单易懂的方式介绍AJAX技术。</p>
</blockquote>
<h3 id="AJAX技术简介"><a href="#AJAX技术简介" class="headerlink" title="AJAX技术简介"></a>AJAX技术简介</h3><p>AJAX即“Asynchronous Javascript And XML”（异步JavaScript和XML），音译为“阿贾克斯”，是指一种创建交互式网页应用的网页开发技术。AJAX通过在后台服务器进行少量的数据交换，实现对网页的异步刷新，即可以在不重新加载整个网页的情况下，对网页的局部进行更新。 Ajax 不是一个新的技术，事实上，它是一些旧有的成熟的技术以一种全新的更加强大的方式整合在一起 Ajax的关键技术：</p>
<ul>
<li>使用XHTML(HTML)和CSS构建标准化的展示层</li>
<li>使用DOM进行动态显示和交互</li>
<li>使用XML和XSLT进行数据交换和操纵</li>
<li>使用XMLHttpRequest异步获取数据</li>
<li>使用JavaScript将所有元素绑定在一起</li>
</ul>
<a id="more"></a>

<h3 id="传统Web应用的同步处理方式"><a href="#传统Web应用的同步处理方式" class="headerlink" title="传统Web应用的同步处理方式"></a>传统Web应用的同步处理方式</h3><p>在传统的Web应用中，如果我们需要更新网页内容，必须重新加载整个页面，传统Web应用同步处理方式模型图如下：</p>
<p><img data-src="https://cdn.javacodes.cn/files/2016/07/2016-07-22_15-21-39.png" alt="传统web应用模型图"></p>
<p>我们可以看到，在传统的Web应用模型下，客户机 （浏览器或者本地机器上运行的代码）向服务器发出请求。该请求是同步的，客户机等待服务器的响应。当客户机等待的时候，会用某种形式通知您正在处理：</p>
<ul>
<li>沙漏（特别是 Windows 上）</li>
<li>旋转皮球（通常在 Mac 机器上）</li>
<li>应用程序基本上冻结了，然后过一段时间光标变化了</li>
</ul>
<p>这正是传统Web 应用程序让人感到笨拙或缓慢的原因：缺乏真正的交互性。 按下按钮时，应用程序实际上变得不能使用，直到刚刚触发的请求得到响应。如果请求需要大量服务器处理，那么等待的时间可能很长。这对用户体验是非常不友好的。</p>
<h3 id="AJAX应用的异步处理方式"><a href="#AJAX应用的异步处理方式" class="headerlink" title="AJAX应用的异步处理方式"></a>AJAX应用的异步处理方式</h3><p>Ajax应用通过在用户和服务器之间引入一个媒介（Ajax engine）来异步发送请求，消除了传统的发送请求－等待－发送请求－等待的特性，极大的提高了用户体验。 Ajax应用的异步处理方式模型图如下： <img data-src="https://cdn.javacodes.cn/files/2016/07/2016-07-22_15-26-15.png" alt="AJAX应用模型图"> 我们在图中可以看到，当用户在浏览器中进行一定的操作（比如点击按钮）请求更新网页内容，浏览器将请求交由AJAX处理，AJAX引擎收到将请求提交给服务器，此时浏览器端无需刷新当前页面，待服务器处理完成请求后，将响应传给AJAX引擎，由AJAX来更新网页的部分内容。 这样的处理在浏览器端用户完全无需等待，完全由AJAX来完成整个处理。这种处理方式就是异步处理。</p>
<h3 id="传统Web应用与Ajax应用的比较"><a href="#传统Web应用与Ajax应用的比较" class="headerlink" title="传统Web应用与Ajax应用的比较"></a>传统Web应用与Ajax应用的比较</h3><p>废话不多说，直接看图： <img data-src="https://cdn.javacodes.cn/files/2016/07/2016-07-22_15-31-34.png" alt="AJAX与传统WEB比较"></p>
<h3 id="创建AJAX核心对象"><a href="#创建AJAX核心对象" class="headerlink" title="创建AJAX核心对象"></a>创建AJAX核心对象</h3><p>想要使用AJAX技术必然逃不掉AJAX引擎，其实说起引擎可能觉得这个概念有点过于庞大，其实在AJAX中，这个引擎不过就是一个对象！对，你没有看错，只是一个对象而已！这个对象就是XMLHttpRequest。 XMLHttpRequest（简称XHR）是一个JavaScript对象。这个对象产生于浏览器中，它是AJAX的核心。 在不同的浏览器中创建这个对象的方法不同，其实主要的原因当然来自万恶的IE，没办法，毕竟IE拥有着庞大的用户群，我们在开发过程中不得不考虑兼容性问题。 那么为了解决兼容性问题，通常创建XHR对象的代码如下：</p>
<p>function ajaxFunction()<br> {<br> var xmlHttp;</p>
<p> try<br>    {<br>   // Firefox, Opera 8.0+, Safari,IE7及以上版本<br>    xmlHttp=new XMLHttpRequest();<br>    }<br> catch (e)<br>    {<br>  // Internet Explorer<br>   try<br>      {<br>      xmlHttp=new ActiveXObject(“Msxml2.XMLHTTP”);//IE较新版本<br>      }<br>   catch (e)<br>      {</p>
<pre><code>  try
     {
     xmlHttp=new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);//IE较老版本
     }
  catch (e)
     {
     alert(&quot;您的浏览器不支持AJAX！&quot;);
     return false;
     }
  }
}</code></pre><p> }</p>
<p>注意不要被这些花括号迷住了眼睛，下面分别介绍每一步: 增加try/catch块：</p>
<ul>
<li>尝试创建 XMLHttpRequest 对象</li>
<li>如果失败,先尝试使用较新版本的Microsoft浏览器创建 Microsoft 兼容的对象（Msxml2.XMLHTTP），如果失败（尝试使用较老版本的Microsoft浏览器创建 Microsoft兼容的对象（Microsoft.XMLHTTP）</li>
</ul>
<p>如果全部失败，则使用JavaScript警告通知用户出现了问题并返回false。</p>
<h3 id="XMLHttpRequest常用方法及属性"><a href="#XMLHttpRequest常用方法及属性" class="headerlink" title="XMLHttpRequest常用方法及属性"></a>XMLHttpRequest常用方法及属性</h3><h4 id="onreadystatechange-属性"><a href="#onreadystatechange-属性" class="headerlink" title="onreadystatechange 属性"></a>onreadystatechange 属性</h4><p>该属性存有处理服务器响应的函数。下面的代码定义了一个空的函数并赋值给onreadystatechange属性：</p>
<p>xmlHttp.onreadystatechange=function()<br>  {<br>  // 我们需要在这里写一些代码<br>  }</p>
<h4 id="readyState属性"><a href="#readyState属性" class="headerlink" title="readyState属性"></a>readyState属性</h4><p>readyState 属性存有服务器响应的状态信息。每当 readyState 改变时，onreadystatechange 函数就会被执行。 这是 readyState 属性可能的值： AJAX - XMLHttpRequest 对象</p>
<p>状态</p>
<p>描述</p>
<p>0</p>
<p>请求未初始化（在调用 open() 之前）</p>
<p>1</p>
<p>请求已提出（调用 send() 之前）</p>
<p>2</p>
<p>请求已发送（这里通常可以从响应得到内容头部）</p>
<p>3</p>
<p>请求处理中（响应中通常有部分数据可用，但是服务器还没有完成响应）</p>
<p>4</p>
<p>请求已完成（可以访问服务器响应并使用它）</p>
<p>我们要向这个 onreadystatechange 函数添加一条 If 语句，来测试我们的响应是否已完成（意味着可获得数据）：</p>
<p>xmlHttp.onreadystatechange=function()<br>  {<br>  if(xmlHttp.readyState==4)<br>    {<br>    // 从服务器的response获得数据<br>    }<br>  }</p>
<h4 id="responseText-属性"><a href="#responseText-属性" class="headerlink" title="responseText 属性"></a>responseText 属性</h4><p>可以通过 responseText 属性来取回由服务器返回的数据。</p>
<p>xmlHttp.onreadystatechange=function()<br>  {<br>  if(xmlHttp.readyState==4)<br>    {<br>    //例如将某一元素内的HTML代码更换为服务器发送的响应字符串<br>    document.getElementById(“某一元素id”).innerHTML = xmlHttp.responseText</code>;<br>    }<br>  }</p>
<h4 id="open-函数"><a href="#open-函数" class="headerlink" title="open()函数"></a>open()函数</h4><p>使用 XMLHttpRequest 对象的 open() 方法来建立请求。该方法有五个参数：</p>
<ul>
<li>request-type：发送请求的类型。典型的值是 GET 或 POST，但也可以发送 HEAD 请求</li>
<li>url：要连接的 URL</li>
<li>asynch：如果希望使用异步连接则为 true，否则为 false。该参数是可选的，默认为 true</li>
<li>username：如果需要身份验证，则可以在此指定用户名。该可选参数没有默认值</li>
<li>password：如果需要身份验证，则可以在此指定口令。该可选参数没有默认值</li>
</ul>
<p>通常使用其中的前三个参数。事实上，即使需要异步连接，通常指定第三个参数为 “true”，这样更容易理解。</p>
<h4 id="send-函数"><a href="#send-函数" class="headerlink" title="send()函数"></a>send()函数</h4><p>一旦请求用 open() 配置好之后，就可以使用send()方法发送请求了，send() 方法只有一个参数，就是要发送的内容。通常在open()方法中已经通过url设置好了参数内容，因此一般send方法中的参数传入null即可。 open()和send()函数的具体使用方法将通过后文中的一个简单实例来进行说明。</p>
<h3 id="实例：通过邮编自动获取城市名称"><a href="#实例：通过邮编自动获取城市名称" class="headerlink" title="实例：通过邮编自动获取城市名称"></a>实例：通过邮编自动获取城市名称</h3><h4 id="前端页面"><a href="#前端页面" class="headerlink" title="前端页面"></a>前端页面</h4><p>网页内容如下图所示： <img data-src="https://cdn.javacodes.cn/files/2016/07/2016-07-22_16-49-19.png" alt="ajax实例页面展示"> 当用户在邮编文本框中输入邮编时，则城市文本框内容自动改变为对应城市，我们知道，在传统web应用程序中如果要更新网站内容必须重新加载页面，而本实例要求只是更改城市文本框的内容，因此AJAX的异步处理方式最适合本实例的要求。 首先我们先准备一个HTML表单页面，代码如下：</p>
<!DOCTYPE html>
<html>
<head>
<title>AJAX实例-通过邮政编码获取城市名称</title>
<meta charset="UTF-8"/>
<meta name="content-type" content="text/html; charset=UTF-8">
<script type="text/javascript">
</script>
<link rel="alternate" href="/atom.xml" title="ByteLife" type="application/atom+xml">
</head>
<body>
    邮编：
    <input type="text" id="text_zipcode" name="zipcode" />
    <br /> <br />
    城市：
    <input type="text" id="text_city" name="city" />
</body>
</html>

<p>这个页面很简单，body中只有两个input文本框标签。</p>
<h4 id="AJAX代码"><a href="#AJAX代码" class="headerlink" title="AJAX代码"></a>AJAX代码</h4><p>下面我们来编写AJAX代码，通常实现一个AJAX功能需要四个简单的步骤：</p>
<ol>
<li>创建XMLHttpRequest对象；</li>
<li>通过open()函数建立连接；</li>
<li>设置onreadystatechange属性并编写回调（callback）函数；</li>
<li>发送请求send(null)；</li>
</ol>
<p>那么我们按照上面的几个步骤逐步实现： 首先我们需要创建XHR对象，该步骤上文已经详细介绍，在此不在赘述； 然后通过open()函数建立连接：open()函数在上文中我们已经知道其可以传入5个参数，但实际开发中通常只需要传入三个参数即可，分别是：</p>
<ul>
<li>request-type：请求类型。通常有get和post两种，在本例中由于我们只需要传递一个参数，且该参数无需加密，因此我们采用get方式即可，get与post请求方式的区别请自行查阅相关资料；</li>
<li>url：请求链接地址及参数；</li>
<li>asynch：连接方式，分为异步连接和同步连接。当值为true时为异步连接，当false时为同步连接，默认值为true。通常我们使用异步连接方式。</li>
</ul>
<p>那么在本例中，open函数的代码书写如下：</p>
<p>xhr.open(“get”, “zipcode.do?zipcode=”+$(“text_zipcode”).value, true);</p>
<p>在代码中，我们使用get方式建立与zipcode.do建立连接并传递zipcode参数。 接下来我们需要书写回调函数并赋值给onreadystatechanged属性，这个回调函数的意义是当ajax的readyState属性发生改变时所执行的函数，通常在这个函数中我们只关心服务器处理完成ajax的请求后并返回响应时我们需要做的操作，因此我们需要在这个函数中加入一个if判断，判断是否readyState是否为4，代码如下：</p>
<p>xhr.onreadystatechange = function(){<br>    // 判断ajax状态码（4为成功接受服务端响应）<br>    if (xhr.readyState == 4) {<br>        // 判断响应状态码（200即正确响应）<br>        if (xhr.status == 200) {<br>            // 更新页面部分内容<br>            $(“text_city”).value = xhr.responseText;<br>        }<br>    }<br>}</p>
<p>最后我们书写发送请求代码：send(null)； 那么根据上面的步骤，我们已经实现好了ajax的全部代码，整合起来代码如下：</p>
<!DOCTYPE html>
<html>
<head>
<title>AJAX实例-通过邮政编码获取城市名称</title>
<meta charset="UTF-8" />
<meta name="content-type" content="text/html; charset=UTF-8">
<script type="text/javascript">
    window.onload = function() {
        $("text_zipcode").onkeyup = function() {
            // 1、获取XHR对象
            var xhr = createXHR();
            // 判断是否成功获取XHR对象
            if (xhr != false) {
                // 2、建立连接
                xhr.open("get", "zipcode.do?zipcode="+$("text_zipcode").value, true);
                // 3、设置回调函数
                xhr.onreadystatechange = function(){
                    // 判断ajax状态码（4为成功接受服务端响应）
                    if (xhr.readyState == 4) {    
                        // 判断响应状态码（200即正确响应）
                        if (xhr.status == 200) {
                            // 更新页面部分内容
                            $("text_city").value = xhr.responseText;
                        }
                    }
                }
                // 4、发送请求
                xhr.send(null);
            }
        };
    };

<pre><code>function createXHR() {
    var xmlHttp = false;
    try {
        // Firefox, Opera 8.0+, Safari,IE7及以上版本
        xmlHttp = new XMLHttpRequest();
    } catch (e) {
        // Internet Explorer
        try {
            xmlHttp = new ActiveXObject(&quot;Msxml2.XMLHTTP&quot;);//IE较新版本
        } catch (e) {

            try {
                xmlHttp = new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);//IE较老版本
            } catch (e) {
                alert(&quot;您的浏览器不支持AJAX！&quot;);
                xmlHttp = false;
            }
        }
    }
    return xmlHttp;
}

function $(id) {
    return document.getElementById(id);
};</code></pre><p></script></p>
</head>
<body>
    邮编：
    <input type="text" id="text_zipcode" name="zipcode" />
    <br />    <br /> 
    城市：
    <input type="text" id="text_city" name="city" />
</body>
</html>



<h4 id="后端代码"><a href="#后端代码" class="headerlink" title="后端代码"></a>后端代码</h4><p>现在我们已经写好整个前端页面并实现ajax，我们来看一下后端代码示例，由于本篇文章主要介绍AJAX，因此后端实现方法不做过多解释，实现语言为Java，代码如下：</p>
<p>package cn.javacodes.servlet;</p>
<p>import java.io.IOException;<br>import java.io.PrintWriter;<br>import java.util.HashMap;<br>import java.util.Map;</p>
<p>import javax.servlet.ServletException;<br>import javax.servlet.http.HttpServlet;<br>import javax.servlet.http.HttpServletRequest;<br>import javax.servlet.http.HttpServletResponse;</p>
<p>public class ZipcodeServlet extends HttpServlet {</p>
<pre><code>private static final long serialVersionUID = 1L;

private Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();

public void init() {
    map.put(&quot;150000&quot;, &quot;哈尔滨&quot;);
    map.put(&quot;110000&quot;, &quot;北京&quot;);
}

public void doGet(HttpServletRequest request, HttpServletResponse response)
        throws ServletException, IOException {

    response.setContentType(&quot;text/html&quot;);
    response.setCharacterEncoding(&quot;UTF-8&quot;);
    PrintWriter out = response.getWriter();
    String zipcode = request.getParameter(&quot;zipcode&quot;);
    if (map.containsKey(zipcode)) {
        out.println(map.get(zipcode));
    }
    out.flush();
    out.close();

}

public void doPost(HttpServletRequest request, HttpServletResponse response)
        throws ServletException, IOException {

    doGet(request, response);
}</code></pre><p>}</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Ajax应用的开发确实有些繁琐，实际上，现在有很多成熟稳定的Ajax工具葙（例如JQuery）封装了以上诸多细节，使得Ajax编程更加容易。但是如果不知道应用程序在做什么，就很难发现其中的问题。XMLHttpRequest对象是Ajax应用的核心，必须非常熟悉。 Ajax应用的基本流程：</p>
<ul>
<li>创建XMLHttpRequest对象</li>
<li>从Web表单中获取需要的数据</li>
<li>设置要连接的URL</li>
<li>建立到服务器的连接</li>
<li>设置服务器在完成后要运行的回调函数</li>
<li>发送请求</li>
</ul>
<p>至于如何使用AJAX操作XML、JSON等，我会在以后的文章中在做讨论。</p>
]]></content>
      <categories>
        <category>JAVA</category>
        <category>Web前端</category>
      </categories>
      <tags>
        <tag>AJAX</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>ConcurrentLinkedQueue的实现原理分析</title>
    <url>/2017/03/15/ConcurrentLinkedQueue%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>在并发编程中我们有时候需要使用线程安全的队列。如果我们要实现一个线程安全的队列有两种实现方式：一种是使用阻塞算法，另一种是使用非阻塞算法。使用阻塞算法的队列可以用一个锁（入队和出队用同一把锁）或两个锁（入队和出队用不同的锁）等方式来实现，而非阻塞的实现方式则可以使用循环CAS的方式来实现，本文让我们一起来研究下Doug Lea是如何使用非阻塞的方式来实现线程安全队列ConcurrentLinkedQueue的，相信从大师身上我们能学到不少并发编程的技巧。</p>
<a id="more"></a>

<h2 id="ConcurrentLinkedQueue的介绍"><a href="#ConcurrentLinkedQueue的介绍" class="headerlink" title="ConcurrentLinkedQueue的介绍"></a>ConcurrentLinkedQueue的介绍</h2><p>ConcurrentLinkedQueue是一个基于链接节点的无界线程安全队列，它采用先进先出的规则对节点进行排序，当我们添加一个元素的时候，它会添加到队列的尾部，当我们获取一个元素时，它会返回队列头部的元素。它采用了“wait－free”算法来实现，该算法在Michael &amp; Scott算法上进行了一些修改, Michael &amp; Scott算法的详细信息可以参见参考资料一。</p>
<h2 id="ConcurrentLinkedQueue的结构"><a href="#ConcurrentLinkedQueue的结构" class="headerlink" title="ConcurrentLinkedQueue的结构"></a>ConcurrentLinkedQueue的结构</h2><p>我们通过ConcurrentLinkedQueue的类图来分析一下它的结构。 <img data-src="https://cdn.javacodes.cn/files/2017/03/2017-03-14_17-06-25.jpg" alt="">￼ （图1） ConcurrentLinkedQueue由head节点和tair节点组成，每个节点（Node）由节点元素（item）和指向下一个节点的引用(next)组成，节点与节点之间就是通过这个next关联起来，从而组成一张链表结构的队列。默认情况下head节点存储的元素为空，tair节点等于head节点。</p>
<pre><code>private transient volatile Node&lt;E&gt; tail = head;</code></pre><h2 id="入队列"><a href="#入队列" class="headerlink" title="入队列"></a>入队列</h2><p>入队列就是将入队节点添加到队列的尾部。为了方便理解入队时队列的变化，以及head节点和tair节点的变化，每添加一个节点我就做了一个队列的快照图。 <img data-src="https://cdn.javacodes.cn/files/2017/03/2017-03-14_17-06-26-1.jpg" alt="">￼ （图二）</p>
<ul>
<li>第一步添加元素1。队列更新head节点的next节点为元素1节点。又因为tail节点默认情况下等于head节点，所以它们的next节点都指向元素1节点。</li>
<li>第二步添加元素2。队列首先设置元素1节点的next节点为元素2节点，然后更新tail节点指向元素2节点。</li>
<li>第三步添加元素3，设置tail节点的next节点为元素3节点。</li>
<li>第四步添加元素4，设置元素3的next节点为元素4节点，然后将tail节点指向元素4节点。</li>
</ul>
<p>通过debug入队过程并观察head节点和tail节点的变化，发现入队主要做两件事情，第一是将入队节点设置成当前队列尾节点的下一个节点。第二是更新tail节点，如果tail节点的next节点不为空，则将入队节点设置成tail节点，如果tail节点的next节点为空，则将入队节点设置成tail的next节点，所以tail节点不总是尾节点，理解这一点对于我们研究源码会非常有帮助。 上面的分析让我们从单线程入队的角度来理解入队过程，但是多个线程同时进行入队情况就变得更加复杂，因为可能会出现其他线程插队的情况。如果有一个线程正在入队，那么它必须先获取尾节点，然后设置尾节点的下一个节点为入队节点，但这时可能有另外一个线程插队了，那么队列的尾节点就会发生变化，这时当前线程要暂停入队操作，然后重新获取尾节点。让我们再通过源码来详细分析下它是如何使用CAS算法来入队的。</p>
<pre><code>public boolean offer(E e) {
    if (e == null) throw new NullPointerException();
    //入队前，创建一个入队节点
    Node&lt;E&gt; n = new Node&lt;E&gt;(e);
    retry:
    //死循环，入队不成功反复入队。
    for (;;) {
        //创建一个指向tail节点的引用
        Node&lt;E&gt; t = tail;
        //p用来表示队列的尾节点，默认情况下等于tail节点。
        Node&lt;E&gt; p = t;
        for (int hops = 0; ; hops++) {
        //获得p节点的下一个节点。
            Node&lt;E&gt; next = succ(p);
        //next节点不为空，说明p不是尾节点，需要更新p后在将它指向next节点
            if (next != null) {
               //循环了两次及其以上，并且当前节点还是不等于尾节点
                if (hops &gt; HOPS &amp;&amp; t != tail)
                    continue retry; 
                p = next;
            } 
            //如果p是尾节点，则设置p节点的next节点为入队节点。
            else if (p.casNext(null, n)) {
              //如果tail节点有大于等于1个next节点，则将入队节点设置成tair节点，更新失败了也
没关系，因为失败了表示有其他线程成功更新了tair节点。
                if (hops &gt;= HOPS)
                    casTail(t, n); // 更新tail节点，允许失败
                return true;  
            } 
           // p有next节点,表示p的next节点是尾节点，则重新设置p节点
            else {
                p = succ(p);
            }
        }
    }
}</code></pre><p><strong>从源代码角度来看整个入队过程主要做二件事情</strong>。第一是定位出尾节点，第二是使用CAS算法能将入队节点设置成尾节点的next节点，如不成功则重试。 <strong>第一步定位尾节点</strong>。tail节点并不总是尾节点，所以每次入队都必须先通过tail节点来找到尾节点，尾节点可能就是tail节点，也可能是tail节点的next节点。代码中循环体中的第一个if就是判断tail是否有next节点，有则表示next节点可能是尾节点。获取tail节点的next节点需要注意的是p节点等于p的next节点的情况，只有一种可能就是p节点和p的next节点都等于空，表示这个队列刚初始化，正准备添加第一次节点，所以需要返回head节点。获取p节点的next节点代码如下</p>
<pre><code>final Node&lt;E&gt; succ(Node&lt;E&gt; p) {
         Node&lt;E&gt; next = p.getNext();
         return (p == next) ? head : next;
     }</code></pre><p><strong>第二步设置入队节点为尾节点</strong>。p.casNext(null, n)方法用于将入队节点设置为当前队列尾节点的next节点，p如果是null表示p是当前队列的尾节点，如果不为null表示有其他线程更新了尾节点，则需要重新获取当前队列的尾节点。 <strong>hops的设计意图</strong>。上面分析过对于先进先出的队列入队所要做的事情就是将入队节点设置成尾节点，doug lea写的代码和逻辑还是稍微有点复杂。那么我用以下方式来实现行不行？</p>
<pre><code>public boolean offer(E e) {
        if (e == null)
            throw new NullPointerException();
        Node&lt;E&gt; n = new Node&lt;E&gt;(e);
        for (;;) {
            Node&lt;E&gt; t = tail;
            if (t.casNext(null, n) &amp;&amp; casTail(t, n)) {
                return true;
            }
        }
    }</code></pre><p>让tail节点永远作为队列的尾节点，这样实现代码量非常少，而且逻辑非常清楚和易懂。但是这么做有个缺点就是每次都需要使用循环CAS更新tail节点。如果能减少CAS更新tail节点的次数，就能提高入队的效率，所以doug lea使用hops变量来控制并减少tail节点的更新频率，并不是每次节点入队后都将 tail节点更新成尾节点，而是当 tail节点和尾节点的距离大于等于常量HOPS的值（默认等于1）时才更新tail节点，tail和尾节点的距离越长使用CAS更新tail节点的次数就会越少，但是距离越长带来的负面效果就是每次入队时定位尾节点的时间就越长，因为循环体需要多循环一次来定位出尾节点，但是这样仍然能提高入队的效率，因为从本质上来看它通过增加对volatile变量的读操作来减少了对volatile变量的写操作，而对volatile变量的写操作开销要远远大于读操作，所以入队效率会有所提升。</p>
<pre><code>private static final int HOPS = 1;</code></pre><p>还有一点需要注意的是入队方法永远返回true，所以不要通过返回值判断入队是否成功。</p>
<h2 id="出队列"><a href="#出队列" class="headerlink" title="出队列"></a>出队列</h2><p>出队列的就是从队列里返回一个节点元素，并清空该节点对元素的引用。让我们通过每个节点出队的快照来观察下head节点的变化。 <img data-src="https://cdn.javacodes.cn/files/2017/03/2017-03-14_17-06-26.jpg" alt="">￼ 从上图可知，并不是每次出队时都更新head节点，当head节点里有元素时，直接弹出head节点里的元素，而不会更新head节点。只有当head节点里没有元素时，出队操作才会更新head节点。这种做法也是通过hops变量来减少使用CAS更新head节点的消耗，从而提高出队效率。让我们再通过源码来深入分析下出队过程。</p>
<pre><code>public E poll() {
    Node&lt;E&gt; h = head;
   // p表示头节点，需要出队的节点
    Node&lt;E&gt; p = h;
    for (int hops = 0;; hops++) {
        // 获取p节点的元素
        E item = p.getItem();
        // 如果p节点的元素不为空，使用CAS设置p节点引用的元素为null,如果成功则返回p节点的元素。
        if (item != null &amp;&amp; p.casItem(item, null)) {
            if (hops &gt;= HOPS) {
                //将p节点下一个节点设置成head节点
                Node&lt;E&gt; q = p.getNext();
                updateHead(h, (q != null) ? q : p);
            }
            return item;
        }
        // 如果头节点的元素为空或头节点发生了变化，这说明头节点已经被另外一个线程修改了。那么获取p节点的下一个节点 
        Node&lt;&gt; next = succ(p);
        // 如果p的下一个节点也为空，说明这个队列已经空了
        if (next == null) {
          // 更新头节点。
            updateHead(h, p);
            break;
        }
        // 如果下一个元素不为空，则将头节点的下一个节点设置成头节点
        p = next;
    }
    return null;
}</code></pre><p>首先获取头节点的元素，然后判断头节点元素是否为空，如果为空，表示另外一个线程已经进行了一次出队操作将该节点的元素取走，如果不为空，则使用CAS的方式将头节点的引用设置成null，如果CAS成功，则直接返回头节点的元素，如果不成功，表示另外一个线程已经进行了一次出队操作更新了head节点，导致元素发生了变化，需要重新获取头节点。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol>
<li>简单，快速和实用的阻塞和非阻塞并发队列算法。</li>
<li>非阻塞算法在容器里的实现。</li>
<li>JDK1.6中ConcurrentLinkedQueue源码和注释。</li>
</ol>
<blockquote>
<p>转载自<a href="http://ifeve.com/" target="_blank" rel="noopener">并发编程网 – ifeve.com</a> 本文链接地址: <a href="http://ifeve.com/concurrentlinkedqueue/" target="_blank" rel="noopener">聊聊并发（六）ConcurrentLinkedQueue的实现原理分析</a></p>
</blockquote>
]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>ConcurrentLinkedQueue</tag>
        <tag>Java</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title>Fedora24（Linux）Nvidia双显卡驱动解决方案（Bumblebee）</title>
    <url>/2016/09/13/Fedora24%EF%BC%88Linux%EF%BC%89Nvidia%E5%8F%8C%E6%98%BE%E5%8D%A1%E9%A9%B1%E5%8A%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%EF%BC%88Bumblebee%EF%BC%89/</url>
    <content><![CDATA[<p>现在的笔记本显卡多为Intel核心显卡+Nvidia显卡的组合模式，如果没能正确的管理Linux操作系统的双显卡驱动，可能会导致发热和性能差的问题。由于我们在Linux中极少运行对显卡要求特别高的3D程序，因此并不需要一直开启Nvidia独立显卡，只在需要它的时候再开启就好，Bumblebee提供了一个很棒的解决方案。 本文以Fedora24为例：</p>
<h3 id="一、确认硬件环境"><a href="#一、确认硬件环境" class="headerlink" title="一、确认硬件环境"></a>一、确认硬件环境</h3><p>当然，首先你得确定你的电脑确实是Intel+Nvidia的双显卡组合模式（optimus），查看方法很简单，只需要一条命令：</p>
<p>lspci | egrep ‘VGA|3D’</p>
<a id="more"></a>

<p>如果你的电脑是双显卡，将会输出类似如下的信息： <img data-src="https://cdn.javacodes.cn/files/2016/09/2016-09-13_03-31-45.png" alt="2016-09-13 11-31-27屏幕截图"></p>
<h3 id="二、禁用Nouveau"><a href="#二、禁用Nouveau" class="headerlink" title="二、禁用Nouveau"></a>二、禁用Nouveau</h3><p>Nouveau是一个大多数Linux发行版都会自带的Nvidia第三方驱动程序，不过Nouveau只支持2D，不支持3D，可想而知其性能有多差。安装Bumblebee之前必须禁用Nouveau，否则会出现问题，方法如下： 运行命令：</p>
<p>sudo gedit /etc/modprobe.d/blacklist.conf</p>
<p>在打开的窗口中加上如下内容：</p>
<blockquote>
<p>blacklist nouveau options nouveau modeset=0</p>
</blockquote>
<p>保存并重新启动操作系统。</p>
<h3 id="三、安装Bumblebee"><a href="#三、安装Bumblebee" class="headerlink" title="三、安装Bumblebee"></a>三、安装Bumblebee</h3><p>不同版本的Fedora稍有不同 开源驱动（Nouveau）命令如下（如果安装此版本，则无需执行上面的第二步）： <strong>fedora 22:</strong></p>
<p># dnf -y –nogpgcheck install <a href="http://install.linux.ncsu.edu/pub/yum/itecs/public/bumblebee/fedora22/noarch/bumblebee-release-1.2-1.noarch.rpm" target="_blank" rel="noopener">http://install.linux.ncsu.edu/pub/yum/itecs/public/bumblebee/fedora22/noarch/bumblebee-release-1.2-1.noarch.rpm</a></p>
<p><strong>fedora 23:</strong></p>
<p># dnf -y –nogpgcheck install <a href="http://install.linux.ncsu.edu/pub/yum/itecs/public/bumblebee/fedora23/noarch/bumblebee-release-1.2-1.noarch.rpm" target="_blank" rel="noopener">http://install.linux.ncsu.edu/pub/yum/itecs/public/bumblebee/fedora23/noarch/bumblebee-release-1.2-1.noarch.rpm</a></p>
<p><strong>fedora 24:</strong></p>
<p># dnf -y –nogpgcheck install <a href="http://install.linux.ncsu.edu/pub/yum/itecs/public/bumblebee/fedora24/noarch/bumblebee-release-1.2-1.noarch.rpm" target="_blank" rel="noopener">http://install.linux.ncsu.edu/pub/yum/itecs/public/bumblebee/fedora24/noarch/bumblebee-release-1.2-1.noarch.rpm</a></p>
<p>闭源驱动（Nvidia）命令如下：（推荐） <strong>fedora 22:</strong></p>
<p># dnf -y –nogpgcheck install <a href="http://install.linux.ncsu.edu/pub/yum/itecs/public/bumblebee-nonfree/fedora22/noarch/bumblebee-nonfree-release-1.2-1.noarch.rpm" target="_blank" rel="noopener">http://install.linux.ncsu.edu/pub/yum/itecs/public/bumblebee-nonfree/fedora22/noarch/bumblebee-nonfree-release-1.2-1.noarch.rpm</a></p>
<p><strong>fedora 23:</strong></p>
<p># dnf -y –nogpgcheck install <a href="http://install.linux.ncsu.edu/pub/yum/itecs/public/bumblebee-nonfree/fedora23/noarch/bumblebee-nonfree-release-1.2-1.noarch.rpm" target="_blank" rel="noopener">http://install.linux.ncsu.edu/pub/yum/itecs/public/bumblebee-nonfree/fedora23/noarch/bumblebee-nonfree-release-1.2-1.noarch.rpm</a></p>
<p><strong>fedora 24:</strong></p>
<p># dnf -y –nogpgcheck install <a href="http://install.linux.ncsu.edu/pub/yum/itecs/public/bumblebee-nonfree/fedora24/noarch/bumblebee-nonfree-release-1.2-1.noarch.rpm" target="_blank" rel="noopener">http://install.linux.ncsu.edu/pub/yum/itecs/public/bumblebee-nonfree/fedora24/noarch/bumblebee-nonfree-release-1.2-1.noarch.rpm</a></p>
<h3 id="四、安装Bumblebee-nvidia"><a href="#四、安装Bumblebee-nvidia" class="headerlink" title="四、安装Bumblebee-nvidia"></a>四、安装Bumblebee-nvidia</h3><p>接下来执行（根据系统选择）： 1、32位系统：</p>
<p># dnf install bumblebee-nvidia bbswitch-dkms primus kernel-devel</p>
<p>2、64位系统：</p>
<p># dnf install bumblebee-nvidia bbswitch-dkms VirtualGL.x86_64 VirtualGL.i686 primus.x86_64 primus.i686 kernel-devel</p>
<p>耐心的等待下载并安装完成，重新启动操作系统。</p>
<h3 id="五、检查是否成功"><a href="#五、检查是否成功" class="headerlink" title="五、检查是否成功"></a>五、检查是否成功</h3><p>1、运行如下命令再次查看显卡pci信息：</p>
<p>lspci | egrep ‘VGA|3D’</p>
<p>检查nvidia显卡信息后面是否是(rev ff)，如果是，则证明Bumblebee已经运行； 2、运行如下命令比较帧数： 首先运行：</p>
<p>glxgears</p>
<p>查看终端中输出的FPS数值，此处的数值为使用核心显卡时的数值： <img data-src="https://cdn.javacodes.cn/files/2016/09/2016-09-13_03-53-59.png" alt="2016-09-13 11-53-42屏幕截图"> 运行：</p>
<p>optirun glxgears</p>
<p>查看终端FPS信息，此时如果能够正常运行，则为Nvidia显卡在工作： <img data-src="https://cdn.javacodes.cn/files/2016/09/2016-09-13_03-57-34.png" alt="2016-09-13 11-56-31屏幕截图"> 明显看出FPS从60飙升到2000，证明NVIDIA生效；</p>
<h3 id="六、使用Bumblebee软件"><a href="#六、使用Bumblebee软件" class="headerlink" title="六、使用Bumblebee软件"></a>六、使用Bumblebee软件</h3><p>常规用法：</p>
<p>$ optirun [options] application [application-parameters]</p>
<p>下面举几个例子： 1、使用独立显卡运行Windows（通过Wine）应用程序：</p>
<p>$ optirun wine application.exe</p>
<p>我就是用这种方式来运行魔兽世界的，虽然不总玩，哈哈，谁说Linux不可以玩游戏！ 2、打开nvidia显卡设置</p>
<p>$ optirun -b none nvidia-settings -c :8</p>
<p>3、使用独立显卡运行Java程序</p>
<p>$ optirun -b primus java -jar /PATH/TO/Minecraft.jar</p>
]]></content>
      <categories>
        <category>Linux/服务器/网络</category>
      </categories>
      <tags>
        <tag>Fedora</tag>
        <tag>Fedora24</tag>
        <tag>Linux</tag>
        <tag>nvidia</tag>
        <tag>双显卡驱动</tag>
        <tag>驱动</tag>
      </tags>
  </entry>
  <entry>
    <title>HTTPS的7个误解</title>
    <url>/2016/07/05/HTTPS%E7%9A%847%E4%B8%AA%E8%AF%AF%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="误解七：HTTPS无法缓存"><a href="#误解七：HTTPS无法缓存" class="headerlink" title="误解七：HTTPS无法缓存"></a><strong>误解七：HTTPS无法缓存</strong></h3><p>许多人以为，出于安全考虑，浏览器不会在本地保存HTTPS缓存。实际上，只要在HTTP头中使用特定命令，HTTPS是可以缓存的。 微软的IE项目经理Eric Lawrence写道：</p>
<blockquote>
<p>“说来也许令人震惊，只要HTTP头允许这样做，所有版本的IE都缓存HTTPS内容。比如，如果头命令是Cache-Control: max-age=600，那么这个网页就将被IE缓存10分钟。IE的缓存策略，与是否使用HTTPS协议无关。（其他浏览器在这方面的行为不一致，取决于你使用的版本，所以这里不加以讨论。）”</p>
</blockquote>
<a id="more"></a>

<p>Firefox默认只在内存中缓存HTTPS。但是，只要头命令中有Cache-Control: Public，缓存就会被写到硬盘上。下面的图片显示，Firefox的硬盘缓存中有HTTPS内容，头命令正是Cache-Control:Public。 <img data-src="https://cdn.javacodes.cn/files/2016/07/2016-07-04_15-57-34.png" alt="">  </p>
<h3 id="误解六：SSL证书很贵"><a href="#误解六：SSL证书很贵" class="headerlink" title="误解六：SSL证书很贵"></a><strong>误解六：SSL证书很贵</strong></h3><p>如果你在网上搜一下，就会发现很多便宜的SSL证书，大概10美元一年，这和一个.com域名的年费差不多。而且事实上，还能找到免费的SSL证书。 在效力上，便宜的证书当然会比大机构颁发的证书差一点，但是几乎所有的主流浏览器都接受这些证书。  </p>
<h3 id="误解五：HTTPS站点必须有独享的IP地址"><a href="#误解五：HTTPS站点必须有独享的IP地址" class="headerlink" title="误解五：HTTPS站点必须有独享的IP地址"></a><strong>误解五：HTTPS站点必须有独享的IP地址</strong></h3><p>由于IPv4将要分配完毕，所以很多人关心这个问题。每个IP地址只能安装一张SSL证书，这是毫无疑问的。但是，如果你使用子域名通配符SSL证书（wildcard SSL certificate，价格大约是每年125美元），就能在一个IP地址上部署多个HTTPS子域名。比如，<a href="https://www.httpwatch.com和https://store.httpwatch.com，就共享同一个IP地址。" target="_blank" rel="noopener">https://www.httpwatch.com和https://store.httpwatch.com，就共享同一个IP地址。</a> <img data-src="https://cdn.javacodes.cn/files/2016/07/2016-07-04_15-57-40.png" alt=""> 另外，UCC（统一通信证书，Unified Communications Certificate）支持一张证书同时匹配多个站点，可以是完全不同的域名。SNI（服务器名称指示，Server Name Indication）允许一个IP地址上多个域名安装多张证书。服务器端，Apache和Nginx支持该技术，IIS不支持；客户端，IE 7+、Firefox 2.0+、Chrome 6+、Safari 2.1+和Opera 8.0+支持。  </p>
<h3 id="误解四：转移服务器时要购买新证书"><a href="#误解四：转移服务器时要购买新证书" class="headerlink" title="误解四：转移服务器时要购买新证书"></a><strong>误解四：转移服务器时要购买新证书</strong></h3><p>部署SSL证书，需要这样几步：</p>
<blockquote>
<p>　　1. 在你的服务器上，生成一个CSR文件（SSL证书请求文件，SSL Certificate Signing Request）。 2. 使用CSR文件，购买SSL证书。 3. 安装SSL证书。</p>
</blockquote>
<p>这些步骤都经过精心设计，保证传输的安全，防止有人截取或非法获得证书。结果就是，你在第二步得到的证书不能用在另一台服务器上。如果你需要这样做，就必须以其他格式输出证书。 比如，IIS的做法是生成一个可以转移的.pfx文件，并加以密码保护。 <img data-src="https://cdn.javacodes.cn/files/2016/07/2016-07-04_15-57-45.png" alt=""> 将这个文件传入其他服务器，将可以继续使用原来的SSL证书了。  </p>
<h3 id="误解三：HTTPS太慢"><a href="#误解三：HTTPS太慢" class="headerlink" title="误解三：HTTPS太慢"></a><strong>误解三：HTTPS太慢</strong></h3><p>使用HTTPS不会使你的网站变得更快（实际上有可能，请看下文），但是有一些技巧可以大大减少额外开销。 首先，只要压缩文本内容，就会降低解码耗用的CPU资源。不过，对于当代CPU来说，这点开销不值一提。 其次，建立HTTPS连接，要求额外的TCP往返，因此会新增一些发送和接收的字节。但是，从下图可以看到，新增的字节是很少的。 <img data-src="https://cdn.javacodes.cn/files/2016/07/2016-07-04_15-57-52.png" alt=""> 第一次打开网页的时候，HTTPS协议会比HTTP协议慢一点，这是因为读取和验证SSL证书的时间。下面是一张HTTP网页打开时间的瀑布图。 <img data-src="https://cdn.javacodes.cn/files/2016/07/2016-07-04_15-57-57.png" alt=""> 同一张网页使用HTTPS协议之后，打开时间变长了。 <img data-src="https://cdn.javacodes.cn/files/2016/07/2016-07-04_15-58-02.png" alt=""> 建立连接的部分，大约慢了10%。但是，一旦有效的HTTPS连接建立起来，再刷新网页，两种协议几乎没有区别。先是HTTP协议的刷新表现： <img data-src="https://cdn.javacodes.cn/files/2016/07/2016-07-04_15-58-06.png" alt=""> 然后是HTTPS协议： <img data-src="https://cdn.javacodes.cn/files/2016/07/2016-07-04_15-58-10.png" alt=""> 某些用户可能发现，HTTPS比HTTP更快一点。这会发生在一些大公司的内部局域网，因为通常情况下，公司的网关会截取并分析所有的网络通信。但是，当它遇到HTTPS连接时，它就只能直接放行，因为HTTPS无法被解读。正是因为少了这个解读的过程，所以HTTPS变得比较快。  </p>
<h3 id="误解二：有了HTTPS，Cookie和查询字符串就安全了"><a href="#误解二：有了HTTPS，Cookie和查询字符串就安全了" class="headerlink" title="误解二：有了HTTPS，Cookie和查询字符串就安全了"></a><strong>误解二：有了HTTPS，Cookie和查询字符串就安全了</strong></h3><p>虽然无法直接从HTTPS数据中读取Cookie和查询字符串，但是你仍然需要使它们的值变得难以预测。 比如，曾经有一家英国银行，直接使用顺序排列的数值表示session id: <img data-src="https://cdn.javacodes.cn/files/2016/07/2016-07-04_15-58-16.png" alt=""> 黑客可以先注册一个账户，找到这个cookie，看到这个值的表示方法。然后，改动cookie，从而劫持其他人的session id。至于查询字符串，也可以通过类似方式泄漏。  </p>
<h3 id="误解一：只有注册登录页，才需要HTTPS"><a href="#误解一：只有注册登录页，才需要HTTPS" class="headerlink" title="误解一：只有注册登录页，才需要HTTPS"></a><strong>误解一：只有注册登录页，才需要HTTPS</strong></h3><p>这种想法很普遍。人们觉得，HTTPS可以保护用户的密码，此外就不需要了。Firefox浏览器新插件Firesheep，证明了这种想法是错的。我们可以看到，在Twitter和Facebook上，劫持其他人的session是非常容易的。 咖啡馆的免费WiFi，就是一个很理想的劫持环境，因为两个原因：</p>
<blockquote>
<p>　　1. 这种WiFi通常不会加密，所以很容易监控所有流量。 2. WiFi通常使用NAT进行外网和内网的地址转换，所有内网客户端都共享一个外网地址。这意味着，被劫持的session，看上去很像来自原来的登录者。</p>
</blockquote>
<p>以Twitter为例，它的登录页使用了HTTPS，但是登录以后，其他页面就变成了HTTP。这时，它的cookie里的session值就暴露了。 <img data-src="https://cdn.javacodes.cn/files/2016/07/2016-07-04_15-58-23.png" alt=""> 也就是说，这些cookie是在HTTPS环境下建立的，但是却在HTTP环境下传输。如果有人劫持到这些cookie，那他就能以你的身份在Twitter上发言了。 （完）  </p>
<blockquote>
<p><strong>来自：阮一峰的网络日志</strong> <strong>译者：</strong>阮一峰<strong>** **链接：<a href="http://www.ruanyifeng.com/blog/2011/02/seven\_myths\_about_https.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2011/02/seven\_myths\_about_https.html</a></strong> <strong>原文：<a href="http://blog.httpwatch.com/2011/01/28/top-7-myths-about-https/" target="_blank" rel="noopener">http://blog.httpwatch.com/2011/01/28/top-7-myths-about-https/</a></strong></p>
</blockquote>
]]></content>
      <categories>
        <category>Linux/服务器/网络</category>
      </categories>
      <tags>
        <tag>HTTPS</tag>
        <tag>网络协议</tag>
      </tags>
  </entry>
  <entry>
    <title>HTTP常见状态码解释</title>
    <url>/2016/07/14/HTTP%E5%B8%B8%E8%A7%81%E7%8A%B6%E6%80%81%E7%A0%81%E8%A7%A3%E9%87%8A/</url>
    <content><![CDATA[<p>状态码的职责是当客户端向服务器端发送请求时，描述返回请求结果。借助状态码，用户可以知道服务器端是正常处理了请求，还是出现了什么错误。 RFC2616定义的状态码，由3位数字和原因短信组成。 数字中的第一位指定了响应类别，后两位无分类。响应类别有以下5种：</p>
<a id="more"></a>

<p>Type</p>
<p>Reason-phrase</p>
<p>Note</p>
<p>1XX</p>
<p>Informational</p>
<p>信息性状态码，表示接受的请求正在处理</p>
<p>2XX</p>
<p>Success</p>
<p>成功状态码，表示请求正常处理完毕</p>
<p>3XX</p>
<p>Redirection</p>
<p>重定向状态码，表示需要客户端需要进行附加操作</p>
<p>4XX</p>
<p>Client Error</p>
<p>客户端错误状态码，表示服务器无法处理请求</p>
<p>5XX</p>
<p>Server Error</p>
<p>服务器错误状态码，表示服务器处理请求出错</p>
<p>RFC2616记录的HTTP状态码有37种，再加上「WebDAV」(RFC4918、5842)和「Additional HTTP Status Codes」(RFC6585)，数量就达到60多种。 然并卵，这么多种HTTP状态码，其实常用的大概只有14种，本文就讲讲这14种状态码。</p>
<h2 id="2XX-Success"><a href="#2XX-Success" class="headerlink" title="2XX Success"></a>2XX Success</h2><blockquote>
<p>This class of status code indicates that the client’s request was successfully received, understood, and accepted.</p>
</blockquote>
<p>2xx 响应结果表示从客户端发来的请求在服务器端被正常处理了。</p>
<h3 id="200-OK"><a href="#200-OK" class="headerlink" title="200 OK"></a>200 OK</h3><p>请求被成功处理，服务器会根据不同的请求方法返回结果： <strong>GET</strong>：请求的对应资源会作为响应返回。 <strong>HEAD</strong>：请求的对应资源的响应头(entity-header)会作为响应返回,不包括响应体(message-body)。 <strong>POST</strong>：返回处理对应请求的结果。</p>
<h3 id="204-No-Content"><a href="#204-No-Content" class="headerlink" title="204 No Content"></a>204 No Content</h3><p>该状态码表示服务器接收到的请求已经处理完毕，但是服务器不需要返回响应体. 比如，客户端是浏览器的话，发出的请求返回204响应，那么浏览器显示的页面不会发生更新。</p>
<h3 id="206-Partial-Content"><a href="#206-Partial-Content" class="headerlink" title="206 Partial Content"></a>206 Partial Content</h3><p>该状态码表示客户端进行了范围请求，而服务器成功执行了这部分的GET请求。 客户端发起的请求，必须在请求头中包含<code>Range</code>字段。服务端响应报文中，必须包含由<code>Content-Range</code>指定范围的实体内容(entity-bodies )</p>
<h2 id="3XX-Redirection"><a href="#3XX-Redirection" class="headerlink" title="3XX Redirection"></a>3XX Redirection</h2><blockquote>
<p>This class of status code indicates that further action needs to be taken by the user agent in order to fulfill the request.</p>
</blockquote>
<p>3XX 响应结果表明浏览器需要执行某些特殊的处理以完成请求。</p>
<h3 id="301-Moved-Permanently"><a href="#301-Moved-Permanently" class="headerlink" title="301 Moved Permanently"></a>301 Moved Permanently</h3><p>永久性重定向。该状态码表示请求的资源已经被分配了新的URI，并且以后使用资源现在所指的URI。并且根据请求的方法有不同的处理方式： <strong>HEAD</strong>：必须在响应头部<code>Location</code>字段中指明新的永久性的URI。 <strong>GET</strong>：除了有<code>Location</code>字段以外，还需要在响应体中附上永久性URI的超链接文本。 <strong>POST</strong>：客户端在发送POST请求，受到301响应之后，不应该自动跳转URI，应当让用户确认跳转。 比如，如果一个URI已经在浏览器中被收藏为书签，这时应该按照<code>Location</code>首部字段提示的URI重新保存。 例如建立一个收藏的书签：</p>
<p>1</p>
<p><a href="https://cdn.javacodes.cn" target="_blank" rel="noopener">https://cdn.javacodes.cn</a></p>
<p>当访问这个书签的时候，请求会被重定向到</p>
<p>1</p>
<p><a href="https://cdn.javacodes.cn" target="_blank" rel="noopener">https://cdn.javacodes.cn</a></p>
<p>并且对应的书签会被改变，指向<a href="https://cdn.javacodes.cn" target="_blank" rel="noopener">https://cdn.javacodes.cn</a> 不信？Try yourself.</p>
<h3 id="302-Found"><a href="#302-Found" class="headerlink" title="302 Found"></a>302 Found</h3><p>临时性重定向。该状态码表示请求的资源已被分配了新的URI，希望用户本次能使用新的URI访问。 和301 Moved Permanently 状态码相似，但302状态码代表的资源不是被永久移动，只是临时性质的。 如果，用户把一个URI收藏为书签，302响应是不会像301那样去更新书签。</p>
<h3 id="303-See-Other"><a href="#303-See-Other" class="headerlink" title="303 See Other"></a>303 See Other</h3><p>该状态码表示由于请求对应的资源存在另一个URI，应使用GET方法定向获取请求的资源。303与302不同之处在于，302是不会改变请求的方法，如果请求方法是POST的话，重定向的请求也应该是POST。而对于303，使用POST请求的话，重定向的请求应该是GET请求。 但是有一点是需要注意的，许多HTTP/1.1版以前的浏览器不能正确理解303状态码，很多现存的浏览器讲302响应视为303响应，并且使用GET方式访问<code>Location</code>中规定的的URI，而无视原先请求的方法。 在RFC2616中有相关的这样一段原文：</p>
<blockquote>
<p>Note: Many pre-HTTP/1.1 user agents do not understand the 303 status. When interoperability with such clients is a concern, the 302 status code may be used instead, since most user agents react to a 302 response as described here for 303.</p>
</blockquote>
<h3 id="304-Not-Modified"><a href="#304-Not-Modified" class="headerlink" title="304 Not Modified"></a>304 Not Modified</h3><p>该状态码表示客户端发送附带条件请求时，服务器端允许请求访问资源，但未满足条件的情况。304状态码返回时，不包含任何响应的主题部分。附带条件的请求指的是采用GET方法的请求头中包含：<code>If-Match</code>、<code>If-Modified-Since</code>、<code>If-None-Match</code>、<code>If-Range</code>、<code>If-Unmodified-Since</code>中任一首部。</p>
<h3 id="307-Temporary-Redirect"><a href="#307-Temporary-Redirect" class="headerlink" title="307 Temporary Redirect"></a>307 Temporary Redirect</h3><p>临时重定向。该状态码与302和303的有着类似的含义，不同之处在于，307状态码并不会指定客户端要用什么样的请求方法请求重定向地址。(302指定使用原有请求方法，303指定使用GET方法)</p>
<h2 id="4XX-Client-Error"><a href="#4XX-Client-Error" class="headerlink" title="4XX Client Error"></a>4XX Client Error</h2><blockquote>
<p>The 4xx class of status code is intended for cases in which the client seems to have erred.</p>
</blockquote>
<p>4XX 的响应结果表明客户端是发生错误的原因所在</p>
<h3 id="400-Bad-Request"><a href="#400-Bad-Request" class="headerlink" title="400 Bad Request"></a>400 Bad Request</h3><p>表示该请求报文中存在语法错误，导致服务器无法理解该请求。客户端需要修改请求的内容后再次发送请求。</p>
<h3 id="401-Unauthorized"><a href="#401-Unauthorized" class="headerlink" title="401 Unauthorized"></a>401 Unauthorized</h3><p>该状态码表示发送的请求需要有通过HTTP认证(Basic认证，Digest认证)的认证信息。返回含有401的响应，必须在头部包含<code>WWW-Authenticate</code>以指明服务器需要哪种方式的认证。 当客户端再次请求该资源的时候，需要在请求头中的<code>Authorization</code>包含认证信息。 更多关于认证授权的信息关注RFC2617</p>
<h3 id="403-Forbidden"><a href="#403-Forbidden" class="headerlink" title="403 Forbidden"></a>403 Forbidden</h3><p>该状态码表明对请求资源的访问被服务器拒绝了。服务器没有必要给出拒绝的详细理由，但如果想做说明的话，可以在实体的主体部分原因进行描述，这样就能让用户看到了。 未获得文件系统的访问权限，访问权限出现某些问题，从未授权的发送源IP地址试图访问等情况都可能发生403响应。</p>
<h3 id="404-Not-Found"><a href="#404-Not-Found" class="headerlink" title="404 Not Found"></a>404 Not Found</h3><p>该状态码表明服务器上无法找到指定的资源。通常被用于服务器不想透露拒绝请求的原因，或者没有其他的响应可提供。</p>
<h2 id="5XX-Server-Error"><a href="#5XX-Server-Error" class="headerlink" title="5XX Server Error"></a>5XX Server Error</h2><blockquote>
<p>Response status codes beginning with the digit “5” indicate cases in which the server is aware that it has erred or is incapable of performing the request.</p>
</blockquote>
<p>5XX 的响应结果表明服务器本身发生错误，或者没有足够的能力来处理请求。</p>
<h3 id="500-Internal-Server-Error"><a href="#500-Internal-Server-Error" class="headerlink" title="500 Internal Server Error"></a>500 Internal Server Error</h3><p>该状态码表明服务器端在执行请求时发生了错误。也有可能是Web应用存在的BUG或某些临时的故障。</p>
<h3 id="503-Service-Unavailable"><a href="#503-Service-Unavailable" class="headerlink" title="503 Service Unavailable"></a>503 Service Unavailable</h3><p>该状态码表明服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。如果事先得知解除以上需要的时间，最好写入<code>Retry-After</code>首部字段再返回给客户端。</p>
<blockquote>
<p>转载自：<a href="http://huang-jerryc.com/2016/05/22/%E3%80%8C%E7%90%86%E8%A7%A3HTTP%E3%80%8D%E4%B9%8B%E5%B8%B8%E8%A7%81%E7%9A%84%E7%8A%B6%E6%80%81%E7%A0%81/" target="_blank" rel="noopener">点击进入</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Linux/服务器/网络</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
        <tag>状态码</tag>
      </tags>
  </entry>
  <entry>
    <title>HashMap多线程并发问题分析</title>
    <url>/2016/07/05/HashMap%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B9%B6%E5%8F%91%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h2 id="并发问题的症状"><a href="#并发问题的症状" class="headerlink" title="并发问题的症状"></a>并发问题的症状</h2><h3 id="多线程put后可能导致get死循环"><a href="#多线程put后可能导致get死循环" class="headerlink" title="多线程put后可能导致get死循环"></a>多线程put后可能导致get死循环</h3><p>从前我们的Java代码因为一些原因使用了HashMap这个东西，但是当时的程序是单线程的，一切都没有问题。后来，我们的程序性能有问题，所以需要变成多线程的，于是，变成多线程后到了线上，发现程序经常占了100%的CPU，查看堆栈，你会发现程序都Hang在了HashMap.get()这个方法上了，重启程序后问题消失。但是过段时间又会来。而且，这个问题在测试环境里可能很难重现。 </p>
<a id="more"></a>

<p>我们简单的看一下我们自己的代码，我们就知道HashMap被多个线程操作。而Java的文档说HashMap是非线程安全的，应该用ConcurrentHashMap。但是在这里我们可以来研究一下原因。简单代码如下：</p>
<p>package com.king.hashmap;</p>
<p>import java.util.HashMap;</p>
<p>public class TestLock {</p>
<pre><code>private HashMap map = new HashMap();

public TestLock() {
    Thread t1 = new Thread() {
        public void run() {
            for (int i = 0; i &lt; 50000; i++) {
                map.put(new Integer(i), i);
            }
            System.out.println(&quot;t1 over&quot;);
        }
    };

    Thread t2 = new Thread() {
        public void run() {
            for (int i = 0; i &lt; 50000; i++) {
                map.put(new Integer(i), i);
            }

            System.out.println(&quot;t2 over&quot;);
        }
    };

    Thread t3 = new Thread() {
        public void run() {
            for (int i = 0; i &lt; 50000; i++) {
                map.put(new Integer(i), i);
            }

            System.out.println(&quot;t3 over&quot;);
        }
    };

    Thread t4 = new Thread() {
        public void run() {
            for (int i = 0; i &lt; 50000; i++) {
                map.put(new Integer(i), i);
            }

            System.out.println(&quot;t4 over&quot;);
        }
    };

    Thread t5 = new Thread() {
        public void run() {
            for (int i = 0; i &lt; 50000; i++) {
                map.put(new Integer(i), i);
            }

            System.out.println(&quot;t5 over&quot;);
        }
    };

    Thread t6 = new Thread() {
        public void run() {
            for (int i = 0; i &lt; 50000; i++) {
                map.get(new Integer(i));
            }

            System.out.println(&quot;t6 over&quot;);
        }
    };

    Thread t7 = new Thread() {
        public void run() {
            for (int i = 0; i &lt; 50000; i++) {
                map.get(new Integer(i));
            }

            System.out.println(&quot;t7 over&quot;);
        }
    };

    Thread t8 = new Thread() {
        public void run() {
            for (int i = 0; i &lt; 50000; i++) {
                map.get(new Integer(i));
            }

            System.out.println(&quot;t8 over&quot;);
        }
    };

    Thread t9 = new Thread() {
        public void run() {
            for (int i = 0; i &lt; 50000; i++) {
                map.get(new Integer(i));
            }

            System.out.println(&quot;t9 over&quot;);
        }
    };

    Thread t10 = new Thread() {
        public void run() {
            for (int i = 0; i &lt; 50000; i++) {
                map.get(new Integer(i));
            }

            System.out.println(&quot;t10 over&quot;);
        }
    };

    t1.start();
    t2.start();
    t3.start();
    t4.start();
    t5.start();

    t6.start();
    t7.start();
    t8.start();
    t9.start();
    t10.start();
}

public static void main(String\[\] args) {
    new TestLock();
}</code></pre><p>}</p>
<p>就是启了10个线程，不断的往一个非线程安全的HashMap中put内容/get内容，put的内容很简单，key和value都是从0自增的整数（这个put的内容做的并不好，以致于后来干扰了我分析问题的思路）。对HashMap做并发写操作，我原以为只不过会产生脏数据的情况，但反复运行这个程序，会出现线程t1、t2被hang住的情况，多数情况下是一个线程被hang住另一个成功结束，偶尔会10个线程都被hang住。 产生这个死循环的根源在于对一个未保护的共享变量 — 一个”HashMap”数据结构的操作。当在所有操作的方法上加了”synchronized”后，一切恢复了正常。这算jvm的bug吗？应该说不是的，这个现象很早以前就报告出来了。Sun的工程师并不认为这是bug，而是建议在这样的场景下应采用”ConcurrentHashMap”， CPU利用率过高一般是因为出现了出现了死循环，导致部分线程一直运行，占用cpu时间。问题原因就是HashMap是非线程安全的，多个线程put的时候造成了某个key值Entry key List的死循环，问题就这么产生了。 当另外一个线程get 这个Entry List 死循环的key的时候，这个get也会一直执行。最后结果是越来越多的线程死循环，最后导致服务器dang掉。我们一般认为HashMap重复插入某个值的时候，会覆盖之前的值，这个没错。但是对于多线程访问的时候，由于其内部实现机制(在多线程环境且未作同步的情况下，对同一个HashMap做put操作可能导致两个或以上线程同时做rehash动作，就可能导致循环键表出现，一旦出现线程将无法终止，持续占用CPU，导致CPU使用率居高不下)，就可能出现安全问题了。 使用jstack工具dump出问题的那台服务器的栈信息。死循环的话，首先查找RUNNABLE的线程，找到问题代码如下：</p>
<blockquote>
<p>java.lang.Thread.State:RUNNABLE at java.util.HashMap.get(HashMap.java:303) at com.sohu.twap.service.logic.TransformTweeter.doTransformTweetT5(TransformTweeter.java:183) 共出现了23次。 java.lang.Thread.State:RUNNABLE at java.util.HashMap.put(HashMap.java:374) at com.sohu.twap.service.logic.TransformTweeter.transformT5(TransformTweeter.java:816) 共出现了3次。</p>
</blockquote>
<p><strong>注意</strong>：不合理使用HashMap导致出现的是死循环而不是死锁。</p>
<h3 id="多线程put的时候可能导致元素丢失"><a href="#多线程put的时候可能导致元素丢失" class="headerlink" title="多线程put的时候可能导致元素丢失"></a>多线程put的时候可能导致元素丢失</h3><p>主要问题出在addEntry方法的new Entry&lt;K,V&gt;(hash, key, value, e)，如果两个线程都同时取得了e,则他们下一个元素都是e，然后赋值给table元素的时候有一个成功有一个丢失。</p>
<h3 id="put非null元素后get出来的却是null"><a href="#put非null元素后get出来的却是null" class="headerlink" title="put非null元素后get出来的却是null"></a>put非null元素后get出来的却是null</h3><p>在transfer方法中代码如下：</p>
<p>void transfer(Entry[] newTable) {<br>    Entry[] src = table;<br>    int newCapacity = newTable.length;<br>    for (int j = 0; j &lt; src.length; j++) {<br>        Entry e = src[j];<br>        if (e != null) {<br>            src[j] = null;<br>            do {<br>                Entry next = e.next;<br>                int i = indexFor(e.hash, newCapacity);<br>                e.next = newTable[i];<br>                newTable[i] = e;<br>                e = next;<br>            } while (e != null);<br>        }<br>    }<br>}</p>
<p>在这个方法里，将旧数组赋值给src，遍历src，当src的元素非null时，就将src中的该元素置null，即将旧数组中的元素置null了，也就是这一句：</p>
<p>if (e != null) {<br>        src[j] = null;</p>
<p>此时若有get方法访问这个key，它取得的还是旧数组，当然就取不到其对应的value了。 <strong>总结：HashMap未同步时在并发程序中会产生许多微妙的问题，难以从表层找到原因。所以使用HashMap出现了违反直觉的现象，那么可能就是并发导致的了。</strong></p>
<h2 id="HashMap数据结构"><a href="#HashMap数据结构" class="headerlink" title="HashMap数据结构"></a>HashMap数据结构</h2><p>我需要简单地说一下HashMap这个经典的数据结构。 HashMap通常会用一个指针数组（假设为table[]）来做分散所有的key，当一个key被加入时，会通过Hash算法通过key算出这个数组的下标i，然后就把这个&lt;key, value&gt;插到table[i]中，如果有两个不同的key被算在了同一个i，那么就叫冲突，又叫碰撞，这样会在table[i]上形成一个链表。 我们知道，如果table[]的尺寸很小，比如只有2个，如果要放进10个keys的话，那么碰撞非常频繁，于是一个O(1)的查找算法，就变成了链表遍历，性能变成了O(n)，这是Hash表的缺陷。 所以，Hash表的尺寸和容量非常的重要。一般来说，Hash表这个容器当有数据要插入时，都会检查容量有没有超过设定的thredhold，如果超过，需要增大Hash表的尺寸，但是这样一来，整个Hash表里的元素都需要被重算一遍。这叫rehash，这个成本相当的大。</p>
<h2 id="HashMap的rehash源代码"><a href="#HashMap的rehash源代码" class="headerlink" title="HashMap的rehash源代码"></a>HashMap的rehash源代码</h2><p>下面，我们来看一下Java的HashMap的源代码。Put一个Key,Value对到Hash表中：</p>
<p>public V put(K key, V value)<br>{<br>    ……<br>    //算Hash值<br>    int hash = hash(key.hashCode());<br>    int i = indexFor(hash, table.length);<br>    //如果该key已被插入，则替换掉旧的value （链接操作）<br>    for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) {<br>        Object k;<br>        if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) {<br>            V oldValue = e.value;<br>            e.value = value;<br>            e.recordAccess(this);<br>            return oldValue;<br>        }<br>    }<br>    modCount++;<br>    //该key不存在，需要增加一个结点<br>    addEntry(hash, key, value, i);<br>    return null;<br>}</p>
<p>检查容量是否超标：</p>
<p>void addEntry(int hash, K key, V value, int bucketIndex)<br>{<br>    Entry&lt;K,V&gt; e = table[bucketIndex];<br>    table[bucketIndex] = new Entry&lt;K,V&gt;(hash, key, value, e);<br>    //查看当前的size是否超过了我们设定的阈值threshold，如果超过，需要resize<br>    if (size++ &gt;= threshold)<br>        resize(2 * table.length);<br>}</p>
<p>新建一个更大尺寸的hash表，然后把数据从老的Hash表中迁移到新的Hash表中。</p>
<p>void resize(int newCapacity)<br>{<br>    Entry[] oldTable = table;<br>    int oldCapacity = oldTable.length;<br>    ……<br>    //创建一个新的Hash Table<br>    Entry[] newTable = new Entry[newCapacity];<br>    //将Old Hash Table上的数据迁移到New Hash Table上<br>    transfer(newTable);<br>    table = newTable;<br>    threshold = (int)(newCapacity * loadFactor);<br>}</p>
<p>迁移的源代码，注意高亮处：</p>
<p>void transfer(Entry[] newTable)<br>{<br>    Entry[] src = table;<br>    int newCapacity = newTable.length;<br>    //下面这段代码的意思是：<br>    //  从OldTable里摘一个元素出来，然后放到NewTable中<br>    for (int j = 0; j &lt; src.length; j++) {<br>        Entry&lt;K,V&gt; e = src[j];<br>        if (e != null) {<br>            src[j] = null;<br>            do {<br>                Entry&lt;K,V&gt; next = e.next;<br>                int i = indexFor(e.hash, newCapacity);<br>                e.next = newTable[i];<br>                newTable[i] = e;<br>                e = next;<br>            } while (e != null);<br>        }<br>    }<br>}</p>
<p>好了，这个代码算是比较正常的。而且没有什么问题。</p>
<h2 id="正常的ReHash过程"><a href="#正常的ReHash过程" class="headerlink" title="正常的ReHash过程"></a>正常的ReHash过程</h2><p>画了个图做了个演示。</p>
<ol>
<li>我假设了我们的hash算法就是简单的用key mod 一下表的大小（也就是数组的长度）。</li>
<li>最上面的是old hash 表，其中的Hash表的size=2, 所以key = 3, 7, 5，在mod 2以后都冲突在table<a href="http://static.oschina.net/uploads/space/2015/0331/142929_Vawr_120166.jpg" target="_blank" rel="noopener">1</a>这里了。</li>
<li>接下来的三个步骤是Hash表 resize成4，然后所有的&lt;key,value&gt; 重新rehash的过程。</li>
</ol>
<p><img data-src="https://cdn.javacodes.cn/files/2016/07/2016-07-05_04-45-06.jpg" alt="在此输入图片描述"></p>
<h2 id="并发的Rehash过程"><a href="#并发的Rehash过程" class="headerlink" title="并发的Rehash过程"></a>并发的Rehash过程</h2><p><strong>（1）假设我们有两个线程。</strong>我用红色和浅蓝色标注了一下。我们再回头看一下我们的 transfer代码中的这个细节：</p>
<p>do {<br>    Entry&lt;K,V&gt; next = e.next; // &lt;–假设线程一执行到这里就被调度挂起了<br>    int i = indexFor(e.hash, newCapacity);<br>    e.next = newTable[i];<br>    newTable[i] = e;<br>    e = next;<br>} while (e != null);</p>
<p>而我们的线程二执行完成了。于是我们有下面的这个样子。 <img data-src="https://cdn.javacodes.cn/files/2016/07/2016-07-05_04-45-07.jpg" alt="在此输入图片描述"> 注意：因为Thread1的 e 指向了key(3)，而next指向了key(7)，其在线程二rehash后，指向了线程二重组后的链表。我们可以看到链表的顺序被反转后。 <strong>（2）线程一被调度回来执行。</strong></p>
<ol>
<li>先是执行 newTalbe[i] = e。</li>
<li>然后是e = next，导致了e指向了key(7)。</li>
<li>而下一次循环的next = e.next导致了next指向了key(3)。</li>
</ol>
<p><img data-src="https://cdn.javacodes.cn/files/2016/07/2016-07-05_04-45-09.jpg" alt="在此输入图片描述"> <strong>（3）一切安好。</strong> 线程一接着工作。把key(7)摘下来，放到newTable[i]的第一个，然后把e和next往下移。 <img data-src="https://cdn.javacodes.cn/files/2016/07/2016-07-05_04-45-10.jpg" alt="在此输入图片描述"> <strong>（4）环形链接出现。</strong> e.next = newTable[i] 导致 key(3).next 指向了 key(7)。注意：此时的key(7).next 已经指向了key(3)， 环形链表就这样出现了。 <img data-src="https://cdn.javacodes.cn/files/2016/07/2016-07-05_04-45-12.jpg" alt="在此输入图片描述"> 于是，当我们的线程一调用到，HashTable.get(11)时，悲剧就出现了——Infinite Loop。</p>
<h2 id="三种解决方案"><a href="#三种解决方案" class="headerlink" title="三种解决方案"></a>三种解决方案</h2><h3 id="Hashtable替换HashMap"><a href="#Hashtable替换HashMap" class="headerlink" title="Hashtable替换HashMap"></a>Hashtable替换HashMap</h3><p>Hashtable 是同步的，但由迭代器返回的 Iterator 和由所有 Hashtable 的“collection 视图方法”返回的 Collection 的 listIterator 方法都是快速失败的：在创建 Iterator 之后，如果从结构上对 Hashtable 进行修改，除非通过 Iterator 自身的移除或添加方法，否则在任何时间以任何方式对其进行修改，Iterator 都将抛出 ConcurrentModificationException。因此，面对并发的修改，Iterator 很快就会完全失败，而不冒在将来某个不确定的时间发生任意不确定行为的风险。由 Hashtable 的键和值方法返回的 Enumeration 不是快速失败的。 注意，迭代器的快速失败行为无法得到保证，因为一般来说，不可能对是否出现不同步并发修改做出任何硬性保证。快速失败迭代器会尽最大努力抛出 ConcurrentModificationException。因此，为提高这类迭代器的正确性而编写一个依赖于此异常的程序是错误做法：迭代器的快速失败行为应该仅用于检测程序错误。</p>
<h3 id="Collections-synchronizedMap将HashMap包装起来"><a href="#Collections-synchronizedMap将HashMap包装起来" class="headerlink" title="Collections.synchronizedMap将HashMap包装起来"></a>Collections.synchronizedMap将HashMap包装起来</h3><p>返回由指定映射支持的同步（线程安全的）映射。为了保证按顺序访问，必须通过返回的映射完成对底层映射的所有访问。在返回的映射或其任意 collection 视图上进行迭代时，强制用户手工在返回的映射上进行同步：</p>
<p>Map m = Collections.synchronizedMap(new HashMap());<br>…<br>Set s = m.keySet();  // Needn’t be in synchronized block<br>…<br>synchronized(m) {  // Synchronizing on m, not s!<br>Iterator i = s.iterator(); // Must be in synchronized block<br>    while (i.hasNext())<br>        foo(i.next());<br>}</p>
<p>不遵从此建议将导致无法确定的行为。如果指定映射是可序列化的，则返回的映射也将是可序列化的。</p>
<h3 id="ConcurrentHashMap替换HashMap"><a href="#ConcurrentHashMap替换HashMap" class="headerlink" title="ConcurrentHashMap替换HashMap"></a>ConcurrentHashMap替换HashMap</h3><p>支持检索的完全并发和更新的所期望可调整并发的哈希表。此类遵守与 Hashtable 相同的功能规范，并且包括对应于 Hashtable 的每个方法的方法版本。不过，尽管所有操作都是线程安全的，但检索操作不必锁定，并且不支持以某种防止所有访问的方式锁定整个表。此类可以通过程序完全与 Hashtable 进行互操作，这取决于其线程安全，而与其同步细节无关。 检索操作（包括 get）通常不会受阻塞，因此，可能与更新操作交迭（包括 put 和 remove）。检索会影响最近完成的更新操作的结果。对于一些聚合操作，比如 putAll 和 clear，并发检索可能只影响某些条目的插入和移除。类似地，在创建迭代器/枚举时或自此之后，Iterators 和 Enumerations 返回在某一时间点上影响哈希表状态的元素。它们不会抛出 ConcurrentModificationException。不过，迭代器被设计成每次仅由一个线程使用。</p>
<blockquote>
<p>来自：陶邦仁的个人空间 - 开源中国社区 作者：陶邦仁 链接：<a href="http://my.oschina.net/xianggao/blog/393990" target="_blank" rel="noopener">http://my.oschina.net/xianggao/blog/393990</a></p>
</blockquote>
]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>并发</tag>
        <tag>HashMap</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>HashMap实现原理及源码分析</title>
    <url>/2017/03/12/HashMap%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%8F%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>哈希表（hash table）也叫散列表，是一种非常重要的数据结构，应用场景及其丰富，许多缓存技术（比如memcached）的核心其实就是在内存中维护一张大的哈希表，而HashMap的实现原理也常常出现在各类的面试题中，重要性可见一斑。本文会对java集合框架中的对应实现HashMap的实现原理进行讲解，然后会对JDK7的HashMap源码进行分析。</p>
<a id="more"></a>

<h1 id="一、什么是哈希表"><a href="#一、什么是哈希表" class="headerlink" title="一、什么是哈希表"></a>一、什么是哈希表</h1><p>在讨论哈希表之前，我们先大概了解下其他数据结构在新增，查找等基础操作执行性能 <strong>数组</strong>：采用一段连续的存储单元来存储数据。对于指定下标的查找，时间复杂度为O(1)；通过给定值进行查找，需要遍历数组，逐一比对给定关键字和数组元素，时间复杂度为O(n)，当然，对于有序数组，则可采用二分查找，插值查找，斐波那契查找等方式，可将查找复杂度提高为O(logn)；对于一般的插入删除操作，涉及到数组元素的移动，其平均复杂度也为O(n) <strong>线性链表</strong>：对于链表的新增，删除等操作（在找到指定操作位置后），仅需处理结点间的引用即可，时间复杂度为O(1)，而查找操作需要遍历链表逐一进行比对，复杂度为O(n) <strong>二叉树</strong>：对一棵相对平衡的有序二叉树，对其进行插入，查找，删除等操作，平均复杂度均为O(logn)。 <strong>哈希表</strong>：相比上述几种数据结构，在哈希表中进行添加，删除，查找等操作，性能十分之高，不考虑哈希冲突的情况下，仅需一次定位即可完成，时间复杂度为O(1)，接下来我们就来看看哈希表是如何实现达到惊艳的常数阶O(1)的。 我们知道，数据结构的物理存储结构只有两种：<strong>顺序存储结构</strong>和<strong>链式存储结构</strong>（像栈，队列，树，图等是从逻辑结构去抽象的，映射到内存中，也这两种物理组织形式），而在上面我们提到过，在数组中根据下标查找某个元素，一次定位就可以达到，哈希表利用了这种特性，<strong>哈希表的主干就是数组</strong>。 比如我们要新增或查找某个元素，我们通过把当前元素的关键字 通过某个函数映射到数组中的某个位置，通过数组下标一次定位就可完成操作。  <strong>存储位置 = f(关键字)</strong> 　其中，这个函数f一般称为<strong>哈希函数</strong>，这个函数的设计好坏会直接影响到哈希表的优劣。举个例子，比如我们要在哈希表中执行插入操作： <img data-src="https://cdn.javacodes.cn/files/2017/03/2017-03-12_10-28-32.png" alt=""> 查找操作同理，先通过哈希函数计算出实际存储地址，然后从数组中对应地址取出即可。 <strong>哈希冲突</strong> 然而万事无完美，如果两个不同的元素，通过哈希函数得出的实际存储地址相同怎么办？也就是说，当我们对某个元素进行哈希运算，得到一个存储地址，然后要进行插入的时候，发现已经被其他元素占用了，其实这就是所谓的<strong>哈希冲突</strong>，也叫哈希碰撞。前面我们提到过，哈希函数的设计至关重要，好的哈希函数会尽可能地保证 <strong>计算简单</strong>和<strong>散列地址分布均匀,</strong>但是，我们需要清楚的是，数组是一块连续的固定长度的内存空间，再好的哈希函数也不能保证得到的存储地址绝对不发生冲突。那么哈希冲突如何解决呢？哈希冲突的解决方案有多种:开放定址法（发生冲突，继续寻找下一块未被占用的存储地址），再散列函数法，链地址法，而HashMap即是采用了链地址法，也就是<strong>数组+链表</strong>的方式，</p>
<h1 id="二、HashMap实现原理"><a href="#二、HashMap实现原理" class="headerlink" title="二、HashMap实现原理"></a>二、HashMap实现原理</h1><p>HashMap的主干是一个Entry数组。Entry是HashMap的基本组成单元，每一个Entry包含一个key-value键值对。</p>
<pre><code>//HashMap的主干数组，可以看到就是一个Entry数组，初始值为空数组{}，主干数组的长度一定是2的次幂，至于为什么这么做，后面会有详细分析。
transient Entry&lt;K,V&gt;[] table = (Entry&lt;K,V&gt;[]) EMPTY_TABLE;</code></pre><p>Entry是HashMap中的一个静态内部类。代码如下</p>
<pre><code>static class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; {
    final K key;
    V value;
    Entry&lt;K,V&gt; next;//存储指向下一个Entry的引用，单链表结构
    int hash;//对key的hashcode值进行hash运算后得到的值，存储在Entry，避免重复计算

    /**
     * Creates new entry.
     */
    Entry(int h, K k, V v, Entry&lt;K,V&gt; n) {
        value = v;
        next = n;
        key = k;
        hash = h;
    }</code></pre><p>所以，HashMap的整体结构如下 <img data-src="https://cdn.javacodes.cn/files/2017/03/2017-03-12_10-28-34.png" alt=""> <strong>简单来说，HashMap由数组+链表组成的，数组是HashMap的主体，链表则是主要为了解决哈希冲突而存在的，如果定位到的数组位置不含链表（当前entry的next指向null）,那么对于查找，添加等操作很快，仅需一次寻址即可；如果定位到的数组包含链表，对于添加操作，其时间复杂度依然为O(1)，因为最新的Entry会插入链表头部，急需要简单改变引用链即可，而对于查找操作来讲，此时就需要遍历链表，然后通过key对象的equals方法逐一比对查找。所以，性能考虑，HashMap中的链表出现越少，性能才会越好。</strong> 其他几个重要字段</p>
<pre><code>//实际存储的key-value键值对的个数
transient int size;
//阈值，当table == {}时，该值为初始容量（初始容量默认为16）；当table被填充了，也就是为table分配内存空间后，threshold一般为 capacity*loadFactory。HashMap在进行扩容时需要参考threshold，后面会详细谈到
int threshold;
//负载因子，代表了table的填充度有多少，默认是0.75
final float loadFactor;
//用于快速失败，由于HashMap非线程安全，在对HashMap进行迭代时，如果期间其他线程的参与导致HashMap的结构发生变化了（比如put，remove等操作），需要抛出异常ConcurrentModificationException
transient int modCount;</code></pre><p>HashMap有4个构造器，其他构造器如果用户没有传入initialCapacity 和loadFactor这两个参数，会使用默认值 initialCapacity默认为16，loadFactory默认为0.75 我们看下其中一个</p>
<pre><code>public HashMap(int initialCapacity, float loadFactor) {
　　　　　//此处对传入的初始容量进行校验，最大不能超过MAXIMUM_CAPACITY = 1&lt;&lt;30(2&lt;sup&gt;30&lt;/sup&gt;)
        if (initialCapacity &lt; 0)
            throw new IllegalArgumentException(&quot;Illegal initial capacity: &quot; +
                                               initialCapacity);
        if (initialCapacity &gt; MAXIMUM_CAPACITY)
            initialCapacity = MAXIMUM_CAPACITY;
        if (loadFactor &lt;= 0 || Float.isNaN(loadFactor))
            throw new IllegalArgumentException(&quot;Illegal load factor: &quot; +
                                               loadFactor);

        this.loadFactor = loadFactor;
        threshold = initialCapacity;
　　　　　
        init();//init方法在HashMap中没有实际实现，不过在其子类如 linkedHashMap中就会有对应实现
    }</code></pre><p>从上面这段代码我们可以看出，<strong>在常规构造器中，没有为数组table分配内存空间（有一个入参为指定Map的构造器例外），而是在执行put操作的时候才真正构建table数组</strong> OK,接下来我们来看看put操作的实现吧</p>
<pre><code>public V put(K key, V value) {
    //如果table数组为空数组{}，进行数组填充（为table分配实际内存空间），入参为threshold，此时threshold为initialCapacity 默认是1&lt;&lt;4(2&lt;sup&gt;4&lt;/sup&gt;=16)
    if (table == EMPTY_TABLE) {
        inflateTable(threshold);
    }
   //如果key为null，存储位置为table[0]或table[0]的冲突链上
    if (key == null)
        return putForNullKey(value);
    int hash = hash(key);//对key的hashcode进一步计算，确保散列均匀
    int i = indexFor(hash, table.length);//获取在table中的实际位置
    for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) {
    //如果该对应数据已存在，执行覆盖操作。用新value替换旧value，并返回旧value
        Object k;
        if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) {
            V oldValue = e.value;
            e.value = value;
            e.recordAccess(this);
            return oldValue;
        }
    }
    modCount++;//保证并发访问时，若HashMap内部结构发生变化，快速响应失败
    addEntry(hash, key, value, i);//新增一个entry
    return null;
}</code></pre><p> 先来看看inflateTable这个方法</p>
<pre><code>private void inflateTable(int toSize) {
        int capacity = roundUpToPowerOf2(toSize);//capacity一定是2的次幂
        threshold = (int) Math.min(capacity * loadFactor, MAXIMUM_CAPACITY + 1);//此处为threshold赋值，取capacity*loadFactor和MAXIMUM_CAPACITY+1的最小值，capaticy一定不会超过MAXIMUM_CAPACITY，除非loadFactor大于1
        table = new Entry[capacity];
        initHashSeedAsNeeded(capacity);
    }</code></pre><p>inflateTable这个方法用于为主干数组table在内存中分配存储空间，通过roundUpToPowerOf2(toSize)可以确保capacity为大于或等于toSize的最接近toSize的二次幂，比如toSize=13,则capacity=16;to_size=16,capacity=16;to_size=17,capacity=32.</p>
<pre><code>private static int roundUpToPowerOf2(int number) {
       // assert number &gt;= 0 : &quot;number must be non-negative&quot;;
       return number &gt;= MAXIMUM_CAPACITY
               ? MAXIMUM_CAPACITY
               : (number &gt; 1) ? Integer.highestOneBit((number - 1) &lt;&lt; 1) : 1;
   }</code></pre><p>roundUpToPowerOf2中的这段处理使得数组长度一定为2的次幂，Integer.highestOneBit是用来获取最左边的bit（其他bit位为0）所代表的数值. hash函数</p>
<pre><code>//这是一个神奇的函数，用了很多的异或，移位等运算，对key的hashcode进一步进行计算以及二进制位的调整等来保证最终获取的存储位置尽量分布均匀
final int hash(Object k) {
        int h = hashSeed;
        if (0 != h &amp;&amp; k instanceof String) {
            return sun.misc.Hashing.stringHash32((String) k);
        }

        h ^= k.hashCode();

        h ^= (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12);
        return h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4);
    }</code></pre><p>以上hash函数计算出的值，通过indexFor进一步处理来获取实际的存储位置</p>
<pre><code>/**
   * 返回数组下标
   */
  static int indexFor(int h, int length) {
      return h &amp; (length-1);
  }</code></pre><p>h&amp;（length-1）保证获取的index一定在数组范围内，举个例子，默认容量16，length-1=15，h=18,转换成二进制计算为</p>
<pre><code>    1  0  0  1  0
&amp;   0  1  1  1  1
__________________
    0  0  0  1  0    = 2</code></pre><p>最终计算出的index=2。有些版本的对于此处的计算会使用 取模运算，也能保证index一定在数组范围内，不过位运算对计算机来说，性能更高一些（HashMap中有大量位运算） 所以最终存储位置的确定流程是这样的： <img data-src="https://cdn.javacodes.cn/files/2017/03/2017-03-12_10-28-34-1.png" alt=""> 再来看看addEntry的实现：</p>
<pre><code>void addEntry(int hash, K key, V value, int bucketIndex) {
        if ((size &gt;= threshold) &amp;&amp; (null != table[bucketIndex])) {
            resize(2 * table.length);//当size超过临界阈值threshold，并且即将发生哈希冲突时进行扩容
            hash = (null != key) ? hash(key) : 0;
            bucketIndex = indexFor(hash, table.length);
        }

        createEntry(hash, key, value, bucketIndex);
    }</code></pre><p>通过以上代码能够得知，当发生哈希冲突并且size大于阈值的时候，需要进行数组扩容，扩容时，需要新建一个长度为之前数组2倍的新的数组，然后将当前的Entry数组中的元素全部传输过去，扩容后的新数组长度为之前的2倍，所以扩容相对来说是个耗资源的操作。</p>
<h1 id="三、为何HashMap的数组长度一定是2的次幂？"><a href="#三、为何HashMap的数组长度一定是2的次幂？" class="headerlink" title="三、为何HashMap的数组长度一定是2的次幂？"></a>三、为何HashMap的数组长度一定是2的次幂？</h1><p>我们来继续看上面提到的resize方法</p>
<pre><code>void resize(int newCapacity) {
       Entry[] oldTable = table;
       int oldCapacity = oldTable.length;
       if (oldCapacity == MAXIMUM_CAPACITY) {
           threshold = Integer.MAX_VALUE;
           return;
       }

       Entry[] newTable = new Entry[newCapacity];
       transfer(newTable, initHashSeedAsNeeded(newCapacity));
       table = newTable;
       threshold = (int)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + 1);
   }</code></pre><p>如果数组进行扩容，数组长度发生变化，而存储位置 index = h&amp;(length-1),index也可能会发生变化，需要重新计算index，我们先来看看transfer这个方法</p>
<pre><code>void transfer(Entry[] newTable, boolean rehash) {
        int newCapacity = newTable.length;
　　　　　//for循环中的代码，逐个遍历链表，重新计算索引位置，将老数组数据复制到新数组中去（数组不存储实际数据，所以仅仅是拷贝引用而已）
        for (Entry&lt;K,V&gt; e : table) {
            while(null != e) {
                Entry&lt;K,V&gt; next = e.next;
                if (rehash) {
                    e.hash = null == e.key ? 0 : hash(e.key);
                }
                int i = indexFor(e.hash, newCapacity);
　　　　　　　　　 //将当前entry的next链指向新的索引位置,newTable[i]有可能为空，有可能也是个entry链，如果是entry链，直接在链表头部插入。
                e.next = newTable[i];
                newTable[i] = e;
                e = next;
            }
        }
    }</code></pre><p>这个方法将老数组中的数据逐个链表地遍历，扔到新的扩容后的数组中，我们的数组索引位置的计算是通过 对key值的hashcode进行hash扰乱运算后，再通过和 length-1进行位运算得到最终数组索引位置。 hashMap的数组长度一定保持2的次幂，比如16的二进制表示为 10000，那么length-1就是15，二进制为01111，同理扩容后的数组长度为32，二进制表示为100000，length-1为31，二进制表示为011111。从下图可以我们也能看到这样会保证低位全为1，而扩容后只有一位差异，也就是多出了最左位的1，这样在通过 h&amp;(length-1)的时候，只要h对应的最左边的那一个差异位为0，就能保证得到的新的数组索引和老数组索引一致(大大减少了之前已经散列良好的老数组的数据位置重新调换)，个人理解。 <img data-src="https://cdn.javacodes.cn/files/2017/03/2017-03-12_10-28-35.png" alt=""> 还有，数组长度保持2的次幂，length-1的低位都为1，会使得获得的数组索引index更加均匀，比如： <img data-src="https://cdn.javacodes.cn/files/2017/03/2017-03-12_10-28-35-1.png" alt=""> 我们看到，上面的&amp;运算，高位是不会对结果产生影响的（hash函数采用各种位运算可能也是为了使得低位更加散列），我们只关注低位bit，如果低位全部为1，那么对于h低位部分来说，任何一位的变化都会对结果产生影响，也就是说，要得到index=21这个存储位置，h的低位只有这一种组合。这也是数组长度设计为必须为2的次幂的原因。 <img data-src="https://cdn.javacodes.cn/files/2017/03/2017-03-12_10-28-35-2.png" alt=""> 如果不是2的次幂，也就是低位不是全为1此时，要使得index=21，h的低位部分不再具有唯一性了，哈希冲突的几率会变的更大，同时，index对应的这个bit位无论如何不会等于1了，而对应的那些数组位置也就被白白浪费了。 get方法</p>
<pre><code>public V get(Object key) {
　　　　 //如果key为null,则直接去table[0]处去检索即可。
       if (key == null)
           return getForNullKey();
       Entry&lt;K,V&gt; entry = getEntry(key);
       return null == entry ? null : entry.getValue();
}</code></pre><p>get方法通过key值返回对应value，如果key为null，直接去table[0]处检索。我们再看一下getEntry这个方法</p>
<pre><code>final Entry&lt;K,V&gt; getEntry(Object key) {

        if (size == 0) {
            return null;
        }
        //通过key的hashcode值计算hash值
        int hash = (key == null) ? 0 : hash(key);
        //indexFor (hash&amp;length-1) 获取最终数组索引，然后遍历链表，通过equals方法比对找出对应记录
        for (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)];
             e != null;
             e = e.next) {
            Object k;
            if (e.hash == hash &amp;&amp; 
                ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))
                return e;
        }
        return null;
    }</code></pre><p>可以看出，get方法的实现相对简单，key(hashcode)–&gt;hash–&gt;indexFor–&gt;最终索引位置，找到对应位置table[i]，再查看是否有链表，遍历链表，通过key的equals方法比对查找对应的记录。要注意的是，有人觉得上面在定位到数组位置之后然后遍历链表的时候，e.hash == hash这个判断没必要，仅通过equals判断就可以。其实不然，试想一下，如果传入的key对象重写了equals方法却没有重写hashCode，而恰巧此对象定位到这个数组位置，如果仅仅用equals判断可能是相等的，但其hashCode和当前对象不一致，这种情况，根据Object的hashCode的约定，不能返回当前对象，而应该返回null，后面的例子会做出进一步解释。</p>
<h1 id="四、重写equals方法需同时重写hashCode方法"><a href="#四、重写equals方法需同时重写hashCode方法" class="headerlink" title="四、重写equals方法需同时重写hashCode方法"></a>四、重写equals方法需同时重写hashCode方法</h1><p>关于HashMap的源码分析就介绍到这儿了，最后我们再聊聊老生常谈的一个问题，各种资料上都会提到，“重写equals时也要同时覆盖hashcode”，我们举个小例子来看看，如果重写了equals而不重写hashcode会发生什么样的问题</p>
<pre><code>/**
 * Created by chengxiao on 2016/11/15.
 */
public class MyTest {
    private static class Person{
        int idCard;
        String name;

        public Person(int idCard, String name) {
            this.idCard = idCard;
            this.name = name;
        }
        @Override
        public boolean equals(Object o) {
            if (this == o) {
                return true;
            }
            if (o == null || getClass() != o.getClass()){
                return false;
            }
            Person person = (Person) o;
            //两个对象是否等值，通过idCard来确定
            return this.idCard == person.idCard;
        }

    }
    public static void main(String []args){
        HashMap&lt;Person,String&gt; map = new HashMap&lt;Person, String&gt;();
        Person person = new Person(1234,&quot;乔峰&quot;);
        //put到hashmap中去
        map.put(person,&quot;天龙八部&quot;);
        //get取出，从逻辑上讲应该能输出“天龙八部”
        System.out.println(&quot;结果:&quot;+map.get(new Person(1234,&quot;萧峰&quot;)));
    }
}</code></pre><p>实际输出结果：</p>
<p>结果：null</p>
<p>如果我们已经对HashMap的原理有了一定了解，这个结果就不难理解了。尽管我们在进行get和put操作的时候，使用的key从逻辑上讲是等值的（通过equals比较是相等的），但由于没有重写hashCode方法，所以put操作时，key(hashcode1)–&gt;hash–&gt;indexFor–&gt;最终索引位置 ，而通过key取出value的时候 key(hashcode1)–&gt;hash–&gt;indexFor–&gt;最终索引位置，由于hashcode1不等于hashcode2，导致没有定位到一个数组位置而返回逻辑上错误的值null（也有可能碰巧定位到一个数组位置，但是也会判断其entry的hash值是否相等，上面get方法中有提到。） 所以，在重写equals的方法的时候，必须注意重写hashCode方法，同时还要保证通过equals判断相等的两个对象，调用hashCode方法要返回同样的整数值。而如果equals判断不相等的两个对象，其hashCode可以相同（只不过会发生哈希冲突，应尽量避免）。</p>
<h1 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h1><p>本文描述了HashMap的实现原理，并结合源码做了进一步的分析，也涉及到一些源码细节设计缘由，最后简单介绍了为什么重写equals的时候需要重写hashCode方法。希望本篇文章能帮助到大家，同时也欢迎讨论指正，谢谢支持！</p>
<p>作者： <a href="http://www.cnblogs.com/chengxiao/" target="_blank" rel="noopener">dreamcatcher-cx</a> 出处： <a href="http://www.cnblogs.com/chengxiao/" target="_blank" rel="noopener"><a href="http://www.cnblogs.com/chengxiao/" target="_blank" rel="noopener">http://www.cnblogs.com/chengxiao/</a></a> 本文版权归作者和博客园共有，欢迎转载，但未经作者同意必须保留此段声明，且在页面明显位置给出原文链接。</p>
]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>HashMap</tag>
      </tags>
  </entry>
  <entry>
    <title>IntelliJ Idea 常用快捷键列表</title>
    <url>/2016/09/27/IntelliJ%20Idea%20%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE%E5%88%97%E8%A1%A8/</url>
    <content><![CDATA[<p>Ctrl+Shift + Enter，语句完成 “！”，否定完成，输入表达式时按 “！”键<br>Ctrl+E，最近的文件<br>Ctrl+Shift+E，最近更改的文件 Shift+Click，可以关闭文件<br>Ctrl+[ OR ]，可以跑到大括号的开头与结尾<br>Ctrl+F12，可以显示当前文件的结构<br>Ctrl+F7，可以查询当前元素在当前文件中的引用，然后按 F3 可以选择<br>Ctrl+N，可以快速打开类 </p>
<a id="more"></a>

<p>Ctrl+Shift+N，可以快速打开文件 Alt+Q，可以看到当前方法的声明<br>Ctrl+P，可以显示参数信息<br>Ctrl+Shift+Insert，可以选择剪贴板内容并插入 Alt+Insert，可以生成构造器/Getter/Setter等<br>Ctrl+Alt+V，可以引入变量。例如：new String(); 自动导入变量定义<br>Ctrl+Alt+T，可以把代码包在一个块内，例如：try/catch<br>Ctrl+Enter，导入包，自动修正<br>Ctrl+Alt+L，格式化代码<br>Ctrl+Alt+I，将选中的代码进行自动缩进编排，这个功能在编辑 JSP 文件时也可以工作<br>Ctrl+Alt+O，优化导入的类和包<br>Ctrl+R，替换文本<br>Ctrl+F，查找文本<br>Ctrl+Shift+Space，自动补全代码<br>Ctrl+空格，代码提示（与系统输入法快捷键冲突）<br>Ctrl+Shift+Alt+N，查找类中的方法或变量 Alt+Shift+C，最近的更改 Alt+Shift+Up/Down，上/下移一行 Shift+F6，重构 – 重命名<br>Ctrl+X，删除行<br>Ctrl+D，复制行<br>Ctrl+/或<br>Ctrl+Shift+/，注释（//或者/<strong>/）<br>Ctrl+J，自动代码（例如：serr）<br>Ctrl+Alt+J，用动态模板环绕<br>Ctrl+H，显示类结构图（类的继承层次）<br>Ctrl+Q，显示注释文档 Alt+F1，查找代码所在位置 Alt+1，快速打开或隐藏工程面板<br>Ctrl+Alt+left/right，返回至上次浏览的位置 Alt+left/right，切换代码视图 Alt+Up/Down，在方法间快速移动定位<br>Ctrl+Shift+Up/Down，向上/下移动语句 F2 或 Shift+F2，高亮错误或警告快速定位 Tab，代码标签输入完成后，按 Tab，生成代码<br>Ctrl+Shift+F7，高亮显示所有该文本，按 Esc 高亮消失 Alt+F3，逐个往下查找相同文本，并高亮显示<br>Ctrl+Up/Down，光标中转到第一行或最后一行下<br>Ctrl+B/<br>Ctrl+Click，快速打开光标处的类或方法（跳转到定义处）<br>Ctrl+Alt+B，跳转到方法实现处<br>Ctrl+Shift+Backspace，跳转到上次编辑的地方<br>Ctrl+O，重写方法<br>Ctrl+Alt+Space，类名自动完成<br>Ctrl+Alt+Up/Down，快速跳转搜索结果<br>Ctrl+Shift+J，整合两行 Alt+F8，计算变量值<br>Ctrl+Shift+V，可以将最近使用的剪贴板内容选择插入到文本<br>Ctrl+Alt+Shift+V，简单粘贴 Shift+Esc，不仅可以把焦点移到编辑器上，而且还可以隐藏当前（或最后活动的）工具窗口 F12，把焦点从编辑器移到最近使用的工具窗口 Shift+F1，要打开编辑器光标字符处使用的类或者方法 Java 文档的浏览器<br>Ctrl+W，可以选择单词继而语句继而行继而函数<br>Ctrl+Shift+W，取消选择光标所在词 Alt+F7，查找整个工程中使用地某一个类、方法或者变量的位置<br>Ctrl+I，实现方法<br>Ctrl+Shift+U，大小写转化<br>Ctrl+Y，删除当前行 Shift+Enter，向下插入新行 psvm/sout，main/System.out.println();<br>Ctrl+J，查看更多<br>Ctrl+Shift+F，全局查找<br>Ctrl+F，查找/Shift+F3，向上查找/F3，向下查找<br>Ctrl+Shift+S，高级搜索<br>Ctrl+U，转到父类<br>Ctrl+Alt+S，打开设置对话框 Alt+Shift+Inert，开启/关闭列选择模式<br>Ctrl+Alt+Shift+S，打开当前项目/模块属性<br>Ctrl+G，定位行 Alt+Home，跳转到导航栏<br>Ctrl+Enter，上插一行<br>Ctrl+Backspace，按单词删除<br>Ctrl+”+/-”，当前方法展开、折叠<br>Ctrl+Shift+”+/-”，全部展开、折叠 **【调试部分、编译】</strong><br>Ctrl+F2，停止 Alt+Shift+F9，选择 Debug Alt+Shift+F10，选择 Run<br>Ctrl+Shift+F9，编译<br>Ctrl+Shift+F10，运行<br>Ctrl+Shift+F8，查看断点 F8，步过 F7，步入 Shift+F7，智能步入 Shift+F8，步出 Alt+Shift+F8，强制步过 Alt+Shift+F7，强制步入 Alt+F9，运行至光标处<br>Ctrl+Alt+F9，强制运行至光标处 F9，恢复程序 Alt+F10，定位到断点<br>Ctrl+F8，切换行断点<br>Ctrl+F9，生成项目 Alt+1，项目 Alt+2，收藏 Alt+6，TODO Alt+7，结构<br>Ctrl+Shift+C，复制路径<br>Ctrl+Alt+Shift+C，复制引用，必须选择类名<br>Ctrl+Alt+Y，同步<br>Ctrl+~，快速切换方案（界面外观、代码风格、快捷键映射等菜单） Shift+F12，还原默认布局<br>Ctrl+Shift+F12，隐藏/恢复所有窗口<br>Ctrl+F4，关闭<br>Ctrl+Shift+F4，关闭活动选项卡<br>Ctrl+Tab，转到下一个拆分器<br>Ctrl+Shift+Tab，转到上一个拆分器 <strong>【重构】</strong><br>Ctrl+Alt+Shift+T，弹出重构菜单 Shift+F6，重命名 F6，移动 F5，复制 Alt+Delete，安全删除<br>Ctrl+Alt+N，内联 <strong>【查找】</strong><br>Ctrl+F，查找<br>Ctrl+R，替换 F3，查找下一个 Shift+F3，查找上一个<br>Ctrl+Shift+F，在路径中查找<br>Ctrl+Shift+R，在路径中替换<br>Ctrl+Shift+S，搜索结构<br>Ctrl+Shift+M，替换结构 Alt+F7，查找用法<br>Ctrl+Alt+F7，显示用法<br>Ctrl+F7，在文件中查找用法<br>Ctrl+Shift+F7，在文件中高亮显示用法</p>
]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>IntelliJ Idea</tag>
        <tag>常用快捷键</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM内存划分</title>
    <url>/2017/03/11/JVM%E5%86%85%E5%AD%98%E5%88%92%E5%88%86/</url>
    <content><![CDATA[<p>Java虚拟机内存规范所管理的内存包括如下运行时数据区域：程序计数器、虚拟机栈、本地方法栈、Java堆、方法区等。</p>
<p><img data-src="https://cdn.javacodes.cn/files/2017/03/2017-03-11_05-11-49.png" alt=""></p>
<a id="more"></a>

<h3 id="程序计数器（Program-Counter-Register）"><a href="#程序计数器（Program-Counter-Register）" class="headerlink" title="程序计数器（Program Counter Register）"></a>程序计数器（Program Counter Register）</h3><p>可以看做是当前线程所执行的<strong>字节码行号指示器</strong>，每条线程都有一个独立的程序计数器（线程私有），此内存区是Java虚拟机规范中唯一没有任何OutOfMemoryError情况的区域。</p>
<h3 id="Java虚拟机栈（Java-Virtual-Machine-Stack）"><a href="#Java虚拟机栈（Java-Virtual-Machine-Stack）" class="headerlink" title="Java虚拟机栈（Java Virtual Machine Stack）"></a>Java虚拟机栈（Java Virtual Machine Stack）</h3><p>线程私有，描述Java方法执行的内存模型：每个方法执行时，都会创建一个栈帧用于存放<strong>局部变量表、操作数栈、动态链接、方法出口</strong>等信息。既每一个方法的执行到完成的过程，对应着栈帧的入栈和出栈的过程。</p>
<h4 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h4><p>局部变量表存放了编译器可知的各种<strong>基本数据类型、对象引用和returnAdress类型</strong>。</p>
<ul>
<li>其中double和long类型的数据会占用2个局部变量空间（slot），其余的类型均占用1个。</li>
<li>局部变量表的空间在编译器即完成分配，大小完全确定，方法运行期间不会改变局部变量表的大小。</li>
</ul>
<h4 id="两种异常情况"><a href="#两种异常情况" class="headerlink" title="两种异常情况"></a>两种异常情况</h4><p>如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverFlowError异常。</p>
<p>如果虚拟机栈可以动态扩展（大部分Java虚拟机都可以），如果扩展时无法申请到足够的内存，就会抛出OutOfMemoryError异常。</p>
<h3 id="本地方法栈（Native-Method-Stack）"><a href="#本地方法栈（Native-Method-Stack）" class="headerlink" title="本地方法栈（Native Method Stack）"></a>本地方法栈（Native Method Stack）</h3><p>与虚拟机栈的发挥作用类似，区别如下：</p>
<ul>
<li>虚拟机栈为虚拟机执行Java方法（字节码）服务。</li>
<li>本地方发栈为虚拟机使用到的Native方法服务。</li>
</ul>
<p>本地方法栈在不同的虚拟机有不同的实现方式，甚至Sun HotSpot虚拟机将本地方法栈和虚拟机栈合二为一。</p>
<p>本地方法栈同样会出现虚拟机栈存在的两种异常情况。</p>
<h3 id="Java堆（Java-Heap）"><a href="#Java堆（Java-Heap）" class="headerlink" title="Java堆（Java Heap）"></a>Java堆（Java Heap）</h3><p>线程共享，在虚拟机启动时创建，唯一目的是存放对象实例。几乎所有的对象实例都在堆上分配。Java堆是GC的主要区域，因此也常称为“GC堆”。</p>
<ul>
<li>从垃圾回收的角度看，由于现在的GC基本都采用分代的收集算法，因此还可以将Java堆细分为：<strong>新生代</strong>和<strong>老年代</strong>。再细致划分的话，有：Eden空间、From Survivor空间、To Suvivor空间。</li>
<li>从内存分配的角度看，线程共享的Java堆还可能划分成多个线程私有的分配缓冲区（TLAB）。</li>
</ul>
<p>但无论如何划分，无论哪个区域，Java堆中存储的都是对象实例，进一步划分是为了更好的回收和分配内存。</p>
<p>Java堆要求逻辑上连续，但物理上可以不连续。主流虚拟机在Java堆的实现上大多采用可以扩展（通过-Xms和-Xmx控制）的实现。</p>
<p>如果Java堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出OutOfMemoryError异常。</p>
<h3 id="方法区（Method-Area）"><a href="#方法区（Method-Area）" class="headerlink" title="方法区（Method Area）"></a>方法区（Method Area）</h3><p>线程共享，用于存储已被Java虚拟机<strong>加载的类信息、常量、静态变量、即时编译器编译后的代码</strong>等数据。Java虚拟机规范将其描述为堆的一个逻辑部分，但它却有个别名叫做Non-Heap（非堆），目的将其与Java堆分开。</p>
<ul>
<li>对于HotSpot虚拟机来说，通常将方法区成为“永久代”（Permanent Generation），但这种描述并不准确，只是因为HotSpot的设计团队将GC分代算法扩展到了方法区，目的是省去专门为方法区编写内存管理代码的工作。对于其它虚拟机来说是不存在永久代的概念的。通常在方法区发生的GC是比较少的，这区域的主要目标是针对常量池的回收和对类型的卸载。</li>
<li>HotSpot团队官方发布的路线图信息，现在也有放弃永久代并逐步改为Native Memory来实现方法区的规划。在JDK1.7的HotSpot中，已经把原本放在永久代中的字符串常量池移出。</li>
</ul>
<p>当方法区无法满足内存的分配需求时，将会抛出OutOfMemoryError异常。</p>
<h3 id="运行时常量池（Runtime-Constant-Pool）"><a href="#运行时常量池（Runtime-Constant-Pool）" class="headerlink" title="运行时常量池（Runtime Constant Pool）"></a>运行时常量池（Runtime Constant Pool）</h3><p>运行时常量池是方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等描述信息以外，还有一项信息是常量池，用于存放编译期生成的各种字面量和符号引用，这部分内容在类加载后进入方法区的运行时常量池中存放。</p>
<ul>
<li>对于运行时常量池，Java虚拟机规范中没有做任何细节的要求，不同的提供商实现的虚拟机可以按照自己的需要来实现这个内存区域。不过，一般来说，除了存储Class文件中描述的符号引用外，还会把翻译出来的直接引用也存储在运行时常量池中。</li>
<li>运行时常量池相对于Class文件常量池的另外一个重要特性是具备动态性。Java语言不要求敞亮一定要在编译期产生，也就是说并非一定要预置入Class文件中常量池的内容才能进入运行时常量池，运行期间也可能将新的敞亮放入池中，这种特性被开发人员利用的比较多的便是String类的intern()方法。</li>
</ul>
<p>当运行时常量池无法满足内存的分配需求，将会抛出OutOfMemoryError异常。</p>
<h3 id="直接内存（Direct-Memory）"><a href="#直接内存（Direct-Memory）" class="headerlink" title="直接内存（Direct Memory）"></a>直接内存（Direct Memory）</h3><p>直接内存不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中的内存区域，但却被频繁使用，也有可能导致OutOfMemoryError异常。</p>
<p>在NIO中，引入了一种基于通道（Channel）与缓冲区（Buffer）的I/O方式，可以利用Native函数库直接分配堆外内存，通过一个存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，避免了在Java堆和Native堆中来回复制数据。</p>
<p>直接内存不受到Java堆大小的限制，但是仍然受到本机RAM和SWAP区（或分页文件）大小以及处理器寻址空间的限制。服务器管理员在配置虚拟机参数时，常常忽略直接内存而设置-Xmx等信息，终而导致各个内存区的总大小大于物理内存限制，从而导致动态扩展时出现的OutOfMemoryError异常。</p>
]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 8 中新的 Date 和 Time 类入门详解</title>
    <url>/2016/07/05/Java%208%20%E4%B8%AD%E6%96%B0%E7%9A%84%20Date%20%E5%92%8C%20Time%20%E7%B1%BB%E5%85%A5%E9%97%A8%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<p>这篇文章主要是java8中新的Date和Time API的实战。新的Date和Time类是java开发者社区千呼万唤始出来的。Java8 之前存在的Date类一直都受人诟病，很多人都会选择使用第三方的date库<a href="http://www.joda.org/joda-time/" target="_blank" rel="noopener">joda-time</a>。Java8中的date和time api是jodatime的作者参与开发的，实现了JSR310的全部内容。这些新的api都在包java.time下。 既然第三方的joda-time,date4j都已经足够强大了，为什么java8还要重新实现他呢，一部分的原因是这些第三方的库是存在兼容问题的，比如标准的JSF日期转化器与joda-time api，就不兼容，每次使用都需要编写自己的转换器，所以标准化api是必须的，就有了JSR310，java8中就实现了他全部的规定内容。</p>
<a id="more"></a>

<h2 id="新Date类和Time类背后的设计原则："><a href="#新Date类和Time类背后的设计原则：" class="headerlink" title="新Date类和Time类背后的设计原则："></a>新Date类和Time类背后的设计原则：</h2><p><strong>不可变类</strong> java8之前，Date类都是可变类。当我们在多线程环境下使用它，编程人员应该确认Date对象的线程安全。Java8的Date和Time API提供了线程安全的不可变类。编程人员不用考虑并发的问题。 <strong>领域模型驱动设计方法</strong> 新的日期和时间的类别遵循“域驱动设计”。对于开发者来说，理解方法和类的功能是很容易的。</p>
<h2 id="接下来让我们来看看新Date和Time-API"><a href="#接下来让我们来看看新Date和Time-API" class="headerlink" title="接下来让我们来看看新Date和Time API:"></a>接下来让我们来看看新Date和Time API:</h2><p><strong>java.time.LocalDate:</strong> LocalDate只提供日期不提供时间信息。它是不可变类且线程安全的。</p>
<p>package org.smarttechie;<br>import java.time.LocalDate;<br>import java.time.temporal.ChronoUnit;<br>/**<br>* This class demonstrates JAVA 8 data and time API<br>* @author Siva Prasad Rao Janapati<br>* <em>/<br>public class DateTimeDemonstration {<br>/*\</em><br>* @param args<br>*/<br>public static void main(String[] args) {<br>   //Create date LocalDate localDate = LocalDate.now();<br>    System.out.println(“The local date is :: “ + localDate);<br>   //Find the length of the month. That is, how many days are there for this month.<br>   System.out.println(“The number of days available for this month:: “ + localDate.lengthOfMonth());<br>   //Know the month name<br>   System.out.println(“What is the month name? :: “ + localDate.getMonth().name());<br>   //add 2 days to the today’s date.<br>   System.out.println(localDate.plus(2, ChronoUnit.DAYS));<br>   //substract 2 days from today<br>   System.out.println(localDate.minus(2, ChronoUnit.DAYS));<br>   //Convert the string to date<br>   System.out.println(localDate.parse(“2017-04-07”));<br>  }<br>}</p>
<p><strong>java.time.LocalTime:</strong> LocalTime只提供时间而不提供日期信息，它是不可变类且线程安全的。</p>
<p>package org.smarttechie;<br>import java.time.LocalTime;<br>import java.time.temporal.ChronoUnit;<br>/**<br>* This class demonstrates JAVA 8 data and time API<br>* @author Siva Prasad Rao Janapati<br>* <em>/<br>public class DateTimeDemonstration {<br>/*\</em><br>* @param args<br>*/<br>public static void main(String[] args) {<br>   //Get local time<br>   LocalTime localTime = LocalTime.now();<br>   System.out.println(localTime);<br>  //Get the hour of the day<br>  System.out.println(“The hour of the day:: “ + localTime.getHour());<br>  //add 2 hours to the time.<br>  System.out.println(localTime.plus(2, ChronoUnit.HOURS));<br>  //add 6 minutes to the time.<br>  System.out.println(localTime.plusMinutes(6));<br>  //substract 2 hours from current time<br>  System.out.println(localTime.minus(2, ChronoUnit.HOURS));<br> }<br>}</p>
<p><strong>java.time.LocalDateTime:</strong> LocalDateTime提供时间和日期的信息，它是不可变类且线程安全的</p>
<p>package orr.smarttechie;<br>import java.time.LocalDateTime;<br>import java.time.temporal.ChronoUnit;<br>/**<br>* This class demonstrates JAVA 8 data and time API<br>* @author Siva Prasad Rao Janapati<br>*<br><em>/<br>public class DateTimeDemonstration {<br>/*\</em><br>* @param args<br>*/<br>public static void main(String[] args) {<br>    //Get LocalDateTime object<br>    LocalDateTime localDateTime = LocalDateTime.now();<br>    System.out.println(localDateTime);<br>    //Find the length of month. That is, how many days are there for this month.<br>    System.out.println(“The number of days available for this month:: “ + localDateTime.getMonth().length(true));<br>    //Know the month name<br>    System.out.println(“What is the month name? :: “ + localDateTime.getMonth().name());<br>    //add 2 days to today’s date.<br>    System.out.println(localDateTime.plus(2, ChronoUnit.DAYS));<br>    //substract 2 days from today<br>    System.out.println(localDateTime.minus(2, ChronoUnit.DAYS));<br>  }<br>}</p>
<p><strong>java.time.Year:</strong> Year提供年的信息，它是不可变类且线程安全的。</p>
<p>package orr.smarttechie;<br>import java.time.Year;<br>import java.time.temporal.ChronoUnit;<br>/**<br>* This class demonstrates JAVA 8 data and time API<br>* @author Siva Prasad Rao Janapati<br>*<br><em>/<br>public class DateTimeDemonstration {<br>/*\</em><br>* @param args<br>*/<br>public static void main(String[] args) {<br>   //Get year<br>   Year year = Year.now();<br>   System.out.println(“Year ::” + year);<br>   //know the year is leap year or not<br>   System.out.println(“Is year[“ +year+”] leap year?”+ year.isLeap());<br>  }<br>}</p>
<p><strong>java.time.Duration:</strong> Duration是用来计算两个给定的日期之间包含多少秒，多少毫秒，它是不可变类且线程安全的 <strong>java.time.Period:</strong> Period是用来计算两个给定的日期之间包含多少天，多少月或者多少年，它是不可变类且线程安全的</p>
<p>package orr.smarttechie;<br>import java.time.LocalDate;<br>import java.time.Period;<br>import java.time.temporal.ChronoUnit;<br>/**<br>* This class demonstrates JAVA 8 data and time API<br>* @author Siva Prasad Rao Janapati<br>*<br><em>/<br>public class DateTimeDemonstration {<br>/*\</em><br>* @param args<br>*/<br>public static void main(String[] args) {<br>   LocalDate localDate = LocalDate.now();<br>   Period period = Period.between(localDate, localDate.plus(2, ChronoUnit.DAYS));<br>   System.out.println(period.getDays());<br>  }<br>}</p>
<blockquote>
<p>来自：码农网 译文链接：<a href="http://www.codeceo.com/article/java-8-date-time-guide.html" target="_blank" rel="noopener">http://www.codeceo.com/article/java-8-date-time-guide.html</a> 英文原文：<a href="https://dzone.com/articles/java-8-new-data-and-time-overview" target="_blank" rel="noopener">https://dzone.com/articles/java-8-new-data-and-time-overview</a> 翻译作者：码农网 – 栗子蜀黍</p>
</blockquote>
]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Date</tag>
        <tag>Java APIs</tag>
      </tags>
  </entry>
  <entry>
    <title>Java NIO 教程详解</title>
    <url>/2017/03/15/Java%20NIO%20%E6%95%99%E7%A8%8B%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<blockquote>
<p>英文原文地址：<a href="http://tutorials.jenkov.com/java-nio/index.html" target="_blank" rel="noopener">http://tutorials.jenkov.com/java-nio/index.html</a> 中文来源地址：<a href="http://ifeve.com/java-nio-all/" target="_blank" rel="noopener">http://ifeve.com/java-nio-all/</a> 作者：Jakob Jenkov 译者：郭蕾 校对：方腾飞 本文由<a href="https://cdn.javacodes.cn" target="_blank" rel="noopener">老H博客</a>整理修订</p>
</blockquote>
<p>[TOC] Java NIO(New IO)是一个可以替代标准Java IO API的IO API（从Java 1.4开始)，Java NIO提供了与标准IO不同的IO工作方式。</p>
<ul>
<li><strong>Java NIO: Channels and Buffers（通道和缓冲区）</strong>：标准的IO基于字节流和字符流进行操作的，而NIO是基于通道（Channel）和缓冲区（Buffer）进行操作，数据总是从通道读取到缓冲区中，或者从缓冲区写入到通道中。</li>
<li><strong>Java NIO: Non-blocking IO（非阻塞IO）</strong>：Java NIO可以让你非阻塞的使用IO，例如：当线程从通道读取数据到缓冲区时，线程还是可以进行其他事情。当数据被写入到缓冲区时，线程可以继续处理它。从缓冲区写入通道也类似。</li>
<li><strong>Java NIO: Selectors（选择器）</strong>：Java NIO引入了选择器的概念，选择器用于监听多个通道的事件（比如：连接打开，数据到达）。因此，单个的线程可以监听多个数据通道。</li>
</ul>
<a id="more"></a>

<p>各章节直达链接：</p>
<ol>
<li><a href="#nio-1">Java NIO概述</a></li>
<li><a href="#nio-2">Java NIO Channel</a></li>
<li><a href="#nio-3">Java NIO Buffer</a></li>
<li><a href="#nio-4">Java NIO Scatter / Gather</a></li>
<li><a href="#nio-5">Java NIO 通道之间的数据传输</a></li>
<li><a href="#nio-6">Java NIO Selector</a></li>
<li><a href="#nio-7">Java NIO FileChannel</a></li>
<li><a href="#nio-8">Java NIO SocketChannel</a></li>
<li><a href="#nio-9">Java NIO ServerSocketChannel</a></li>
<li><a href="#nio-10">Java NIO DataGramChannel</a></li>
<li><a href="#nio-11">Java NIO Pipe</a></li>
<li><a href="#nio-12">Java NIO NIO 与IO</a></li>
</ol>
<hr>
<h2 id="一、Java-NIO-概述"><a href="#一、Java-NIO-概述" class="headerlink" title="一、Java NIO 概述"></a>一、Java NIO 概述</h2><p>Java NIO 由以下几个核心部分组成：</p>
<ul>
<li>Channels</li>
<li>Buffers</li>
<li>Selectors</li>
</ul>
<p>虽然Java NIO 中除此之外还有很多类和组件，但在我看来，Channel，Buffer 和 Selector 构成了核心的API。其它组件，如Pipe和FileLock，只不过是与三个核心组件共同使用的工具类。因此，在概述中我将集中在这三个组件上。其它组件会在单独的章节中讲到。</p>
<h3 id="Channel-和-Buffer"><a href="#Channel-和-Buffer" class="headerlink" title="Channel 和 Buffer"></a>Channel 和 Buffer</h3><p>基本上，所有的 IO 在NIO 中都从一个Channel 开始。Channel 有点象流。 数据可以从Channel读到Buffer中，也可以从Buffer 写到Channel中。这里有个图示： <img data-src="https://cdn.javacodes.cn/files/2017/03/2017-03-14_17-35-10-1.jpg" alt="">￼ Channel和Buffer有好几种类型。下面是JAVA NIO中的一些主要Channel的实现：</p>
<ul>
<li>FileChannel</li>
<li>DatagramChannel</li>
<li>SocketChannel</li>
<li>ServerSocketChannel</li>
</ul>
<p>正如你所看到的，这些通道涵盖了UDP 和 TCP 网络IO，以及文件IO。 与这些类一起的有一些有趣的接口，但为简单起见，我尽量在概述中不提到它们。本教程其它章节与它们相关的地方我会进行解释。 以下是Java NIO里关键的Buffer实现：</p>
<ul>
<li>ByteBuffer</li>
<li>CharBuffer</li>
<li>DoubleBuffer</li>
<li>FloatBuffer</li>
<li>IntBuffer</li>
<li>LongBuffer</li>
<li>ShortBuffer</li>
</ul>
<p>这些Buffer覆盖了你能通过IO发送的基本数据类型：byte, short, int, long, float, double 和 char。 Java NIO 还有个 MappedByteBuffer，用于表示内存映射文件， 我也不打算在概述中说明。</p>
<h3 id="Selector"><a href="#Selector" class="headerlink" title="Selector"></a>Selector</h3><p>Selector允许单线程处理多个 Channel。如果你的应用打开了多个连接（通道），但每个连接的流量都很低，使用Selector就会很方便。例如，在一个聊天服务器中。 这是在一个单线程中使用一个Selector处理3个Channel的图示： <img data-src="https://cdn.javacodes.cn/files/2017/03/2017-03-14_17-35-10.jpg" alt="">￼ 要使用Selector，得向Selector注册Channel，然后调用它的<code>select()</code>方法。这个方法会一直阻塞到某个注册的通道有事件就绪。一旦这个方法返回，线程就可以处理这些事件，事件的例子有如新连接进来，数据接收等。</p>
<hr>
<h2 id="二、Channal"><a href="#二、Channal" class="headerlink" title="二、Channal"></a>二、Channal</h2><p>Java NIO的通道类似流，但又有些不同：</p>
<ul>
<li>既可以从通道中读取数据，又可以写数据到通道。但流的读写通常是单向的。</li>
<li>通道可以异步地读写。</li>
<li>通道中的数据总是要先读到一个Buffer，或者总是要从一个Buffer中写入。</li>
</ul>
<p>正如上面所说，从通道读取数据到缓冲区，从缓冲区写入数据到通道。如下图所示： <img data-src="https://cdn.javacodes.cn/files/2017/03/2017-03-14_17-35-10-4.jpg" alt="">￼</p>
<h3 id="Channel的实现"><a href="#Channel的实现" class="headerlink" title="Channel的实现"></a>Channel的实现</h3><p>这些是Java NIO中最重要的通道的实现：</p>
<ul>
<li>FileChannel</li>
<li>DatagramChannel</li>
<li>SocketChannel</li>
<li>ServerSocketChannel</li>
</ul>
<p>FileChannel 从文件中读写数据。 DatagramChannel 能通过UDP读写网络中的数据。 SocketChannel 能通过TCP读写网络中的数据。 ServerSocketChannel可以监听新进来的TCP连接，像Web服务器那样。对每一个新进来的连接都会创建一个SocketChannel。</p>
<h3 id="基本的-Channel-示例"><a href="#基本的-Channel-示例" class="headerlink" title="基本的 Channel 示例"></a>基本的 Channel 示例</h3><p>下面是一个使用FileChannel读取数据到Buffer中的示例：</p>
<pre><code>RandomAccessFile aFile = new RandomAccessFile(&quot;data/nio-data.txt&quot;, &quot;rw&quot;);
FileChannel inChannel = aFile.getChannel();
ByteBuffer buf = ByteBuffer.allocate(48);
int bytesRead = inChannel.read(buf);
while (bytesRead != -1) {
  System.out.println(&quot;Read &quot; + bytesRead);
  buf.flip();
  while(buf.hasRemaining()){
      System.out.print((char) buf.get());
  }
  buf.clear();
  bytesRead = inChannel.read(buf);
}
aFile.close();</code></pre><p>注意 buf.flip() 的调用，首先读取数据到Buffer，然后反转Buffer,接着再从Buffer中读取数据。下一节会深入讲解Buffer的更多细节。</p>
<hr>
<h2 id="三、Buffer"><a href="#三、Buffer" class="headerlink" title="三、Buffer"></a>三、Buffer</h2><p>Java NIO中的Buffer用于和NIO通道进行交互。如你所知，数据是从通道读入缓冲区，从缓冲区写入到通道中的。 缓冲区本质上是一块可以写入数据，然后可以从中读取数据的内存。这块内存被包装成NIO Buffer对象，并提供了一组方法，用来方便的访问该块内存。</p>
<h3 id="Buffer的基本用法"><a href="#Buffer的基本用法" class="headerlink" title="Buffer的基本用法"></a>Buffer的基本用法</h3><p>使用Buffer读写数据一般遵循以下四个步骤：</p>
<ol>
<li>写入数据到Buffer</li>
<li>调用<code>flip()</code>方法</li>
<li>从Buffer中读取数据</li>
<li>调用<code>clear()</code>方法或者<code>compact()</code>方法</li>
</ol>
<p>当向buffer写入数据时，buffer会记录下写了多少数据。一旦要读取数据，需要通过<code>flip()</code>方法将Buffer从写模式切换到读模式。在读模式下，可以读取之前写入到buffer的所有数据。 一旦读完了所有的数据，就需要清空缓冲区，让它可以再次被写入。有两种方式能清空缓冲区：调用<code>clear()</code>或<code>compact()</code>方法。</p>
<ul>
<li><code>clear()</code>方法会清空整个缓冲区。</li>
<li><code>compact()</code>方法只会清除已经读过的数据。任何未读的数据都被移到缓冲区的起始处，新写入的数据将放到缓冲区未读数据的后面。</li>
</ul>
<p>下面是一个使用Buffer的例子：</p>
<pre><code>RandomAccessFile aFile = new RandomAccessFile(&quot;data/nio-data.txt&quot;, &quot;rw&quot;);
FileChannel inChannel = aFile.getChannel();
//create buffer with capacity of 48 bytes
ByteBuffer buf = ByteBuffer.allocate(48);
int bytesRead = inChannel.read(buf); //read into buffer.
while (bytesRead != -1) {
  buf.flip(); //make buffer ready for read
  while(buf.hasRemaining()){
      System.out.print((char) buf.get()); // read 1 byte at a time
  }
  buf.clear(); //make buffer ready for writing
  bytesRead = inChannel.read(buf);
}
aFile.close();</code></pre><h3 id="Buffer的capacity-position和limit"><a href="#Buffer的capacity-position和limit" class="headerlink" title="Buffer的capacity,position和limit"></a>Buffer的capacity,position和limit</h3><p>缓冲区本质上是一块可以写入数据，然后可以从中读取数据的内存。这块内存被包装成NIO Buffer对象，并提供了一组方法，用来方便的访问该块内存。 为了理解Buffer的工作原理，需要熟悉它的三个属性：</p>
<ul>
<li>capacity</li>
<li>position</li>
<li>limit</li>
</ul>
<p>position和limit的含义取决于Buffer处在读模式还是写模式。不管Buffer处在什么模式，capacity的含义总是一样的。 这里有一个关于capacity，position和limit在读写模式中的说明，详细的解释在插图后面。 <img data-src="https://cdn.javacodes.cn/files/2017/03/2017-03-14_17-35-10-5.jpg" alt="">￼</p>
<ul>
<li><strong>capacity</strong>：作为一个内存块，Buffer有一个固定的大小值，也叫“capacity”.你只能往里写capacity个byte、long，char等类型。一旦Buffer满了，需要将其清空（通过读数据或者清除数据）才能继续写数据往里写数据。</li>
<li><strong>position</strong>：当你写数据到Buffer中时，position表示当前的位置。初始的position值为0.当一个byte、long等数据写到Buffer后， position会向前移动到下一个可插入数据的Buffer单元。position最大可为capacity – 1。 当读取数据时，也是从某个特定位置读。当将Buffer从写模式切换到读模式，position会被重置为0. 当从Buffer的position处读取数据时，position向前移动到下一个可读的位置。</li>
<li><strong>limit</strong>：在写模式下，Buffer的limit表示你最多能往Buffer里写多少数据。 写模式下，limit等于Buffer的capacity。当切换Buffer到读模式时， limit表示你最多能读到多少数据。因此，当切换Buffer到读模式时，limit会被设置成写模式下的position值。换句话说，你能读到之前写入的所有数据（limit被设置成已写数据的数量，这个值在写模式下就是position）。</li>
</ul>
<h3 id="Buffer的类型"><a href="#Buffer的类型" class="headerlink" title="Buffer的类型"></a>Buffer的类型</h3><p>Java NIO 有以下Buffer类型</p>
<ul>
<li>ByteBuffer</li>
<li>MappedByteBuffer</li>
<li>CharBuffer</li>
<li>DoubleBuffer</li>
<li>FloatBuffer</li>
<li>IntBuffer</li>
<li>LongBuffer</li>
<li>ShortBuffer</li>
</ul>
<p>如你所见，这些Buffer类型代表了不同的数据类型。换句话说，就是可以通过char，short，int，long，float 或 double类型来操作缓冲区中的字节。 MappedByteBuffer 有些特别，在涉及它的专门章节中再讲。</p>
<h3 id="Buffer的分配"><a href="#Buffer的分配" class="headerlink" title="Buffer的分配"></a>Buffer的分配</h3><p>要想获得一个Buffer对象首先要进行分配。 每一个Buffer类都有一个<code>allocate()</code>方法。下面是一个分配48字节capacity的ByteBuffer的例子。</p>
<pre><code>ByteBuffer buf = ByteBuffer.allocate(48);</code></pre><p>这是分配一个可存储1024个字符的CharBuffer：</p>
<pre><code>CharBuffer buf = CharBuffer.allocate(1024);</code></pre><h3 id="向Buffer中写数据"><a href="#向Buffer中写数据" class="headerlink" title="向Buffer中写数据"></a>向Buffer中写数据</h3><p>写数据到Buffer有两种方式：</p>
<ul>
<li>从Channel写到Buffer。</li>
<li>通过Buffer的<code>put()</code>方法写到Buffer里。</li>
</ul>
<p>从Channel写到Buffer的例子</p>
<pre><code>int bytesRead = inChannel.read(buf); //read into buffer.</code></pre><p>通过<code>put()</code>方法写Buffer的例子：</p>
<pre><code>buf.put(127);</code></pre><p><code>put()</code>方法有很多版本，允许你以不同的方式把数据写入到Buffer中。例如， 写到一个指定的位置，或者把一个字节数组写入到Buffer。 更多Buffer实现的细节参考JavaDoc。</p>
<h4 id="flip-方法"><a href="#flip-方法" class="headerlink" title="flip()方法"></a>flip()方法</h4><p><code>flip()</code>方法将Buffer从写模式切换到读模式。调用<code>flip()</code>方法会将position设回0，并将limit设置成之前position的值。 换句话说，position现在用于标记读的位置，limit表示之前写进了多少个byte、char等 —— 现在能读取多少个byte、char等。</p>
<h3 id="从Buffer中读取数据"><a href="#从Buffer中读取数据" class="headerlink" title="从Buffer中读取数据"></a>从Buffer中读取数据</h3><p>从Buffer中读取数据有两种方式：</p>
<ul>
<li>从Buffer读取数据到Channel。</li>
<li>使用<code>get()</code>方法从Buffer中读取数据。</li>
</ul>
<p>从Buffer读取数据到Channel的例子：</p>
<pre><code>//read from buffer into channel.
int bytesWritten = inChannel.write(buf);</code></pre><p>使用<code>get()</code>方法从Buffer中读取数据的例子</p>
<pre><code>byte aByte = buf.get();</code></pre><p><code>get()</code>方法有很多版本，允许你以不同的方式从Buffer中读取数据。例如，从指定position读取，或者从Buffer中读取数据到字节数组。更多Buffer实现的细节参考JavaDoc。</p>
<h3 id="rewind-方法"><a href="#rewind-方法" class="headerlink" title="rewind()方法"></a>rewind()方法</h3><p><code>Buffer.rewind()</code>将position设回0，所以你可以重读Buffer中的所有数据。limit保持不变，仍然表示能从Buffer中读取多少个元素（byte、char等）。</p>
<h3 id="clear-与compact-方法"><a href="#clear-与compact-方法" class="headerlink" title="clear()与compact()方法"></a>clear()与compact()方法</h3><p>一旦读完Buffer中的数据，需要让Buffer准备好再次被写入。可以通过<code>clear()</code>或<code>compact()</code>方法来完成。</p>
<ul>
<li><p>如果调用的是<code>clear()</code>方法，position将被设回0，limit被设置成 capacity的值。换句话说，Buffer 被清空了。Buffer中的数据并未清除，只是这些标记告诉我们可以从哪里开始往Buffer里写数据。如果Buffer中有一些未读的数据，调用<code>clear()</code>方法，数据将“被遗忘”，意味着不再有任何标记会告诉你哪些数据被读过，哪些还没有。</p>
</li>
<li><p>如果Buffer中仍有未读的数据，且后续还需要这些数据，但是此时想要先先写些数据，那么使用<code>compact()</code>方法。<code>compact()</code>方法将所有未读的数据拷贝到Buffer起始处。然后将position设到最后一个未读元素正后面。limit属性依然像<code>clear()</code>方法一样，设置成capacity。现在Buffer准备好写数据了，但是不会覆盖未读的数据。</p>
</li>
</ul>
<h3 id="mark-与reset-方法"><a href="#mark-与reset-方法" class="headerlink" title="mark()与reset()方法"></a>mark()与reset()方法</h3><p>通过调用<code>Buffer.mark()</code>方法，可以标记Buffer中的一个特定position。之后可以通过调用<code>Buffer.reset()</code>方法恢复到这个position。例如：</p>
<pre><code>buffer.mark();
//call buffer.get() a couple of times, e.g. during parsing.
buffer.reset(); //set position back to mark.</code></pre><h3 id="equals-与compareTo-方法"><a href="#equals-与compareTo-方法" class="headerlink" title="equals()与compareTo()方法"></a>equals()与compareTo()方法</h3><p>可以使用<code>equals()</code>和<code>compareTo()</code>方法两个Buffer。 ####equals() 当满足下列条件时，表示两个Buffer相等：</p>
<ol>
<li>有相同的类型（byte、char、int等）。</li>
<li>Buffer中剩余的byte、char等的个数相等。</li>
<li>Buffer中所有剩余的byte、char等都相同。</li>
</ol>
<p>如你所见，equals只是比较Buffer的一部分，不是每一个在它里面的元素都比较。实际上，它只比较Buffer中的剩余元素。 ####compareTo()方法 <code>compareTo()</code>方法比较两个Buffer的剩余元素(byte、char等)， 如果满足下列条件，则认为一个Buffer“小于”另一个Buffer：</p>
<ol>
<li>第一个不相等的元素小于另一个Buffer中对应的元素 。</li>
<li>所有元素都相等，但第一个Buffer比另一个先耗尽(第一个Buffer的元素个数比另一个少。</li>
</ol>
<p>（译注：剩余元素是从 position到limit之间的元素）</p>
<hr>
<h2 id="四、Scatter-Gather"><a href="#四、Scatter-Gather" class="headerlink" title="四、Scatter/Gather"></a>四、Scatter/Gather</h2><p>Java NIO开始支持scatter/gather，scatter/gather用于描述从Channel（译者注：Channel在中文经常翻译为通道）中读取或者写入到Channel的操作。</p>
<ul>
<li><strong>分散（scatter）</strong>：从Channel中读取是指在读操作时将读取的数据写入多个buffer中。因此，Channel将从Channel中读取的数据“分散（scatter）”到多个Buffer中。</li>
<li><strong>聚集（gather）</strong>：写入Channel是指在写操作时将多个buffer的数据写入同一个Channel，因此，Channel 将多个Buffer中的数据“聚集（gather）”后发送到Channel。</li>
</ul>
<p>scatter / gather经常用于需要将传输的数据分开处理的场合，例如传输一个由消息头和消息体组成的消息，你可能会将消息体和消息头分散到不同的buffer中，这样你可以方便的处理消息头和消息体。 ###Scattering Reads Scattering Reads是指数据从一个channel读取到多个buffer中。如下图描述： <img data-src="https://cdn.javacodes.cn/files/2017/03/2017-03-14_17-35-10-2.jpg" alt="">￼ 代码示例如下：</p>
<pre><code>ByteBuffer header = ByteBuffer.allocate(128);
ByteBuffer body = ByteBuffer.allocate(1024);
ByteBuffer[] bufferArray = { header, body };
channel.read(bufferArray);</code></pre><p>注意buffer首先被插入到数组，然后再将数组作为<code>channel.read()</code> 的输入参数。<code>read()</code>方法按照buffer在数组中的顺序将从channel中读取的数据写入到buffer，当一个buffer被写满后，channel紧接着向另一个buffer中写。 Scattering Reads在移动下一个buffer前，必须填满当前的buffer，这也意味着它不适用于动态消息(译者注：消息大小不固定)。换句话说，如果存在消息头和消息体，消息头必须完成填充（例如 128byte），Scattering Reads才能正常工作。</p>
<h3 id="Gathering-Writes"><a href="#Gathering-Writes" class="headerlink" title="Gathering Writes"></a>Gathering Writes</h3><p>Gathering Writes是指数据从多个buffer写入到同一个channel。如下图描述： <img data-src="https://cdn.javacodes.cn/files/2017/03/2017-03-14_17-35-10-3.jpg" alt="">￼ 代码示例如下：</p>
<pre><code>ByteBuffer header = ByteBuffer.allocate(128);
ByteBuffer body = ByteBuffer.allocate(1024);
//write data into buffers
ByteBuffer[] bufferArray = { header, body };
channel.write(bufferArray);</code></pre><p>buffers数组是<code>write()</code>方法的入参，write()方法会按照buffer在数组中的顺序，将数据写入到channel，注意只有position和limit之间的数据才会被写入。因此，如果一个buffer的容量为128byte，但是仅仅包含58byte的数据，那么这58byte的数据将被写入到channel中。因此与Scattering Reads相反，Gathering Writes能较好的处理动态消息。</p>
<hr>
<h2 id="五、通道之间的数据传输"><a href="#五、通道之间的数据传输" class="headerlink" title="五、通道之间的数据传输"></a>五、通道之间的数据传输</h2><p>在Java NIO中，如果两个通道中有一个是FileChannel，那你可以直接将数据从一个channel（译者注：channel中文常译作通道）传输到另外一个channel。</p>
<h3 id="transferFrom"><a href="#transferFrom" class="headerlink" title="transferFrom()"></a>transferFrom()</h3><p>FileChannel的<code>transferFrom()</code>方法可以将数据从源通道传输到FileChannel中（译者注：这个方法在JDK文档中的解释为将字节从给定的可读取字节通道传输到此通道的文件中）。下面是一个简单的例子：</p>
<pre><code>javaRandomAccessFile fromFile = new RandomAccessFile(&quot;fromFile.txt&quot;, &quot;rw&quot;);
FileChannel fromChannel = fromFile.getChannel();
RandomAccessFile toFile = new RandomAccessFile(&quot;toFile.txt&quot;, &quot;rw&quot;);
FileChannel toChannel = toFile.getChannel();
long position = 0;
long count = fromChannel.size();
toChannel.transferFrom(fromChannel, position, count);</code></pre><p>方法的输入参数position表示从position处开始向目标文件写入数据，count表示最多传输的字节数。如果源通道的剩余空间小于 count 个字节，则所传输的字节数要小于请求的字节数。 此外要注意，在SoketChannel的实现中，SocketChannel只会传输此刻准备好的数据（可能不足count字节）。因此，SocketChannel可能不会将请求的所有数据(count个字节)全部传输到FileChannel中。</p>
<h3 id="transferTo"><a href="#transferTo" class="headerlink" title="transferTo()"></a>transferTo()</h3><p><code>transferTo()</code>方法将数据从FileChannel传输到其他的channel中。下面是一个简单的例子：</p>
<pre><code>RandomAccessFile fromFile = new RandomAccessFile(&quot;fromFile.txt&quot;, &quot;rw&quot;);
FileChannel fromChannel = fromFile.getChannel();
RandomAccessFile toFile = new RandomAccessFile(&quot;toFile.txt&quot;, &quot;rw&quot;);
FileChannel toChannel = toFile.getChannel();
long position = 0;
long count = fromChannel.size();
fromChannel.transferTo(position, count, toChannel);</code></pre><p>是不是发现这个例子和前面那个例子特别相似？除了调用方法的FileChannel对象不一样外，其他的都一样。 上面所说的关于SocketChannel的问题在<code>transferTo()</code>方法中同样存在。SocketChannel会一直传输数据直到目标buffer被填满。</p>
<hr>
<h2 id="六、Selector"><a href="#六、Selector" class="headerlink" title="六、Selector"></a>六、Selector</h2><p>Selector（选择器）是Java NIO中能够检测一到多个NIO通道，并能够知晓通道是否为诸如读写事件做好准备的组件。这样，一个单独的线程可以管理多个channel，从而管理多个网络连接。</p>
<h3 id="为什么使用Selector"><a href="#为什么使用Selector" class="headerlink" title="为什么使用Selector?"></a>为什么使用Selector?</h3><p>仅用单个线程来处理多个Channels的好处是，只需要更少的线程来处理通道。事实上，可以只用一个线程处理所有的通道。对于操作系统来说，线程之间上下文切换的开销很大，而且每个线程都要占用系统的一些资源（如内存）。因此，使用的线程越少越好。 但是，需要记住，现代的操作系统和CPU在多任务方面表现的越来越好，所以多线程的开销随着时间的推移，变得越来越小了。实际上，如果一个CPU有多个内核，不使用多任务可能是在浪费CPU能力。不管怎么说，关于那种设计的讨论应该放在另一篇不同的文章中。在这里，只要知道使用Selector能够处理多个通道就足够了。 下面是单线程使用一个Selector处理3个channel的示例图： <img data-src="https://cdn.javacodes.cn/files/2017/03/2017-03-14_17-35-14-3.jpg" alt="">￼</p>
<h3 id="Selector的创建"><a href="#Selector的创建" class="headerlink" title="Selector的创建"></a>Selector的创建</h3><p>通过调用<code>Selector.open()</code>方法创建一个Selector，如下：</p>
<pre><code>Selector selector = Selector.open();</code></pre><h3 id="向Selector注册通道"><a href="#向Selector注册通道" class="headerlink" title="向Selector注册通道"></a>向Selector注册通道</h3><p>为了将Channel和Selector配合使用，必须将channel注册到selector上。通过 <code>SelectableChannel.register()</code>方法来实现，如下：</p>
<pre><code>channel.configureBlocking(false);
SelectionKey key = channel.register(selector, Selectionkey.OP_READ);</code></pre><p>与Selector一起使用时，Channel必须处于非阻塞模式下。这意味着不能将FileChannel与Selector一起使用，因为FileChannel不能切换到非阻塞模式。而套接字通道都可以。 注意register()方法的第二个参数。这是一个“interest集合”，意思是在通过Selector监听Channel时对什么事件感兴趣。可以监听四种不同类型的事件：</p>
<ol>
<li>Connect</li>
<li>Accept</li>
<li>Read</li>
<li>Write</li>
</ol>
<p>通道触发了一个事件意思是该事件已经就绪。所以，某个channel成功连接到另一个服务器称为“连接就绪”。一个server socket channel准备好接收新进入的连接称为“接收就绪”。一个有数据可读的通道可以说是“读就绪”。等待写数据的通道可以说是“写就绪”。 这四种事件用SelectionKey的四个常量来表示：</p>
<ol>
<li>SelectionKey.OP_CONNECT</li>
<li>SelectionKey.OP_ACCEPT</li>
<li>SelectionKey.OP_READ</li>
<li>SelectionKey.OP_WRITE</li>
</ol>
<p>如果你对不止一种事件感兴趣，那么可以用“位或”操作符将常量连接起来，如下：</p>
<pre><code>int interestSet = SelectionKey.OP_READ | SelectionKey.OP_WRITE;</code></pre><p>在下面还会继续提到interest集合。</p>
<h3 id="SelectionKey"><a href="#SelectionKey" class="headerlink" title="SelectionKey"></a>SelectionKey</h3><p>在上一小节中，当向Selector注册Channel时，register()方法会返回一个SelectionKey对象。这个对象包含了一些你感兴趣的属性：</p>
<ul>
<li>interest集合</li>
<li>ready集合</li>
<li>Channel</li>
<li>Selector</li>
<li>附加的对象（可选）</li>
</ul>
<p>下面我会描述这些属性。</p>
<h4 id="interest集合"><a href="#interest集合" class="headerlink" title="interest集合"></a>interest集合</h4><p>就像向Selector注册通道一节中所描述的，interest集合是你所选择的感兴趣的事件集合。可以通过SelectionKey读写interest集合，像这样：</p>
<pre><code>int interestSet = selectionKey.interestOps();
boolean isInterestedInAccept = (interestSet &amp; SelectionKey.OP_ACCEPT) == SelectionKey.OP_ACCEPT；
boolean isInterestedInConnect = interestSet &amp; SelectionKey.OP_CONNECT;
boolean isInterestedInRead = interestSet &amp; SelectionKey.OP_READ;
boolean isInterestedInWrite = interestSet &amp; SelectionKey.OP_WRITE;</code></pre><p>可以看到，用“位与”操作interest 集合和给定的SelectionKey常量，可以确定某个确定的事件是否在interest 集合中。</p>
<h4 id="ready集合"><a href="#ready集合" class="headerlink" title="ready集合"></a>ready集合</h4><p>ready 集合是通道已经准备就绪的操作的集合。在一次选择(Selection)之后，你会首先访问这个ready set。Selection将在下一小节进行解释。可以这样访问ready集合：</p>
<pre><code>int readySet = selectionKey.readyOps();</code></pre><p>可以用像检测interest集合那样的方法，来检测channel中什么事件或操作已经就绪。但是，也可以使用以下四个方法，它们都会返回一个布尔类型：</p>
<pre><code>selectionKey.isAcceptable();
selectionKey.isConnectable();
selectionKey.isReadable();
selectionKey.isWritable();</code></pre><h4 id="Channel-Selector"><a href="#Channel-Selector" class="headerlink" title="Channel + Selector"></a>Channel + Selector</h4><p>从SelectionKey访问Channel和Selector很简单。如下：</p>
<pre><code>Channel channel = selectionKey.channel();
Selector selector = selectionKey.selector();</code></pre><h4 id="附加的对象"><a href="#附加的对象" class="headerlink" title="附加的对象"></a>附加的对象</h4><p>可以将一个对象或者更多信息附着到SelectionKey上，这样就能方便的识别某个给定的通道。例如，可以附加 与通道一起使用的Buffer，或是包含聚集数据的某个对象。使用方法如下：</p>
<pre><code>selectionKey.attach(theObject);
Object attachedObj = selectionKey.attachment();</code></pre><p>还可以在用<code>register()</code>方法向Selector注册Channel的时候附加对象。如：</p>
<pre><code>SelectionKey key = channel.register(selector, SelectionKey.OP_READ, theObject);</code></pre><h3 id="通过Selector选择通道"><a href="#通过Selector选择通道" class="headerlink" title="通过Selector选择通道"></a>通过Selector选择通道</h3><p>一旦向Selector注册了一或多个通道，就可以调用几个重载的<code>select()</code>方法。这些方法返回你所感兴趣的事件（如连接、接受、读或写）已经准备就绪的那些通道。换句话说，如果你对“读就绪”的通道感兴趣，<code>select()</code>方法会返回读事件已经就绪的那些通道。 下面是select()方法：</p>
<ul>
<li>int select()：阻塞到至少有一个通道在你注册的事件上就绪了。</li>
<li>int select(long timeout)：和<code>select()</code>一样，除了最长会阻塞timeout毫秒(参数)。</li>
<li>int selectNow()：不会阻塞，不管什么通道就绪都立刻返回（译者注：此方法执行非阻塞的选择操作。如果自从前一次选择操作后，没有通道变成可选择的，则此方法直接返回零）。</li>
</ul>
<p><code>select()</code>方法返回的int值表示有多少通道已经就绪。亦即，自上次调用<code>select()</code>方法后有多少通道变成就绪状态。如果调用<code>select()</code>方法，因为有一个通道变成就绪状态，返回了1，若再次调用<code>select()</code>方法，如果另一个通道就绪了，它会再次返回1。如果对第一个就绪的channel没有做任何操作，现在就有两个就绪的通道，但在每次<code>select()</code>方法调用之间，只有一个通道就绪了。</p>
<h3 id="selectedKeys"><a href="#selectedKeys" class="headerlink" title="selectedKeys()"></a>selectedKeys()</h3><p>一旦调用了<code>select()</code>方法，并且返回值表明有一个或更多个通道就绪了，然后可以通过调用selector的<code>selectedKeys()</code>方法，访问“已选择键集（selected key set）”中的就绪通道。如下所示：</p>
<pre><code>Set selectedKeys = selector.selectedKeys();</code></pre><p>当像Selector注册Channel时，<code>Channel.register()</code>方法会返回一个SelectionKey 对象。这个对象代表了注册到该Selector的通道。可以通过SelectionKey的<code>selectedKeySet()</code>方法访问这些对象。 可以遍历这个已选择的键集合来访问就绪的通道。如下：</p>
<pre><code>Set selectedKeys = selector.selectedKeys();
Iterator keyIterator = selectedKeys.iterator();
while(keyIterator.hasNext()) {
    SelectionKey key = keyIterator.next();
    if(key.isAcceptable()) {
        // a connection was accepted by a ServerSocketChannel.
    } else if (key.isConnectable()) {
        // a connection was established with a remote server.
    } else if (key.isReadable()) {
        // a channel is ready for reading
    } else if (key.isWritable()) {
        // a channel is ready for writing
    }
    keyIterator.remove();
}</code></pre><p>这个循环遍历已选择键集中的每个键，并检测各个键所对应的通道的就绪事件。 注意每次迭代末尾的<code>keyIterator.remove()</code>调用。Selector不会自己从已选择键集中移除SelectionKey实例。必须在处理完通道时自己移除。下次该通道变成就绪时，Selector会再次将其放入已选择键集中。 <code>SelectionKey.channel()</code>方法返回的通道需要转型成你要处理的类型，如ServerSocketChannel或SocketChannel等。</p>
<h3 id="wakeUp"><a href="#wakeUp" class="headerlink" title="wakeUp()"></a>wakeUp()</h3><p>某个线程调用<code>select()</code>方法后阻塞了，即使没有通道已经就绪，也有办法让其从<code>select()</code>方法返回。只要让其它线程在第一个线程调用<code>select()</code>方法的那个对象上调用<code>Selector.wakeup()</code>方法即可。阻塞在select()方法上的线程会立马返回。 如果有其它线程调用了<code>wakeup()</code>方法，但当前没有线程阻塞在<code>select()</code>方法上，下个调用select()方法的线程会立即“醒来（wake up）”。</p>
<h3 id="close"><a href="#close" class="headerlink" title="close()"></a>close()</h3><p>用完Selector后调用其<code>close()</code>方法会关闭该Selector，且使注册到该Selector上的所有SelectionKey实例无效。通道本身并不会关闭。</p>
<h3 id="完整的示例"><a href="#完整的示例" class="headerlink" title="完整的示例"></a>完整的示例</h3><p>这里有一个完整的示例，打开一个Selector，注册一个通道注册到这个Selector上(通道的初始化过程略去),然后持续监控这个Selector的四种事件（接受，连接，读，写）是否就绪。</p>
<pre><code>Selector selector = Selector.open();
channel.configureBlocking(false);
SelectionKey key = channel.register(selector, SelectionKey.OP_READ);
while(true) {
  int readyChannels = selector.select();
  if(readyChannels == 0) continue;
  Set selectedKeys = selector.selectedKeys();
  Iterator keyIterator = selectedKeys.iterator();
  while(keyIterator.hasNext()) {
    SelectionKey key = keyIterator.next();
    if(key.isAcceptable()) {
        // a connection was accepted by a ServerSocketChannel.
    } else if (key.isConnectable()) {
        // a connection was established with a remote server.
    } else if (key.isReadable()) {
        // a channel is ready for reading
    } else if (key.isWritable()) {
        // a channel is ready for writing
    }
    keyIterator.remove();
  }
}</code></pre><hr>
<h2 id="七、FileChannel"><a href="#七、FileChannel" class="headerlink" title="七、FileChannel"></a>七、FileChannel</h2><p>Java NIO中的FileChannel是一个连接到文件的通道。可以通过文件通道读写文件。 FileChannel无法设置为非阻塞模式，它总是运行在阻塞模式下。</p>
<h3 id="打开FileChannel"><a href="#打开FileChannel" class="headerlink" title="打开FileChannel"></a>打开FileChannel</h3><p>在使用FileChannel之前，必须先打开它。但是，我们无法直接打开一个FileChannel，需要通过使用一个InputStream、OutputStream或RandomAccessFile来获取一个FileChannel实例。 下面是通过RandomAccessFile打开FileChannel的示例：</p>
<pre><code>RandomAccessFile aFile = new RandomAccessFile(&quot;data/nio-data.txt&quot;, &quot;rw&quot;);
FileChannel inChannel = aFile.getChannel();</code></pre><h3 id="从FileChannel读取数据"><a href="#从FileChannel读取数据" class="headerlink" title="从FileChannel读取数据"></a>从FileChannel读取数据</h3><p>调用多个<code>read()</code>方法之一从FileChannel中读取数据。如：</p>
<pre><code>ByteBuffer buf = ByteBuffer.allocate(48);
int bytesRead = inChannel.read(buf);</code></pre><p>首先，分配一个Buffer。从FileChannel中读取的数据将被读到Buffer中。 然后，调用FileChannel.read()方法。该方法将数据从FileChannel读取到Buffer中。read()方法返回的int值表示了有多少字节被读到了Buffer中。如果返回-1，表示到了文件末尾。</p>
<h3 id="向FileChannel写数据"><a href="#向FileChannel写数据" class="headerlink" title="向FileChannel写数据"></a>向FileChannel写数据</h3><p>使用<code>FileChannel.write()</code>方法向FileChannel写数据，该方法的参数是一个Buffer。如：</p>
<pre><code>String newData = &quot;New String to write to file...&quot; + System.currentTimeMillis();
ByteBuffer buf = ByteBuffer.allocate(48);
buf.clear();
buf.put(newData.getBytes());
buf.flip();
while(buf.hasRemaining()) {
    channel.write(buf);
}</code></pre><p>注意<code>FileChannel.write()</code>是在while循环中调用的。因为无法保证<code>write()</code>方法一次能向FileChannel写入多少字节，因此需要重复调用<code>write()</code>方法，直到Buffer中已经没有尚未写入通道的字节。</p>
<h3 id="关闭FileChannel"><a href="#关闭FileChannel" class="headerlink" title="关闭FileChannel"></a>关闭FileChannel</h3><p>用完FileChannel后必须将其关闭。如：</p>
<pre><code>channel.close();</code></pre><h3 id="FileChannel的position方法"><a href="#FileChannel的position方法" class="headerlink" title="FileChannel的position方法"></a>FileChannel的position方法</h3><p>有时可能需要在FileChannel的某个特定位置进行数据的读/写操作。可以通过调用<code>position()</code>方法获取FileChannel的当前位置。 也可以通过调用<code>position(long pos)</code>方法设置FileChannel的当前位置。 这里有两个例子:</p>
<pre><code>long pos = channel.position();
channel.position(pos +123);</code></pre><ul>
<li>如果将位置设置在文件结束符之后，然后试图从文件通道中读取数据，读方法将返回-1 —— 文件结束标志。</li>
<li>如果将位置设置在文件结束符之后，然后向通道中写数据，文件将撑大到当前位置并写入数据。这可能导致“文件空洞”，磁盘上物理文件中写入的数据间有空隙。</li>
</ul>
<h3 id="FileChannel的size方法"><a href="#FileChannel的size方法" class="headerlink" title="FileChannel的size方法"></a>FileChannel的size方法</h3><p>FileChannel实例的<code>size()</code>方法将返回该实例所关联文件的大小。如:</p>
<pre><code>long fileSize = channel.size();</code></pre><h3 id="FileChannel的truncate方法"><a href="#FileChannel的truncate方法" class="headerlink" title="FileChannel的truncate方法"></a>FileChannel的truncate方法</h3><p>可以使用<code>FileChannel.truncate()</code>方法截取一个文件。截取文件时，文件将中指定长度后面的部分将被删除。如：</p>
<pre><code>channel.truncate(1024);</code></pre><p>这个例子截取文件的前1024个字节。</p>
<h3 id="FileChannel的force方法"><a href="#FileChannel的force方法" class="headerlink" title="FileChannel的force方法"></a>FileChannel的force方法</h3><p><code>FileChannel.force()</code>方法将通道里尚未写入磁盘的数据强制写到磁盘上。出于性能方面的考虑，操作系统会将数据缓存在内存中，所以无法保证写入到FileChannel里的数据一定会即时写到磁盘上。要保证这一点，需要调用<code>force()</code>方法。 <code>force()</code>方法有一个boolean类型的参数，指明是否同时将文件元数据（权限信息等）写到磁盘上。 下面的例子同时将文件数据和元数据强制写到磁盘上：</p>
<pre><code>channel.force(true);</code></pre><hr>
<h2 id="八、SocketChannel"><a href="#八、SocketChannel" class="headerlink" title="八、SocketChannel"></a>八、SocketChannel</h2><p>Java NIO中的SocketChannel是一个连接到TCP网络套接字的通道。可以通过以下2种方式创建SocketChannel：</p>
<ol>
<li>打开一个SocketChannel并连接到互联网上的某台服务器。</li>
<li>一个新连接到达ServerSocketChannel时，会创建一个SocketChannel。</li>
</ol>
<h3 id="打开-SocketChannel"><a href="#打开-SocketChannel" class="headerlink" title="打开 SocketChannel"></a>打开 SocketChannel</h3><p>下面是SocketChannel的打开方式：</p>
<pre><code>SocketChannel socketChannel = SocketChannel.open();
socketChannel.connect(new InetSocketAddress(&quot;http://jenkov.com&quot;, 80));</code></pre><h3 id="关闭-SocketChannel"><a href="#关闭-SocketChannel" class="headerlink" title="关闭 SocketChannel"></a>关闭 SocketChannel</h3><p>当用完SocketChannel之后调用<code>SocketChannel.close()</code>关闭SocketChannel：</p>
<pre><code>socketChannel.close();</code></pre><h3 id="从-SocketChannel-读取数据"><a href="#从-SocketChannel-读取数据" class="headerlink" title="从 SocketChannel 读取数据"></a>从 SocketChannel 读取数据</h3><p>要从SocketChannel中读取数据，调用一个<code>read()</code>的方法之一。以下是例子：</p>
<pre><code>ByteBuffer buf = ByteBuffer.allocate(48);
int bytesRead = socketChannel.read(buf);</code></pre><p>首先，分配一个Buffer。从SocketChannel读取到的数据将会放到这个Buffer中。 然后，调用<code>SocketChannel.read()</code>。该方法将数据从SocketChannel 读到Buffer中。read()方法返回的int值表示读了多少字节进Buffer里。如果返回的是-1，表示已经读到了流的末尾（连接关闭了）。</p>
<h3 id="写入-SocketChannel"><a href="#写入-SocketChannel" class="headerlink" title="写入 SocketChannel"></a>写入 SocketChannel</h3><p>写数据到SocketChannel用的是<code>SocketChannel.write()</code>方法，该方法以一个Buffer作为参数。示例如下：</p>
<pre><code>String newData = &quot;New String to write to file...&quot; + System.currentTimeMillis();
ByteBuffer buf = ByteBuffer.allocate(48);
buf.clear();
buf.put(newData.getBytes());
buf.flip();
while(buf.hasRemaining()) {
    channel.write(buf);
}</code></pre><p>注意<code>SocketChannel.write()</code>方法的调用是在一个while循环中的。<code>write()</code>方法无法保证能写多少字节到SocketChannel。所以，我们重复调用<code>write()</code>直到Buffer没有要写的字节为止。</p>
<h3 id="非阻塞模式"><a href="#非阻塞模式" class="headerlink" title="非阻塞模式"></a>非阻塞模式</h3><p>可以设置 SocketChannel 为非阻塞模式（non-blocking mode）.设置之后，就可以在异步模式下调用<code>connect()</code>,<code>read()</code>和<code>write()</code>了。</p>
<h4 id="connect"><a href="#connect" class="headerlink" title="connect()"></a>connect()</h4><p>如果SocketChannel在非阻塞模式下，此时调用<code>connect()</code>，该方法可能在连接建立之前就返回了。为了确定连接是否建立，可以调用<code>finishConnect()</code>的方法。像这样：</p>
<pre><code>socketChannel.configureBlocking(false);
socketChannel.connect(new InetSocketAddress(&quot;http://jenkov.com&quot;, 80));
while(! socketChannel.finishConnect() ){
    //wait, or do something else...    
}</code></pre><h4 id="write"><a href="#write" class="headerlink" title="write()"></a>write()</h4><p>非阻塞模式下，<code>write()</code>方法在尚未写出任何内容时可能就返回了。所以需要在循环中调用<code>write()</code>。前面已经有例子了，这里就不赘述了。</p>
<h4 id="read"><a href="#read" class="headerlink" title="read()"></a>read()</h4><p>非阻塞模式下,<code>read()</code>方法在尚未读取到任何数据时可能就返回了。所以需要关注它的int返回值，它会告诉你读取了多少字节。</p>
<h4 id="非阻塞模式与选择器"><a href="#非阻塞模式与选择器" class="headerlink" title="非阻塞模式与选择器"></a>非阻塞模式与选择器</h4><p>非阻塞模式与选择器搭配会工作的更好，通过将一或多个SocketChannel注册到Selector，可以询问选择器哪个通道已经准备好了读取，写入等。Selector与SocketChannel的搭配使用会在后面详讲。</p>
<hr>
<h2 id="九、ServerSocketChannel"><a href="#九、ServerSocketChannel" class="headerlink" title="九、ServerSocketChannel"></a>九、ServerSocketChannel</h2><p>Java NIO中的 ServerSocketChannel 是一个可以监听新进来的TCP连接的通道, 就像标准IO中的ServerSocket一样。ServerSocketChannel类在<code>java.nio.channels</code>包中。 这里有个例子：</p>
<pre><code>ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();
serverSocketChannel.socket().bind(new InetSocketAddress(9999));
while(true){
    SocketChannel socketChannel =
            serverSocketChannel.accept();
    //do something with socketChannel...
}</code></pre><h3 id="打开-ServerSocketChannel"><a href="#打开-ServerSocketChannel" class="headerlink" title="打开 ServerSocketChannel"></a>打开 ServerSocketChannel</h3><p>通过调用 <code>ServerSocketChannel.open()</code>方法来打开ServerSocketChannel.如：</p>
<pre><code>ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();</code></pre><h3 id="关闭-ServerSocketChannel"><a href="#关闭-ServerSocketChannel" class="headerlink" title="关闭 ServerSocketChannel"></a>关闭 ServerSocketChannel</h3><p>通过调用<code>ServerSocketChannel.close()</code>方法来关闭ServerSocketChannel. 如：</p>
<pre><code>serverSocketChannel.close();</code></pre><h3 id="监听新进来的连接"><a href="#监听新进来的连接" class="headerlink" title="监听新进来的连接"></a>监听新进来的连接</h3><p>通过 <code>ServerSocketChannel.accept()</code>方法监听新进来的连接。当 <code>accept()</code>方法返回的时候,它返回一个包含新进来的连接的 SocketChannel。因此, <code>accept()</code>方法会一直阻塞到有新连接到达。 通常不会仅仅只监听一个连接,在while循环中调用 <code>accept()</code>方法. 如下面的例子：</p>
<pre><code>while(true){
    SocketChannel socketChannel =
            serverSocketChannel.accept();
    //do something with socketChannel...
}</code></pre><p>当然,也可以在while循环中使用除了true以外的其它退出准则。</p>
<h3 id="非阻塞模式-1"><a href="#非阻塞模式-1" class="headerlink" title="非阻塞模式"></a>非阻塞模式</h3><p>ServerSocketChannel可以设置成非阻塞模式。在非阻塞模式下，<code>accept()</code>方法会立刻返回，如果还没有新进来的连接,返回的将是null。 因此，需要检查返回的SocketChannel是否是null.如：</p>
<pre><code>ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();
serverSocketChannel.socket().bind(new InetSocketAddress(9999));
serverSocketChannel.configureBlocking(false);
while(true){
    SocketChannel socketChannel =
            serverSocketChannel.accept();
    if(socketChannel != null){
        //do something with socketChannel...
    }
}</code></pre><hr>
<h2 id="十、DatagramChannel"><a href="#十、DatagramChannel" class="headerlink" title="十、DatagramChannel"></a>十、DatagramChannel</h2><p>Java NIO中的DatagramChannel是一个能收发UDP包的通道。因为UDP是无连接的网络协议，所以不能像其它通道那样读取和写入。它发送和接收的是数据包。</p>
<h3 id="打开-DatagramChannel"><a href="#打开-DatagramChannel" class="headerlink" title="打开 DatagramChannel"></a>打开 DatagramChannel</h3><p>下面是 DatagramChannel 的打开方式：</p>
<pre><code>DatagramChannel channel = DatagramChannel.open();
channel.socket().bind(new InetSocketAddress(9999));</code></pre><p>这个例子打开的 DatagramChannel可以在UDP端口9999上接收数据包。</p>
<h3 id="接收数据"><a href="#接收数据" class="headerlink" title="接收数据"></a>接收数据</h3><p>通过<code>receive()</code>方法从DatagramChannel接收数据，如：</p>
<pre><code>ByteBuffer buf = ByteBuffer.allocate(48);
buf.clear();

channel.receive(buf);</code></pre><p><code>receive()</code>方法会将接收到的数据包内容复制到指定的Buffer. 如果Buffer容不下收到的数据，多出的数据将被丢弃。</p>
<h3 id="发送数据"><a href="#发送数据" class="headerlink" title="发送数据"></a>发送数据</h3><p>通过<code>send()</code>方法从DatagramChannel发送数据，如:</p>
<pre><code>String newData = &quot;New String to write to file...&quot;
                    + System.currentTimeMillis();

ByteBuffer buf = ByteBuffer.allocate(48);
buf.clear();
buf.put(newData.getBytes());
buf.flip();
int bytesSent = channel.send(buf, new InetSocketAddress(&quot;jenkov.com&quot;, 80));</code></pre><p>这个例子发送一串字符到”jenkov.com”服务器的UDP端口80。 因为服务端并没有监控这个端口，所以什么也不会发生。也不会通知你发出的数据包是否已收到，因为UDP在数据传送方面没有任何保证。</p>
<h3 id="连接到特定的地址"><a href="#连接到特定的地址" class="headerlink" title="连接到特定的地址"></a>连接到特定的地址</h3><p>可以将DatagramChannel“连接”到网络中的特定地址的。由于UDP是无连接的，连接到特定地址并不会像TCP通道那样创建一个真正的连接。而是锁住DatagramChannel ，让其只能从特定地址收发数据。 这里有个例子:</p>
<pre><code>channel.connect(new InetSocketAddress(&quot;jenkov.com&quot;, 80));</code></pre><p>当连接后，也可以使用<code>read()</code>和<code>write()</code>方法，就像在用传统的通道一样。只是在数据传送方面没有任何保证。这里有几个例子：</p>
<pre><code>int bytesRead = channel.read(buf);


int bytesWritten = channel.write(but);</code></pre><hr>
<h2 id="十一、Pipe"><a href="#十一、Pipe" class="headerlink" title="十一、Pipe"></a>十一、Pipe</h2><p>Java NIO 管道是2个线程之间的单向数据连接。Pipe有一个source通道和一个sink通道。数据会被写到sink通道，从source通道读取。 这里是Pipe原理的图示： <img data-src="https://cdn.javacodes.cn/files/2017/03/2017-03-14_17-35-14-2.jpg" alt="">￼</p>
<h3 id="创建管道"><a href="#创建管道" class="headerlink" title="创建管道"></a>创建管道</h3><p>通过<code>Pipe.open()</code>方法打开管道。例如：</p>
<pre><code>Pipe pipe = Pipe.open();</code></pre><h3 id="向管道写数据"><a href="#向管道写数据" class="headerlink" title="向管道写数据"></a>向管道写数据</h3><p>要向管道写数据，需要访问sink通道。像这样：</p>
<pre><code>Pipe.SinkChannel sinkChannel = pipe.sink();</code></pre><p>通过调用SinkChannel的<code>write()</code>方法，将数据写入SinkChannel,像这样：</p>
<pre><code>String newData = &quot;New String to write to file...&quot; + System.currentTimeMillis();
ByteBuffer buf = ByteBuffer.allocate(48);
buf.clear();
buf.put(newData.getBytes());
buf.flip();
while(buf.hasRemaining()) {
    sinkChannel.write(buf);
}</code></pre><h3 id="从管道读取数据"><a href="#从管道读取数据" class="headerlink" title="从管道读取数据"></a>从管道读取数据</h3><p>从读取管道的数据，需要访问source通道，像这样：</p>
<pre><code>Pipe.SourceChannel sourceChannel = pipe.source();</code></pre><p>调用source通道的<code>read()</code>方法来读取数据，像这样：</p>
<pre><code>ByteBuffer buf = ByteBuffer.allocate(48);
int bytesRead = sourceChannel.read(buf);</code></pre><p><code>read()</code>方法返回的int值会告诉我们多少字节被读进了缓冲区。</p>
<hr>
<h2 id="十二、NIO与IO"><a href="#十二、NIO与IO" class="headerlink" title="十二、NIO与IO"></a>十二、NIO与IO</h2><p>当学习了Java NIO和IO的API后，一个问题马上涌入脑海： 我应该何时使用IO，何时使用NIO呢？在本文中，我会尽量清晰地解析Java NIO和IO的差异、它们的使用场景，以及它们如何影响您的代码设计。</p>
<h3 id="Java-NIO和IO的主要区别"><a href="#Java-NIO和IO的主要区别" class="headerlink" title="Java NIO和IO的主要区别"></a>Java NIO和IO的主要区别</h3><p>下表总结了Java NIO和IO之间的主要差别，我会更详细地描述表中每部分的差异。</p>
<p>IO</p>
<p>NIO</p>
<p>面向流</p>
<p>面向缓冲</p>
<p>阻塞IO</p>
<p>非阻塞IO</p>
<p>无</p>
<p>选择器</p>
<h3 id="面向流与面向缓冲"><a href="#面向流与面向缓冲" class="headerlink" title="面向流与面向缓冲"></a>面向流与面向缓冲</h3><p>Java NIO和IO之间第一个最大的区别是，IO是面向流的，NIO是面向缓冲区的。 Java IO面向流意味着每次从流中读一个或多个字节，直至读取所有字节，它们没有被缓存在任何地方。此外，它不能前后移动流中的数据。如果需要前后移动从流中读取的数据，需要先将它缓存到一个缓冲区。 Java NIO的缓冲导向方法略有不同。数据读取到一个它稍后处理的缓冲区，需要时可在缓冲区中前后移动。这就增加了处理过程中的灵活性。但是，还需要检查是否该缓冲区中包含所有您需要处理的数据。而且，需确保当更多的数据读入缓冲区时，不要覆盖缓冲区里尚未处理的数据。</p>
<h3 id="阻塞与非阻塞IO"><a href="#阻塞与非阻塞IO" class="headerlink" title="阻塞与非阻塞IO"></a>阻塞与非阻塞IO</h3><p>Java IO的各种流是阻塞的。这意味着，当一个线程调用<code>read()</code>或 <code>write()</code>时，该线程被阻塞，直到有一些数据被读取，或数据完全写入。该线程在此期间不能再干任何事情了。 Java NIO的非阻塞模式，使一个线程从某通道发送请求读取数据，但是它仅能得到目前可用的数据，如果目前没有数据可用时，就什么都不会获取。而不是保持线程阻塞，所以直至数据变的可以读取之前，该线程可以继续做其他的事情。 非阻塞写也是如此。一个线程请求写入一些数据到某通道，但不需要等待它完全写入，这个线程同时可以去做别的事情。 线程通常将非阻塞IO的空闲时间用于在其它通道上执行IO操作，所以一个单独的线程现在可以管理多个输入和输出通道（channel）。</p>
<h3 id="选择器（Selectors）"><a href="#选择器（Selectors）" class="headerlink" title="选择器（Selectors）"></a>选择器（Selectors）</h3><p>Java NIO的选择器允许一个单独的线程来监视多个输入通道，你可以注册多个通道使用一个选择器，然后使用一个单独的线程来“选择”通道：这些通道里已经有可以处理的输入，或者选择已准备写入的通道。这种选择机制，使得一个单独的线程很容易来管理多个通道。</p>
<h3 id="NIO和IO如何影响应用程序的设计"><a href="#NIO和IO如何影响应用程序的设计" class="headerlink" title="NIO和IO如何影响应用程序的设计"></a>NIO和IO如何影响应用程序的设计</h3><p>无论您选择IO或NIO工具箱，可能会影响您应用程序设计的以下几个方面：</p>
<ol>
<li>对NIO或IO类的API调用。</li>
<li>数据处理。</li>
<li>用来处理数据的线程数。</li>
</ol>
<h4 id="API调用"><a href="#API调用" class="headerlink" title="API调用"></a>API调用</h4><p>当然，使用NIO的API调用时看起来与使用IO时有所不同，但这并不意外，因为并不是仅从一个InputStream逐字节读取，而是数据必须先读入缓冲区再处理。</p>
<h4 id="数据处理"><a href="#数据处理" class="headerlink" title="数据处理"></a>数据处理</h4><p>使用纯粹的NIO设计相较IO设计，数据处理也受到影响。 在IO设计中，我们从InputStream或 Reader逐字节读取数据。假设你正在处理一基于行的文本数据流，例如：</p>
<pre><code>Name: Anna
Age: 25
Email: anna@mailserver.com
Phone: 1234567890</code></pre><p>该文本行的流可以这样处理：</p>
<pre><code>InputStream input = ... ; // get the InputStream from the client socket
BufferedReader reader = new BufferedReader(new InputStreamReader(input));
String nameLine = reader.readLine();
String ageLine = reader.readLine();
String emailLine = reader.readLine();
String phoneLine = reader.readLine();</code></pre><p>请注意处理状态由程序执行多久决定。换句话说，一旦<code>reader.readLine()</code>方法返回，你就知道肯定文本行就已读完， readline()阻塞直到整行读完，这就是原因。你也知道此行包含名称；同样，第二个<code>readline()</code>调用返回的时候，你知道这行包含年龄等。 正如你可以看到，该处理程序仅在有新数据读入时运行，并知道每步的数据是什么。一旦正在运行的线程已处理过读入的某些数据，该线程不会再回退数据（大多如此）。下图也说明了这条原则：</p>
<p><img data-src="https://cdn.javacodes.cn/files/2017/03/2017-03-14_17-35-14.jpg" alt="">￼</p>
<p><strong>Java IO: 从一个阻塞的流中读数据</strong></p>
<p>而一个NIO的实现会有所不同，下面是一个简单的例子：</p>
<pre><code>ByteBuffer buffer = ByteBuffer.allocate(48);
int bytesRead = inChannel.read(buffer);</code></pre><p>注意第二行，从通道读取字节到ByteBuffer。当这个方法调用返回时，你不知道你所需的所有数据是否在缓冲区内。你所知道的是，该缓冲区包含一些字节，这使得处理有点困难。 假设第一次<code>read(buffer)</code>调用后，读入缓冲区的数据只有半行，例如，“Name:An”，你能处理数据吗？显然不能，需要等待，直到整行数据读入缓存，在此之前，对数据的任何处理毫无意义。 所以，你怎么知道是否该缓冲区包含足够的数据可以处理呢？好了，你不知道。发现的方法只能查看缓冲区中的数据。其结果是，在你知道所有数据都在缓冲区里之前，你必须检查几次缓冲区的数据。这不仅效率低下，而且可以使程序设计方案杂乱不堪。例如：</p>
<pre><code>ByteBuffer buffer = ByteBuffer.allocate(48);
int bytesRead = inChannel.read(buffer);
while(! bufferFull(bytesRead) ) {
    bytesRead = inChannel.read(buffer);
}</code></pre><p><code>bufferFull()</code>方法必须跟踪有多少数据读入缓冲区，并返回真或假，这取决于缓冲区是否已满。换句话说，如果缓冲区准备好被处理，那么表示缓冲区满了。 <code>bufferFull()</code>方法扫描缓冲区，但必须保持在<code>bufferFull()</code>方法被调用之前状态相同。如果没有，下一个读入缓冲区的数据可能无法读到正确的位置。这是不可能的，但却是需要注意的又一问题。 如果缓冲区已满，它可以被处理。如果它不满，并且在你的实际案例中有意义，你或许能处理其中的部分数据。但是许多情况下并非如此。 下图展示了“缓冲区数据循环就绪”：</p>
<p><img data-src="https://cdn.javacodes.cn/files/2017/03/2017-03-14_17-35-14-4.jpg" alt="">￼</p>
<p><strong>Java NIO:从一个通道里读数据，直到所有的数据都读到缓冲区里</strong></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>NIO可让您只使用一个（或几个）单线程管理多个通道（网络连接或文件），但付出的代价是解析数据可能会比从一个阻塞流中读取数据更复杂。 如果需要管理同时打开的成千上万个连接，这些连接每次只是发送少量的数据，例如聊天服务器，实现NIO的服务器可能是一个优势。同样，如果你需要维持许多打开的连接到其他计算机上，如P2P网络中，使用一个单独的线程来管理你所有出站连接，可能是一个优势。一个线程多个连接的设计方案如下图所示：</p>
<p><img data-src="https://cdn.javacodes.cn/files/2017/03/2017-03-14_17-35-14-1.jpg" alt="">￼</p>
<p><strong>Java NIO: 单线程管理多个连接</strong></p>
<p>如果你有少量的连接使用非常高的带宽，一次发送大量的数据，也许典型的IO服务器实现可能非常契合。下图说明了一个典型的IO服务器设计：</p>
<p><img data-src="https://cdn.javacodes.cn/files/2017/03/2017-03-14_17-35-15.jpg" alt="">￼</p>
<p><strong>Java IO: 一个典型的IO服务器设计- 一个连接通过一个线程处理</strong></p>
]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>NIO</tag>
      </tags>
  </entry>
  <entry>
    <title>Java中的Copy-On-Write容器</title>
    <url>/2017/03/15/Java%E4%B8%AD%E7%9A%84Copy-On-Write%E5%AE%B9%E5%99%A8/</url>
    <content><![CDATA[<p>Copy-On-Write简称COW，是一种用于程序设计中的优化策略。其基本思路是，从一开始大家都在共享同一个内容，当某个人想要修改这个内容的时候，才会真正把内容Copy出去形成一个新的内容然后再改，这是一种延时懒惰策略。从JDK1.5开始Java并发包里提供了两个使用CopyOnWrite机制实现的并发容器,它们是CopyOnWriteArrayList和CopyOnWriteArraySet。CopyOnWrite容器非常有用，可以在非常多的并发场景中使用到。</p>
<a id="more"></a>

<h2 id="什么是CopyOnWrite容器"><a href="#什么是CopyOnWrite容器" class="headerlink" title="什么是CopyOnWrite容器"></a>什么是CopyOnWrite容器</h2><p>CopyOnWrite容器即写时复制的容器。通俗的理解是当我们往一个容器添加元素的时候，不直接往当前容器添加，而是先将当前容器进行Copy，复制出一个新的容器，然后新的容器里添加元素，添加完元素之后，再将原容器的引用指向新的容器。这样做的好处是我们可以对CopyOnWrite容器进行并发的读，而不需要加锁，因为当前容器不会添加任何元素。所以CopyOnWrite容器也是一种读写分离的思想，读和写不同的容器。</p>
<h2 id="CopyOnWriteArrayList的实现原理"><a href="#CopyOnWriteArrayList的实现原理" class="headerlink" title="CopyOnWriteArrayList的实现原理"></a>CopyOnWriteArrayList的实现原理</h2><p>在使用CopyOnWriteArrayList之前，我们先阅读其源码了解下它是如何实现的。以下代码是向ArrayList里添加元素，可以发现在添加的时候是需要加锁的，否则多线程写的时候会Copy出N个副本出来。</p>
<pre><code>public boolean add(T e) {
    final ReentrantLock lock = this.lock;
    lock.lock();
    try {

        Object[] elements = getArray();

        int len = elements.length;
        // 复制出新数组

        Object[] newElements = Arrays.copyOf(elements, len + 1);
        // 把新元素添加到新数组里

        newElements[len] = e;
        // 把原数组引用指向新数组

        setArray(newElements);

        return true;

    } finally {

        lock.unlock();

    }

}

final void setArray(Object[] a) {
    array = a;
}</code></pre><p>读的时候不需要加锁，如果读的时候有多个线程正在向ArrayList添加数据，读还是会读到旧的数据，因为写的时候不会锁住旧的ArrayList。</p>
<pre><code>public E get(int index) {
    return get(getArray(), index);
}</code></pre><p>JDK中并没有提供CopyOnWriteMap，我们可以参考CopyOnWriteArrayList来实现一个，基本代码如下：</p>
<pre><code>import java.util.Collection;
import java.util.Map;
import java.util.Set;

public class CopyOnWriteMap&lt;K, V&gt; implements Map&lt;K, V&gt;, Cloneable {
    private volatile Map&lt;K, V&gt; internalMap;

    public CopyOnWriteMap() {
        internalMap = new HashMap&lt;K, V&gt;();
    }

    public V put(K key, V value) {

        synchronized (this) {
            Map&lt;K, V&gt; newMap = new HashMap&lt;K, V&gt;(internalMap);
            V val = newMap.put(key, value);
            internalMap = newMap;
            return val;
        }
    }

    public V get(Object key) {
        return internalMap.get(key);
    }

    public void putAll(Map&lt;? extends K, ? extends V&gt; newData) {
        synchronized (this) {
            Map&lt;K, V&gt; newMap = new HashMap&lt;K, V&gt;(internalMap);
            newMap.putAll(newData);
            internalMap = newMap;
        }
    }
}</code></pre><p>实现很简单，只要了解了CopyOnWrite机制，我们可以实现各种CopyOnWrite容器，并且在不同的应用场景中使用。</p>
<h2 id="CopyOnWrite的应用场景"><a href="#CopyOnWrite的应用场景" class="headerlink" title="CopyOnWrite的应用场景"></a>CopyOnWrite的应用场景</h2><p>CopyOnWrite并发容器用于读多写少的并发场景。比如白名单，黑名单，商品类目的访问和更新场景，假如我们有一个搜索网站，用户在这个网站的搜索框中，输入关键字搜索内容，但是某些关键字不允许被搜索。这些不能被搜索的关键字会被放在一个黑名单当中，黑名单每天晚上更新一次。当用户搜索时，会检查当前关键字在不在黑名单当中，如果在，则提示不能搜索。实现代码如下：</p>
<pre><code>package com.ifeve.book;

import java.util.Map;

import com.ifeve.book.forkjoin.CopyOnWriteMap;

/**
 * 黑名单服务
 *
 * @author fangtengfei
 *
 */
public class BlackListServiceImpl {

    private static CopyOnWriteMap&lt;String, Boolean&gt; blackListMap = new CopyOnWriteMap&lt;String, Boolean&gt;(
            1000);

    public static boolean isBlackList(String id) {
        return blackListMap.get(id) == null ? false : true;
    }

    public static void addBlackList(String id) {
        blackListMap.put(id, Boolean.TRUE);
    }

    /**
     * 批量添加黑名单
     *
     * @param ids
     */
    public static void addBlackList(Map&lt;String,Boolean&gt; ids) {
        blackListMap.putAll(ids);
    }

}</code></pre><p>代码很简单，但是使用CopyOnWriteMap需要注意两件事情：</p>
<ol>
<li>减少扩容开销。根据实际需要，初始化CopyOnWriteMap的大小，避免写时CopyOnWriteMap扩容的开销。</li>
<li>使用批量添加。因为每次添加，容器每次都会进行复制，所以减少添加次数，可以减少容器的复制次数。如使用上面代码里的addBlackList方法。</li>
</ol>
<h2 id="CopyOnWrite的缺点"><a href="#CopyOnWrite的缺点" class="headerlink" title="CopyOnWrite的缺点"></a>CopyOnWrite的缺点</h2><p>CopyOnWrite容器有很多优点，但是同时也存在两个问题，即内存占用问题和数据一致性问题。所以在开发的时候需要注意一下。</p>
<ul>
<li><strong>内存占用问题</strong>：因为CopyOnWrite的写时复制机制，所以在进行写操作的时候，内存里会同时驻扎两个对象的内存，旧的对象和新写入的对象（注意:在复制的时候只是复制容器里的引用，只是在写的时候会创建新对象添加到新容器里，而旧容器的对象还在使用，所以有两份对象内存）。如果这些对象占用的内存比较大，比如说200M左右，那么再写入100M数据进去，内存就会占用300M，那么这个时候很有可能造成频繁的Yong GC和Full GC。之前我们系统中使用了一个服务由于每晚使用CopyOnWrite机制更新大对象，造成了每晚15秒的Full GC，应用响应时间也随之变长。</li>
</ul>
<p>针对内存占用问题，可以通过压缩容器中的元素的方法来减少大对象的内存消耗，比如，如果元素全是10进制的数字，可以考虑把它压缩成36进制或64进制。或者不使用CopyOnWrite容器，而使用其他的并发容器，如ConcurrentHashMap。</p>
<ul>
<li><strong>数据一致性问题</strong>：CopyOnWrite容器只能保证数据的最终一致性，不能保证数据的实时一致性。所以如果你希望写入的的数据，马上能读到，请不要使用CopyOnWrite容器。</li>
</ul>
<p>关于C++的STL中，曾经也有过Copy-On-Write的玩法，参见陈皓的《C++ STL String类中的Copy-On-Write》，后来，因为有很多线程安全上的事，就被去掉了。</p>
<blockquote>
<p>转载自<a href="http://ifeve.com/" target="_blank" rel="noopener">并发编程网 – ifeve.com</a> 本文链接地址: <a href="http://ifeve.com/java-copy-on-write/" target="_blank" rel="noopener">聊聊并发-Java中的Copy-On-Write容器</a></p>
</blockquote>
]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>并发</tag>
        <tag>CopyOnWrite</tag>
      </tags>
  </entry>
  <entry>
    <title>Java加解密与数字签名</title>
    <url>/2016/09/07/Java%E5%8A%A0%E8%A7%A3%E5%AF%86%E4%B8%8E%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D/</url>
    <content><![CDATA[<blockquote>
<p>本文转载自：QQ兴趣部落：<strong>java学习（部落）</strong> <a href="http://buluo.qq.com/p/detail.html?bid=11148&pid=1064765-1472376406&from=share_qq" target="_blank" rel="noopener">原文地址：点击访问</a></p>
</blockquote>
<p>实现方式：JDK实现，CC，BC JDK提供比较基础的底层的实现；CC提供一些简化的操作；BC提供补充 <strong>一、Base64加密</strong> 非常简单，加密解密就一个函数。 </p>
<a id="more"></a>

<p>代码如下： <img data-src="https://cdn.javacodes.cn/files/2016/09/2016-09-07_07-42-49.jpg" alt=""> <strong>二、消息摘要算法加密————主要用于验证数据完整性。</strong> MD（消息摘要）： <img data-src="https://cdn.javacodes.cn/files/2016/09/2016-09-07_07-43-58.jpg" alt=""> SHA（安全散列） JDK实现和MD一样。 BC实现如下：（Digest类） <img data-src="https://cdn.javacodes.cn/files/2016/09/2016-09-07_07-45-09.jpg" alt=""> CC实现最简单（就是一个DigestUtils的静态方法）： <img data-src="https://cdn.javacodes.cn/files/2016/09/2016-09-07_07-46-13.png" alt=""> MAC（消息认证码）——含有密钥的散列函数算法 兼容MD和SHA的特性，但加入了密钥。 主要JDK和Bouncy Castle实现。 JDK实现：获取或定义密钥（byte[]数组），Mac类 实例化、初始化、执行。 BC实现：Hmac类 实例化、初始化、执行。 *<em>三、对称加解密 *</em> 对称加密指加密和解密使用相同密钥的加密算法。这里将介绍DES、3重DES、AES和PBE几种常见的对称加密算法在Java中的实现。 DES、3DES、AES（密钥）、PBE（口令和盐） DES： JDK实现：生成并转换Key；Cipher类的实例化（getInstance）、初始化（init选择模式与Key）；执行（doFinal）加解密。 推荐BC实现方式：Security.addProvider(new BouncyCastleProvider()); 然后剩下的代码就可以和JDK实现代码基本一样了。 3DES、AES实现基本一样，所以就不一一介绍。。。 PBE（基于口令的加密） 特点：通过 salt + 口令 实现：初始化盐；生成口令；Cipher类加解密。 *<em>四、非对称加解密 *</em> 非对称加密算法是一种基于密钥的保密方法，需要公开密钥和私有密钥，在文件加密、尤其是网银中应用广泛。这里主要介绍非对称加密算法的实现过程，DH、RSA和ELGamal等几种常见的非对称加密算法的在Java中的应用。 概念：公钥、私钥； DH(密钥交换算法)： 代码实现有些麻烦 ——初始化发送方密钥 -KeyPairGenerator ：能产生KeyPair -KeyPair ：常用的密钥载体，称为密钥对，分为公钥PublicKey与私钥PrivateKey。 -PublicKey ——初始化接收方密钥 -KeyFactory ：密钥工厂，生成密钥，通过某种密钥的规范来还原密钥 -X509EncodedKeySpec ：根据ASN.1进行密钥编码 -DHPublicKey ： -DHParameterSpec ：遵从DH算法发参数的集合 -KeyPairGenerator ： -PrivateKey ： ——双发根据公布的对方的PublicKey构建本地密钥， ——构建出来的本地密钥是一致的 -KeyAgreement ：用来提供密钥一致性协议 -SecretKey ：秘密密钥，对称 -KeyFactory -X509EncodedKeySpec -PublicKey ——加密、解密（利用本地密钥） -Cipher ：为加密和解密提供密码功能的类 <img data-src="https://cdn.javacodes.cn/files/2016/09/2016-09-07_07-47-25.jpg" alt=""> 解释： 首先，发送方产生密钥对，并公开 公钥；接收方根据这个公钥产生密钥对，然后也公开自己的 公钥。 然后，发送方根据接收方的 公钥 产生自己本地的密钥（本地密钥一般是采用对称密钥），接收方也根据发送方的 公钥 产生自己本地的密钥。其实，这样双方产生的本地密钥是相同的。 最后，双方就可以利用本地密钥进行加解密了。 RSA（基于因子分解）：代码实现较为简单 初始化密钥（包含公钥、密钥）。 可以利用公钥加密，私钥解密；也可以私钥加密，公钥解密 使用过程：双方分别掌握公钥与私钥中的一种，然后就可以加密并传输数据了。 <img data-src="https://cdn.javacodes.cn/files/2016/09/2016-09-07_07-48-36.jpg" alt=""> <img data-src="https://cdn.javacodes.cn/files/2016/09/2016-09-07_07-49-48.jpg" alt=""> <img data-src="https://cdn.javacodes.cn/files/2016/09/2016-09-07_07-50-57.jpg" alt=""> EIGamal（基于离散因数） JDK没有实现，只能利用BC实现。 首先，Security.addProvider(new BouncyCastleProvider()); 之后实现类似于RSA。 <img data-src="https://cdn.javacodes.cn/files/2016/09/2016-09-07_07-52-07.jpg" alt=""> 五．Java实现数字签名 数字签名用于鉴别数字信息，公钥和私钥，私钥对数据签名，公钥用于检验。 过程为：首先初始化一个密钥对，在密钥对的基础上进行签名与验证。 1、RSA：既可以加解密，也可以数字签名。 初始化密钥对：KeyPairGenerator、KeyPair、RSAPublic、PSAPrivate； 执行签名；Signature类 验证签名；Signature类 2、DSA（数字签名算法） 初始化密钥对，公钥、私钥； 执行签名，用私钥签名； 验证签名，用公钥验证； 3、ECDSA 微软序列号便是采用的ECDSA算法进行的签名。速度快，强度高，签名短。 初始化密钥对； 执行签名； 验证签名</p>
]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>加解密</tag>
        <tag>数字签名</tag>
      </tags>
  </entry>
  <entry>
    <title>Java垃圾回收机制（GC）</title>
    <url>/2017/03/11/Java%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%EF%BC%88GC%EF%BC%89/</url>
    <content><![CDATA[<h3 id="判断对象是否可回收的常见方法"><a href="#判断对象是否可回收的常见方法" class="headerlink" title="判断对象是否可回收的常见方法"></a>判断对象是否可回收的常见方法</h3><h4 id="引用计数算法（Reference-Counting）"><a href="#引用计数算法（Reference-Counting）" class="headerlink" title="引用计数算法（Reference Counting）"></a>引用计数算法（Reference Counting）</h4><p>给对象中添加一个引用计数器，每当有一个地方引用时，计数器加1；当引用失效时，计数器减1；任何时刻计数器为0的对象就是不可能再被使用的。</p>
<ul>
<li><p>优点：实现简单，判定效率高；</p>
</li>
<li><p>缺点：很难解决对象之间的循环引用问题；</p>
</li>
</ul>
<p>JVM并不使用这种算法。</p>
<a id="more"></a>

<h4 id="可达性分析算法（Reachability-Analysis）"><a href="#可达性分析算法（Reachability-Analysis）" class="headerlink" title="可达性分析算法（Reachability Analysis）"></a>可达性分析算法（Reachability Analysis）</h4><p>通过一些列称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径叫做引用链，当一个对象到GC Roots没有任何引用链与之相连时，则证明该对象是不可用的。 <img data-src="https://cdn.javacodes.cn/files/2017/03/2017-03-11_12-38-18.png" alt=""></p>
<p>在Java语言中，可作为GC Roots的对象包括：</p>
<ul>
<li><p>虚拟机栈（栈帧中的本地变量表）中引用的对象；</p>
</li>
<li><p>方法区中静态属性引用的对象；</p>
</li>
<li><p>方法区中常量引用的对象；</p>
</li>
<li><p>本地方法栈中JNI（Native方法）引用的对象；</p>
</li>
</ul>
<h4 id="二次标记"><a href="#二次标记" class="headerlink" title="二次标记"></a>二次标记</h4><p>如果一个对象真正宣告“死亡”，至少要经过两次标记过程：</p>
<ul>
<li><p>如果一个对象经过可达性分析算法判定为可回收对象，则它将会被第一次标记并进行一次筛选，筛选的条件是判断该对象是否有必要执行finalize()方法。当对象没有覆盖finalize()方法或者已经执行过一次finalize()方法，则虚拟将将判定为“没有必要执行”。如果判定为“有必要执行finalize()方法”，那么这个对象将被置入F-Queue队列，并在稍后由一个虚拟机自动建立的、低优先级的Finalizer线程区执行（仅仅是触发）它。</p>
</li>
<li><p>finalize()方法是逃脱死亡的最后机会，稍后GC将堆F-Queue队列进行再一次的小规模标记，如果对象在finalize()方法中重新与引用链上的任何一个对象建立关联，那么在第二次标记的时候将会被移除“即将回收”的集合；如果对象这时候还没有逃脱，那么基本上对象宣告“死亡”并将被回收。</p>
</li>
</ul>
<h3 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h3><h4 id="标记-清除算法（Mark-Sweep）"><a href="#标记-清除算法（Mark-Sweep）" class="headerlink" title="标记-清除算法（Mark-Sweep）"></a>标记-清除算法（Mark-Sweep）</h4><p><img data-src="https://cdn.javacodes.cn/files/2017/03/2017-03-11_12-38-20.png" alt=""></p>
<p>算法分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收掉所有被标记的对象。 <img data-src="https://cdn.javacodes.cn/files/2017/03/2017-03-11_12-38-21.png" alt=""> 主要缺点：</p>
<ul>
<li>效率问题，标记和清除过程的<strong>效率都不高</strong>；</li>
<li>空间问题，标记清除之后会产生大量<strong>不连续的内存碎片</strong>，空间碎片太多可能会导致，当程序在以后的运行过程中需要分配较大对象时无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作；</li>
</ul>
<h4 id="复制算法（Copying）"><a href="#复制算法（Copying）" class="headerlink" title="复制算法（Copying）"></a>复制算法（Copying）</h4><p>它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。</p>
<p><img data-src="https://cdn.javacodes.cn/files/2017/03/2017-03-11_12-38-21-1.png" alt=""></p>
<p>这样使得每次都是对其中的一块进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。只是这种算法的代价是将内存缩小为原来的一半，未免太高了一点。</p>
<p><img data-src="https://cdn.javacodes.cn/files/2017/03/2017-03-11_12-38-22.png" alt=""></p>
<p>现在的商业虚拟机都采用这种收集算法来<strong>回收新生代</strong>，新生代中的对象98%是朝生夕死的，所以并不需要按照1∶1的比例来划分内存空间，而是将内存分为<strong>一块较大的Eden空间</strong>和<strong>两块较小的Survivor空间</strong>，每次使用Eden和其中的一块Survivor。</p>
<p>当回收时，将Eden和Survivor中还存活着的对象一次性地拷贝到另外一块Survivor空间上，最后清理掉Eden和刚才用过的Survivor的空间。HotSpot虚拟机默认Eden和Survivor的大小比例是8∶1，也就是每次新生代中可用内存空间为整个新生代容量的90%（80%+10%），只有10%的内存是会被“浪费”的。</p>
<p>当然，98%的对象可回收只是一般场景下的数据，我们没有办法保证每次回收都只有不多于10%的对象存活，当Survivor空间不够用时，需要依赖其他内存（这里指老年代）进行分配担保（Handle Promotion）。如果另外一块Survivor空间没有足够的空间存放上一次新生代收集下来的存活对象，这些对象将直接通过分配担保机制进入老年代。</p>
<h4 id="标记整理算法（Mark-Compact）"><a href="#标记整理算法（Mark-Compact）" class="headerlink" title="标记整理算法（Mark-Compact）"></a>标记整理算法（Mark-Compact）</h4><p>复制收集算法在对象存活率较高时就要执行较多的复制操作，效率将会变低。更关键的是，如果不想浪费50%的空间，就需要有额外的空间进行分配担保，以应对被使用的内存中所有对象都100%存活的极端情况，所以在老年代一般不能直接选用这种算法。</p>
<p><img data-src="https://cdn.javacodes.cn/files/2017/03/2017-03-11_12-38-23.png" alt=""></p>
<p>根据<strong>老年代</strong>的特点，有人提出了另外一种“<strong>标记-整理</strong>”（Mark-Compact）算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。</p>
<p><img data-src="https://cdn.javacodes.cn/files/2017/03/2017-03-11_12-38-24.png" alt=""></p>
<h4 id="分代收集算法（Generational-Collection）"><a href="#分代收集算法（Generational-Collection）" class="headerlink" title="分代收集算法（Generational Collection）"></a>分代收集算法（Generational Collection）</h4><p>当前商业虚拟机的垃圾收集都采用“分代收集”（Generational Collection）算法，这种算法并没有什么新的思想，只是根据对象的存活周期的不同将内存划分为几块。 一般是把Java堆分为<strong>新生代</strong>和<strong>老年代</strong>，这样就可以根据各个年代的特点采用最适当的收集算法。</p>
<ul>
<li><p>新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。</p>
</li>
<li><p>老年代中，因为对象存活率高、没有额外空间对它进行分配担保，就必须使用“标记-清理”或“标记-整理”算法来进行回收。</p>
</li>
</ul>
<h3 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h3><p>Java虚拟机规范中对垃圾收集器应该如何实现并没有任何规定，因此不同的厂商、不同版本的虚拟机所提供的垃圾收集器都可能会有很大的差别，并且一般都会提供参数供用户根据自己的应用特点和要求组合出各个年代所使用的收集器。</p>
<ul>
<li><p><strong>Serial收集器（复制算法)：</strong>新生代单线程收集器，标记和清理都是单线程，优点是简单高效。</p>
</li>
<li><p><strong>Serial Old收集器(标记-整理算法)：</strong>老年代单线程收集器，Serial收集器的老年代版本。</p>
</li>
<li><p><strong>ParNew收集器(停止-复制算法)：</strong>新生代收集器，可以认为是Serial收集器的多线程版本,在多核CPU环境下有着比Serial更好的表现。</p>
</li>
<li><p><strong>Parallel Scavenge收集器(停止-复制算法)：</strong>并行收集器，追求高吞吐量，高效利用CPU。吞吐量一般为99%， 吞吐量= 用户线程时间/(用户线程时间+GC线程时间)。适合后台应用等对交互相应要求不高的场景。</p>
</li>
<li><p><strong>Parallel Old收集器(停止-复制算法)：</strong>Parallel Scavenge收集器的老年代版本，并行收集器，吞吐量优先</p>
</li>
<li><p><strong>CMS(Concurrent Mark Sweep)收集器（标记-清理算法）**</strong>：**高并发、低停顿，追求最短GC回收停顿时间，cpu占用比较高，响应时间快，停顿时间短，多核cpu 追求高响应时间的选择</p>
<p><img data-src="https://cdn.javacodes.cn/files/2017/03/2017-03-11_12-38-24-1.png" alt=""></p>
</li>
</ul>
<h4 id="1-Serial-Garbage-Collector"><a href="#1-Serial-Garbage-Collector" class="headerlink" title="1. Serial Garbage Collector"></a>1. Serial Garbage Collector</h4><p>Serial Garbage Collector通过暂停所有应用的线程来工作。它是为单线程工作环境而设计的。它中使用一个线程来进行垃圾回收。这种暂停应用线程来进行垃圾回收的方式可能不太适应服务器环境。它最适合简单的命令行程序。通过 -XX:+UseSerialGC 参数来选用Serial Garbage Collector。</p>
<h4 id="2-Parallel-Garbage-Collector"><a href="#2-Parallel-Garbage-Collector" class="headerlink" title="2. Parallel Garbage Collector"></a>2. Parallel Garbage Collector</h4><p>Parallel Garbage Collector也被称为吞吐量收集器（throughput collector）。它是Java虚拟机的默认垃圾收集器。与Serial Garbage Collector不同，Parallel Garbage Collector使用多个线程进行垃圾回收。与Serial Garbage Collector相似的地方时，它也是暂停所有的应用线程来进行垃圾回收。</p>
<h4 id="3-CMS-Garbage-Collector"><a href="#3-CMS-Garbage-Collector" class="headerlink" title="3. CMS Garbage Collector"></a>3. CMS Garbage Collector</h4><p>Concurrent Mark Sweep (CMS) Garbage Collector使用多个线程来扫描堆内存来标记需要回收的实例，然后再清除被标记的实例。CMS Garbage Collector只有在如下两种情景才会暂停所有的应用线程：</p>
<ul>
<li>当标记永久代内存空间中的对象时；</li>
<li>当进行垃圾回收时，堆内存同步发生了一些变化。</li>
</ul>
<p>相比Parallel Garbage Collector，CMS Garbage Collector使用更多的CPU资源来确保应用有一个更好的吞吐量。如果分配更多的CPU资源可以获得更好的性能，那么CMS Garbage Collector是一个更好的选择。 通过 XX:+USeParNewGC 参数来选用CMS Garbage Collector。</p>
<h4 id="4-G1-Garbage-Collector"><a href="#4-G1-Garbage-Collector" class="headerlink" title="4. G1 Garbage Collector"></a>4. G1 Garbage Collector</h4><p>G1 Garbage Collector用于大的堆内存区域。它将堆内存分割成多个独立区域（Region），然后并发地对它们进行垃圾回收。在释放内存后，G1还可以压缩空闲的堆内存。但是，CMS Garbage Collector是通过“Stop The World (STW)”来进行内存压缩的。G1优先收集可回收更多内存的区域。Java 8 的改进：在用G1 Garbage Collector时，可以开启 -XX:+UseStringDeduplication 参数。它通过将重复的字符串移动到同一个 char 数组中来优化堆内存的使用。该选项在Java 8u20时引用进来。 通过 –XX:+UseG1GC 参数来选用G1 Garbage Collector。</p>
<h3 id="Java虚拟机中的垃圾回收选项配置"><a href="#Java虚拟机中的垃圾回收选项配置" class="headerlink" title="Java虚拟机中的垃圾回收选项配置"></a>Java虚拟机中的垃圾回收选项配置</h3><p>下面是与Java收集器相关的Java虚拟机选项。</p>
<h4 id="垃圾收集器选择"><a href="#垃圾收集器选择" class="headerlink" title="垃圾收集器选择"></a>垃圾收集器选择</h4><p><strong>Option</strong></p>
<p><strong>Description</strong></p>
<p>-XX:+UseSerialGC</p>
<p>Serial Garbage Collector</p>
<p>-XX:+UseParallelGC</p>
<p>Parallel Garbage Collector</p>
<p>-XX:+UseConcMarkSweepGC</p>
<p>CMS Garbage Collector</p>
<p>-XX:ParallelCMSThreads=</p>
<p>CMS Collector – 使用的线程数</p>
<p>-XX:+UseG1GC</p>
<p>G1 Gargbage Collector</p>
<h4 id="垃圾回收优化选项"><a href="#垃圾回收优化选项" class="headerlink" title="垃圾回收优化选项"></a>垃圾回收优化选项</h4><p><strong>Option</strong></p>
<p><strong>Description</strong></p>
<p>-Xms</p>
<p>堆内存初始化尺寸</p>
<p>-Xmx</p>
<p>堆内存最大尺寸</p>
<p>-Xmn</p>
<p>新生代（Young Generation）的尺寸</p>
<p>-XX:PermSize</p>
<p>永久代（Permanent Generation）初始化尺寸</p>
<p>-XX:MaxPermSize</p>
<p>永久代（Permanent Generation）最大尺寸</p>
]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
        <tag>GC</tag>
        <tag>垃圾回收</tag>
      </tags>
  </entry>
  <entry>
    <title>Java实现数据统计的常用算法</title>
    <url>/2016/09/27/Java%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E7%BB%9F%E8%AE%A1%E7%9A%84%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>做数据处理的人可能经常用到一些比如求中位数、众数、均值等等的常用数学方法，下面整理一些算法，由于都比较简单，不做过多的解释了，直接拿去用就好啦！</p>
<a id="more"></a>

<p>package cn.javacodes.utils;</p>
<p>import java.util.Arrays;<br>import java.util.HashMap;<br>import java.util.Iterator;<br>import java.util.Map;</p>
<p>/**<br> * 数据统计工具类<br> * @author 胡湛霏<br> * @since 2016-09-27<br> <em>/<br>public class DataStatisticsUtils {<br>    /*\</em><br>     * 求和<br>     *<br>     * @param arr<br>     * @return<br>     */<br>    public static double getSum(double[] arr) {<br>        double sum = 0;<br>        for (double num : arr) {<br>            sum += num;<br>        }<br>        return sum;<br>    }</p>
<pre><code>/\*\*
 \* 求均值
 \*
 \* @param arr
 \* @return
 */
public static double getMean(double\[\] arr) {
    return getSum(arr) / arr.length;
}

/\*\*
 \* 求众数
 \*
 \* @param arr
 \* @return
 */
public static double getMode(double\[\] arr) {
    Map&lt;Double, Integer&gt; map = new HashMap&lt;Double, Integer&gt;();
    for (int i = 0; i &lt; arr.length; i++) {
        if (map.containsKey(arr\[i\])) {
            map.put(arr\[i\], map.get(arr\[i\]) + 1);
        } else {
            map.put(arr\[i\], 1);
        }
    }
    int maxCount = 0;
    double mode = -1;
    Iterator&lt;Double&gt; iter = map.keySet().iterator();
    while (iter.hasNext()) {
        double num = iter.next();
        int count = map.get(num);
        if (count &gt; maxCount) {
            maxCount = count;
            mode = num;
        }
    }
    return mode;
}

/\*\*
 \* 求中位数
 \*
 \* @param arr
 \* @return
 */
public static double getMedian(double\[\] arr) {
    double\[\] tempArr = Arrays.copyOf(arr, arr.length);
    Arrays.sort(tempArr);
    if (tempArr.length % 2 == 0) {
        return (tempArr\[tempArr.length &gt;&gt; 1\] + tempArr\[(tempArr.length &gt;&gt; 1) - 1\]) / 2;
    } else {
        return tempArr\[(tempArr.length &gt;&gt; 1)\];
    }
}


/\*\*
 \* 求中列数
 \*
 \* @param arr
 \* @return
 */
public static double getMidrange(double\[\] arr) {
    double max = arr\[0\], min = arr\[0\];
    for (int i = 0; i &lt; arr.length; i++) {
        if (arr\[i\] &gt; max) {
            max = arr\[i\];
        }
        if (arr\[i\] &lt; min) {
            min = arr\[i\];
        }
    }
    return (min + max) / 2;
}

/\*\*
 \* 求四分位数
 \*
 \* @param arr
 \* @return 存放三个四分位数的数组
 */
public static double\[\] getQuartiles(double\[\] arr) {
    double\[\] tempArr = Arrays.copyOf(arr, arr.length);
    Arrays.sort(tempArr);
    double\[\] quartiles = new double\[3\];
    // 第二四分位数（中位数）
    quartiles\[1\] = getMedian(tempArr);
    // 求另外两个四分位数
    if (tempArr.length % 2 == 0) {
        quartiles\[0\] = getMedian(Arrays.copyOfRange(tempArr, 0, tempArr.length / 2));
        quartiles\[2\] = getMedian(Arrays.copyOfRange(tempArr, tempArr.length / 2, tempArr.length));
    } else {
        quartiles\[0\] = getMedian(Arrays.copyOfRange(tempArr, 0, tempArr.length / 2));
        quartiles\[2\] = getMedian(Arrays.copyOfRange(tempArr, tempArr.length / 2 + 1, tempArr.length));
    }
    return quartiles;
}

/\*\*
 \* 求极差
 \*
 \* @param arr
 \* @return
 */
public static double getRange(double\[\] arr) {
    double max = arr\[0\], min = arr\[0\];
    for (int i = 0; i &lt; arr.length; i++) {
        if (arr\[i\] &gt; max) {
            max = arr\[i\];
        }
        if (arr\[i\] &lt; min) {
            min = arr\[i\];
        }
    }
    return max - min;
}

/\*\*
 \* 求四分位数极差
 \*
 \* @param arr
 \* @return
 */
public static double getQuartilesRange(double\[\] arr) {
    return getRange(getQuartiles(arr));
}

/\*\*
 \* 求截断均值
 \*
 \* @param arr 求值数组
 \* @param p   截断量p，例如p的值为20，则截断20%（高10%，低10%）
 \* @return
 */
public static double getTrimmedMean(double\[\] arr, int p) {
    int tmp = arr.length * p / 100;
    double\[\] tempArr = Arrays.copyOfRange(arr, tmp, arr.length + 1 - tmp);
    return getMean(tempArr);
}

/\*\*
 \* 求方差
 \*
 \* @param arr
 \* @return
 */
public static double getVariance(double\[\] arr) {
    double variance = 0;
    double sum = 0, sum2 = 0;
    for (int i = 0; i &lt; arr.length; i++) {
        sum += arr\[i\];
        sum2 += arr\[i\] * arr\[i\];
    }
    variance = sum2 / arr.length - (sum / arr.length) * (sum / arr.length);
    return variance;
}

/\*\*
 \* 求绝对平均偏差(AAD)
 \*
 \* @param arr
 \* @return
 */
public static double getAbsoluteAverageDeviation(double\[\] arr) {
    double sum = 0;
    double mean = getMean(arr);
    for (int i = 0; i &lt; arr.length; i++) {
        sum += Math.abs(arr\[i\] - mean);
    }
    return sum / arr.length;
}

/\*\*
 \* 求中位数绝对偏差(MAD)
 \*
 \* @param arr
 \* @return
 */
public static double getMedianAbsoluteDeviation(double\[\] arr) {
    double\[\] tempArr = new double\[arr.length\];
    double median = getMedian(arr);
    for (int i = 0; i &lt; arr.length; i++) {
        tempArr\[i\] = Math.abs(arr\[i\] - median);
    }
    return getMedian(tempArr);
}

/\*\*
 \* 求标准差
 \* @param arr
 \* @return
 */
public static double getStandardDevition(double\[\] arr) {
    double sum = 0;
    double mean = getMean(arr);
    for (int i = 0; i &lt; arr.length; i++) {
        sum += Math.sqrt((arr\[i\] - mean) * (arr\[i\] - mean));
    }
    return (sum / (arr.length - 1));
}</code></pre><p>}</p>
<p>下面还有一些做数据规范化的代码整理：</p>
<p>package cn.javacodes.utils;</p>
<p>import java.util.Arrays;</p>
<p>/**<br> * 数据变化-规范化工具类<br> * @author 胡湛霏<br> * @since 2016-09-27<br> */<br>public class DataConversionUtils {</p>
<pre><code>/\*\*
 \* 最小\-最大规范化
 \*
 \* @param arr
 \* @return 规范化后的数组
 */
public static double\[\] minMaxNormalize(double\[\] arr) {
    // 拷贝数组
    double\[\] tempArr = Arrays.copyOf(arr, arr.length);
    // 找到最大值和最小值
    double max = tempArr\[0\], min = tempArr\[0\];
    for (int i = 0; i &lt; tempArr.length; i++) {
        if (tempArr\[i\] &gt; max) {
            max = tempArr\[i\];
        }
        if (tempArr\[i\] &lt; min) {
            min = tempArr\[i\];
        }
    }
    // 规范化
    for (int i = 0; i &lt; tempArr.length; i++) {
        tempArr\[i\] = (tempArr\[i\] - min) / (max - min);
    }
    return tempArr;
}


/\*\*
 \* Z-score规范化
 \* @param arr
 \* @return 规范化后的数组
 */
public static double\[\] zScoreNormalize(double\[\] arr) {
    // 拷贝数组
    double\[\] tempArr = Arrays.copyOf(arr, arr.length);
    // 求均值
    double sum = 0;
    for (double num : tempArr) {
        sum += num;
    }
    double mean = sum / tempArr.length;
    // 求标准差
    double sum2 = 0;
    for (int i = 0; i &lt; tempArr.length; i++) {
        sum2 += Math.sqrt((tempArr\[i\] - mean) * (tempArr\[i\] - mean));
    }
    double standardDivition = sum2 / (tempArr.length - 1);
    // 标准化
    for (int i = 0; i &lt; tempArr.length; i++) {
        tempArr\[i\] = (tempArr\[i\] - mean) / standardDivition;
    }
    return tempArr;

}

/\*\*
 \* 小数定标规范化
 \* @param arr
 \* @return 规范化后的数组
 */
public static double\[\] decimalsNormalize(double\[\] arr){
    // 拷贝数组
    double\[\] tempArr = Arrays.copyOf(arr, arr.length);
    // 找到最大值
    double max = tempArr\[0\];
    for (int i = 0; i &lt; tempArr.length; i++) {
        if (tempArr\[i\] &gt; max) {
            max = tempArr\[i\];
        }
    }
    // 确定j的值（j为使max(|v&apos;|)&lt;1的最小整数）
    int j = 0;
    while (Math.abs(max/Math.pow(10,j))&gt;=1){
        j++;
    }
    // 规范化
    for (int i = 0; i &lt; tempArr.length; i++) {
        tempArr\[i\] = tempArr\[i\] / Math.pow(10,j);
    }
    return tempArr;

}</code></pre><p>}</p>
]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>中位数</tag>
        <tag>众数</tag>
        <tag>四分位数</tag>
        <tag>常用算法</tag>
        <tag>数据处理</tag>
        <tag>方差</tag>
        <tag>极差</tag>
        <tag>标准差</tag>
      </tags>
  </entry>
  <entry>
    <title>Java程序员最可能被考到的面试题</title>
    <url>/2016/09/07/Java%E7%A8%8B%E5%BA%8F%E5%91%98%E6%9C%80%E5%8F%AF%E8%83%BD%E8%A2%AB%E8%80%83%E5%88%B0%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<p>作为程序员在面试的时候碰到的问题还是很多的，不光要掌握像数组、链表、栈、队列和树这样基本的数据结构，在面试中还会碰到数据结构和算法问题。所以小编在这里告诉大家，下面的面试题目很有可能被碰到，一起来看看吧！ </p>
<a id="more"></a>

<p><strong>1. 如何只扫描一遍就找到位于一个链表正中间的元素？</strong> 这是最受欢迎的算法题之一，经常在电话面试中被问到。很多程序员会想，要知道链表的长度，就要先扫描一遍链表，然后在第二遍中取其正中的元素。所以被要求只扫描一遍就解决问题的时候他们就会很困惑。要解决这个问题，你要维护两个指针。一个每次往下走一个结点，而另一个每次走两个结点。那么当走的快的指针到达链表末尾时，另一个指针就正好指在链表的正中间。 <strong>2. 如何确定一个链表中是否存在环？</strong> 这跟第一题有点类似。同样地维护两个指针，分别以每步一个结点和每步两个结点的速度走，那么如果当某一步结束以后两个指针指向同一个结点，就说明我们找到了一个环。 <strong>3. 如何只扫描一遍就找到一个链表倒数第三个元素？</strong> 这也是一个很经典的链表题，也可以用两个指针的方法来解决。我们让第一个指针先走，当它走出三步以后再让第二个指针开始走。那么当第一个指针到达链表的末尾时，第二个指针就正好指向链表中的倒数第三个元素。 <strong>4. 如何找到一个含有 1~100 的数组中唯一出现两次的元素？</strong> 这是一个挺简单的算法题。你可以把数组里面所有元素加起来，再减去 1~100 的和，就能得到那个重复的元素。当然你也可以暴力地去比对每一对元素，不过这样的复杂度是 O(N^2)。 <strong>5. 如何在 Java 中反转一个字符串？</strong> 这是我最喜欢的问题之一。因为 String 是编程中最重要的类型之一，所以在技术面试中你会遇到许多跟字符串有关的问题。Java 和其他编程语言都有许多不同的方式可以反转一个字符串，所以面试官往往会禁止你使用某些特性，比如 reverse() 和 StringBuffer。之后他还可能会问如何用递归来反转字符串。 <strong>6. 如何用冒泡排序对数组进行排序？</strong> 在技术面试中我总是会问一些关于搜索和排序的问题。冒泡排序是最简单的排序算法之一，但如果你让一个候选人现场写冒泡排序，这能够很好地衡量他的编程技能。 <strong>7. 栈和队列这两种数据结构之间的区别是什么？</strong> 这是一个经典的数据结构问题，应该没有人不知道的吧？不管怎么说，最主要的区别在于栈是后进先出（LIFO），而队列是先进先出（FIFO）的。 <strong>8. 如何找到一个数组中所有重复出现的元素？</strong> 这个问题有时会作为第 4 题的后续出现。解决这个问题的一种途径是使用哈希表。遍历整个数组并将元素和出现次数存到哈希表中。最后你就可以统计那些出现超过一次的元素作为答案。在 Java 中，当一个元素已经在 HashMap 中时，调用 get(index) 就可以得到对应的值，否则会返回 Null。这个性质可以用来插入和更新 HashMap 中的值。 <strong>9. 单向链表和双向链表之间有什么差别？</strong> 这又是一个经常在电话面试中被问到的数据结构题。单向链表和双向链表之间主要的差别在于它们的可遍历性不同。在单向链表中，每个结点只有指向下一个结点的指针，而没有指向上一个结点的指针，所以你就不能倒回去遍历。而双向链表的结点则维护了两个指针，往两个方向都可以遍历。 <strong>10. 如何打印斐波那契数列？</strong> 这是一个在面试中经常出现的编程问题。斐波那契数列是这样的一种数列：它的每一项都等于前两项之和，例如：1，1，2，3，5，8，13，21。面试官往往会关心这两件事情：一个能够返回斐波那契数列第 n 项的函数，以及如何在 Java 中用递归解决这个问题。虽然这个问题很简单，但递归的部分可能会困惑一些初学者。 <strong>11. 如何判断一个整数是不是回文数？</strong> 跟前一题一样，这也不是一个算法题，但在面试中的出现率也很高。当一个数反过来写还是等于本身时，我们称之为回文数。面试官往往会要求你不使用 Java API 和第三方库来解这个问题。当然，问题本身不难。你只要会用 / 和 % 就能解决它。/ 能去掉最后一位，而 % 能得到最后一位。比如 1234 / 10 会得到 123，而 1234 % 10 则能得到 4。 <strong>12. 什么是二叉查找树？</strong> 这是一个关于树的数据结构问题。二叉查找树满足一些特殊的性质，比如说每个结点的左子树中的值都要比自身小，而右子树中的值都要比自身大，等等。除了定义以外，面试官还可能让你在 Java 中实现一棵二叉树并询问关于树的遍历的问题。比如中序遍历、先序遍历和后序遍历之间的区别。 <strong>13. 如何分别用递归和非递归方式倒置一个链表？</strong> 这是一个非常好的数据结构题，所以我希望你自己去思考。当然你也能轻易地在网上找到许多解法。 <strong>14. 如何用 Java 实现一个栈？</strong> 你可以用数组或者链表来实现栈。这个问题期望你实现栈所提供的标准接口，也就是 push()和 pop()。这两个操作都应该发生在栈的顶部。当然，如果你能实现 contains() 和 isEmpty() 这样的功能就更好了。顺便一提，你可以利用 JDK 提供的 java.util.Stack 来学习怎么实现一个栈。</p>
]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>Java类加载机制-类加载器（ClassLoader）与双亲委派模型</title>
    <url>/2017/03/12/Java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%EF%BC%88ClassLoader%EF%BC%89%E4%B8%8E%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<p>Java虚拟机类加载过程中的“加载”阶段第一步就是“通过一个类的全限定名来获取描述此类的二级制字节流”，这个动作由Java虚拟机外部实现，以便让应用程序自己决定如何去获取所需要的类，实现这个动作的模块叫做“类加载器”。</p>
<a id="more"></a>

<h2 id="类与类加载器"><a href="#类与类加载器" class="headerlink" title="类与类加载器"></a>类与类加载器</h2><p>类加载器虽然只用于实现类的加载动作，但它在Java程序中的作用远不限于此。</p>
<blockquote>
<p>对于任意一个类，都需要由<strong>加载它的类加载器</strong>和这个<strong>类本身</strong>一同确立其在Java虚拟机中的唯一性，每一个类加载器，都拥有一个独立的类命名空间。</p>
</blockquote>
<p>换言之，比较两个类“相等”，只有在两个类是由<strong>同一个类加载器</strong>加载的前提下才有意义，否则，即使这两个类来源于同一个Class文件，被同一个虚拟机加载，只要加载它们的类加载器不同，那这两个类就必定不相等。</p>
<h2 id="Java中的类加载器"><a href="#Java中的类加载器" class="headerlink" title="Java中的类加载器"></a>Java中的类加载器</h2><p>Java虚拟机只有两种不同的类加载器：</p>
<ul>
<li><strong>启动类加载器（Bootstrap ClassLoader）</strong>：使用C++语言（HotSpot）实现，是虚拟机的一部分，该类加载器实例无法被用户获取；</li>
<li><strong>所有其它的类加载器</strong>：均由Java语言实现，独立于虚拟机外部，并且全部继承自抽象类java.lang.ClassLoader；</li>
</ul>
<p>从Java程序员的角度，类加载器还可以继续细化，绝大部分Java程序都会使用到以下3种类加载器。</p>
<ul>
<li><strong>启动类加载器 （Bootstrap ClassLoader）</strong>：这个类加载器负责将存放在<code>&lt;JAVA_HOME&gt;\lib</code>目录中的，或者被<code>-Xbootclasspath</code>参数所指定的目录中的，并且是虚拟机识别的（仅按照文件名识别，例如rt.jar）类库加载到虚拟机内存中。 启动类加载器无法被Java程序直接引用，用户在编写自定义加载器时，如果需要把加载请求委托给引导类加载器，直接使用null代替即可。</li>
<li><strong>扩展类加载器（Extension ClassLoader）</strong>：这个加载器由<code>sun.misc.Launcher$ExtClassLoader</code>实现，他负责加载<code>&lt;JAVA_HOME&gt;\lib\ext</code>目录中的，或者被<code>java.ext.dirs</code>系统变量所指定的路径中的所有类库，开发者可以直接使用扩展类加载器。</li>
<li><strong>应用程序类加载器（Application ClassLoader）</strong>：这个类加载器由<code>sun.misc.Launcher$AppClassLoader</code>实现。该类是ClassLoader中的<code>getSystemClassLoader()</code>方法的返回值，因此也称作“<strong>系统类加载器</strong>”。它负责用户类路径（ClassPath）上所指定的类库，开发者可以直接使用这个类加载器，如果应用程序中没有定义过自己的类加载器，一般情况下这个就是程序的默认类加载器。</li>
</ul>
<p>应用程序一般由这3中类加载器相互配合加载，如果有必要，还可以加入自己定义的类加载器，集成。</p>
<h3 id="自定义类加载器"><a href="#自定义类加载器" class="headerlink" title="自定义类加载器"></a>自定义类加载器</h3><p>自定义类加载器可以直接或间接继承自类<code>java.lang.ClassLoader</code>。在<code>java.lang.ClassLoader</code>类的常用方法中，一般来说，自己开发的类加载器只需要覆写 <code>findClass(String name)</code>方法即可。 java.lang.ClassLoader类的方法 loadClass()封装了代理模式的实现。</p>
<ul>
<li>该方法会首先调用 findLoadedClass()方法来检查该类是否已经被加载过；</li>
<li>如果没有加载过的话，会调用父类加载器的 loadClass()方法来尝试加载该类；</li>
<li>如果父类加载器无法加载该类的话，就调用 findClass()方法来查找该类。</li>
</ul>
<p>因此，为了保证类加载器都正确实现代理模式，在开发自己的类加载器时，最好不要覆写 loadClass()方法，而是覆写 findClass()方法。 下面是一个文件系统类加载器的例子：</p>
<p>public class FileSystemClassLoader extends ClassLoader {<br>    private String rootDir;<br>    public FileSystemClassLoader(String rootDir) {<br>        this.rootDir = rootDir;<br>    }<br>    protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException {<br>        byte[] classData = getClassData(name);<br>        if (classData == null) {<br>            throw new ClassNotFoundException();<br>        }<br>        else {<br>            return defineClass(name, classData, 0, classData.length);<br>        }<br>    }<br>    private byte[] getClassData(String className) {<br>        String path = classNameToPath(className);<br>        try {<br>            InputStream ins = new FileInputStream(path);<br>            ByteArrayOutputStream baos = new ByteArrayOutputStream();<br>            int bufferSize = 4096;<br>            byte[] buffer = new byte[bufferSize];<br>            int bytesNumRead = 0;<br>            while ((bytesNumRead = ins.read(buffer)) != -1) {<br>                baos.write(buffer, 0, bytesNumRead);<br>            }<br>            return baos.toByteArray();<br>        } catch (IOException e) {<br>            e.printStackTrace();<br>        }<br>        return null;<br>    }<br>    private String classNameToPath(String className) {<br>        return rootDir + File.separatorChar<br>                + className.replace(‘.’, File.separatorChar) + “.class”;<br>    }<br> }</p>
<h2 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h2><p>下图展示的类加载器之间的层次关系，称为类加载器的“双亲委派模型”。双亲委派模型要求除了顶层的启动类加载器外，其它类加载器必须有自己的父加载器。</p>
<p><img data-src="https://cdn.javacodes.cn/files/2017/03/2017-03-12_08-34-52.png" alt=""></p>
<blockquote>
<p>这里的类加载器之间的父子关系一般不通过继承（Inheritance）来实现，而是通过组合（Composition）关系来服用父加载器代码。 双亲委派模型并不是一个强制性约束，而是Java设计者推荐给开发者的一种类加载实现方式。</p>
</blockquote>
<h3 id="双亲委派模型的工作过程"><a href="#双亲委派模型的工作过程" class="headerlink" title="双亲委派模型的工作过程"></a>双亲委派模型的工作过程</h3><ul>
<li>如果一个类加载器收到了类加载的请求，它不会先自己尝试处理这个请求，而是委派给它的父类加载器，所有的请求最终都会传送到顶层的启动类加载器</li>
<li>只有当父类反馈自己无法完成该请求（它的搜索范围中没有找到所需的类，即抛出ClassNotFoundException）时，子加载器才会尝试自己加载。</li>
</ul>
<h3 id="为什么使用双亲委派模型？"><a href="#为什么使用双亲委派模型？" class="headerlink" title="为什么使用双亲委派模型？"></a>为什么使用双亲委派模型？</h3><p>使用双亲委派模型可以使得Java类随着它的类加载器一起具备了一种<strong>带有优先级的层次关系</strong>。 例如类<code>java.lang.Object</code>，它存放在rt.jar中，无论哪一个类加载器要加载这个类，最终都是委派给处于模型最顶端的启动类加载器加载，因此Objcet类在程序中的各种类加载器环境中都是同一个类。 如果没有使用双亲委派模型，那么如果用户自己写了一个称为<code>“java.lang.Object”</code>的类，并放在程序的classpath中，那么系统将产生多个不同的Object类，可想而知，程序将一片混乱。</p>
<h3 id="双亲委派模型的实现"><a href="#双亲委派模型的实现" class="headerlink" title="双亲委派模型的实现"></a>双亲委派模型的实现</h3><p>双亲委派模型的实现非常简单，几乎所有的代码仅在<code>loadClass()</code>方法中实现，下面是一个简单的例子：</p>
<p>//双亲委派模型的实现源码<br>protected synchronized Class&lt;?&gt; loadClass(String name, Boolean resolve)  throws ClassNotFoundException{<br>    // 1、首先检查请求的类是否已经被加载过<br>    Class c = findLoadedClass(name);<br>    if(c == null){<br>        try{<br>            if(parent != null){    // 2、如果没有则调用父加载器的loadClass()方法<br>                c = parent.loadClass(name, false);  </p>
<pre><code>        // 3、如果父加载器为空则默认使用启动类加载器作为父加载器  
        } else{  
            c = findBootstrapClassOrNull(name);  
        }  
    }catch(ClassNotFoundException e){  
        // 4、如果父类加载器加载失败，则先抛出ClassNotFoundException  
    }  
    // 5、然后再调用自己的findClass()方法进行加载  
    if(c == null){  
        c = findClass(name);  
    }  
}  
if(resolve){  
    resolveClass(c);  
}  
return c;  </code></pre><p>}</p>
]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
        <tag>ClassLoader</tag>
        <tag>类加载</tag>
      </tags>
  </entry>
  <entry>
    <title>Java类加载机制-类加载的时机和过程</title>
    <url>/2017/03/12/Java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E7%9A%84%E6%97%B6%E6%9C%BA%E5%92%8C%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="类加载的时机"><a href="#类加载的时机" class="headerlink" title="类加载的时机"></a>类加载的时机</h2><p>类从被加载到虚拟机开始，到卸载为止，生命周期如图所示： <img data-src="https://cdn.javacodes.cn/files/2017/03/2017-03-12_05-33-29.png" alt=""> 其中，加载、验证、准备、初始化、卸载这五个阶段的顺序是确定的，类的加载过程必须按照这种顺序按部就班的开始（开始不代表完成，通常为交叉混合运行），而解析阶段不一定：它在某些情况下可以在初始化阶段之后再开始。 </p>
<a id="more"></a>

<p>Java虚拟机规定有且只有5种情况必须立即对类进行“初始化”：</p>
<ol>
<li>遇到<strong>new、getstatic、putstatic或invokestatic</strong>这4条字节码指令（new实例化对象、读取或设置静态字段、调用静态方法）；</li>
<li>使用java.lang.reflect包的方法进行<strong>反射</strong>调用；</li>
<li>初始化一个类时，其父类如未初始化，则需要先初始化其<strong>父类</strong>；</li>
<li>虚拟机启动时，用户指定的要执行的<strong>主类</strong>（包含main方法的那个类）；</li>
<li>使用JDK1.7的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果<strong>REF_getStatic、REF_putStatic、REF_invokeStatic</strong>的方法句柄，并且句柄所对应的类没有进行初始化；</li>
</ol>
<h2 id="类加载的过程"><a href="#类加载的过程" class="headerlink" title="类加载的过程"></a>类加载的过程</h2><h3 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h3><p>“加载”阶段，虚拟机需要完成下面3件事情：</p>
<ol>
<li>通过一个类的全限定名来获取定义此类的二进制字节流</li>
<li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构</li>
<li>在内存中生成一个代表该类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口</li>
</ol>
<blockquote>
<p>注意：加载阶段尚未完成，连接阶段可能已经开始。</p>
</blockquote>
<h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>验证是连接阶段的第一步，目的是确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会威胁虚拟机自身的安全。 验证阶段大致上会完成下面4个阶段的检验动作：文件格式验证、元数据验证、字节码验证、符号引用验证。</p>
<ol>
<li>文件格式验证：验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理，通过验证后字节流进入方法区；</li>
<li>元数据验证：对字节码描述的信息进行语义分析，保证其描述的信息符合Java语言规范的要求；</li>
<li>字节码验证：最复杂，通过数据流和控制流分析确定程序语义是否合法、符合逻辑；</li>
<li>符号引用验证：该验证发生在虚拟机将符号引用转化为直接引用时，该动作发生在解析阶段。可以看做是对类自身以外的信息进行匹配性校验；</li>
</ol>
<h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>正式为类变量（static修饰的变量）分配内存并设置初始值的阶段，这些变量所使用的内存将在方法区中进行分配。 通常情况下是对应类型的“零值”，真正的用户定义的初值要在初始化阶段完成。例如： <code>public static int value = 123;</code> 变量value在准备阶段过后的初始值将是0而不是123，因为这是并未执行任何java方法，而是把value赋值为123的putstatic指令是程序编译后，存放于类构造器<clinit>()方法中，因此该动作在初始化阶段才会执行。</p>
<blockquote>
<p>注意：这里是指“通常情况”，如果字段的字段属性表中存在ConstantValue属性，那在准备阶段变量就将被赋予ConstantValue属性所指的值，例如：<code>public static final int value = 123;</code>， 编译的时候javac会为value生成ConstantValue属性，在准备阶段虚拟机会根据ConstantValue的设置将value赋值为123.</p>
</blockquote>
<h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。</p>
<ul>
<li>符号引用：是一组符号来描述所引用的目标，其字面量形式明确定义在Java虚拟机规范的Class文件格式中；</li>
<li>直接引用：可以是直接指向目标的指针、相对偏移量或一个能间接定位到目标的句柄。</li>
</ul>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>类初始化阶段是类加载过程的最后一步，在准备阶段变量已经被附过一次系统要求的初始值（通常为“零值”）,而在初始化阶段，则根据程序员通过程序制定的主观计划去初始化类变量和其它资源。换言之，初始化阶段就是<strong>执行类构造器<clinit>()方法</strong>的过程。</p>
<ul>
<li><clinit>()方法是由编译器自动收集类中的所有变量的赋值动作和静态语句块（static{}块）中的语句合并产生的，编译器收集的顺序是语句在源文件中出现的顺序决定的，静态语句块中只能访问到定义在静态语句块之前的变量，定义在它之后的变量在之前可以访问但不能赋值；</li>
<li><clinit>()方法与类构造函数（或者说实例构造器<init>()方法）不同，它不需要显示调用父类构造器，虚拟机会保证在子类的<clinit>()方法执行之前父类的已经执行完毕，因此虚拟机中第一个被执行的<clinit>()方法一定是java.lang.Object；</li>
<li>由于父类的<clinit>()方法先执行，意味着父类中定义的静态语句块要优先于子类的变量赋值操作；</li>
<li><clinit>()方法对于类或者接口不是必须的，如果一个类没有静态语句块和变量的赋值操作，那编译器就可以不为这个类生成<clinit>()方法；</li>
<li>接口中不能使用静态语句块，但仍然有变量初始化的赋值操作，因此接口也会生成<clinit>()方法。但接口不需要先执行父接口的<clinti>()方法，只有当父接口中定义的变量使用时，父接口才会初始化。接口的实现类初始化时一样不会执行接口的<clinit>()方法；</li>
<li>虚拟机会保证一个类的<clinit>()方法在多线程环境中被正确的加锁、同步。如果多线程同时执行某一个类的<clinit>()方法，那么只会有一个线程去执行，其它线程将会阻塞等待，直到活动线程执行完毕，需要注意的是，当活动线程执行完毕后，其它线程唤醒之后并不会再次进入<clinit>()方法。同一个类加载器下，一个类型只会被初始化一次。</li>
</ul>
]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
        <tag>ClassLoader</tag>
        <tag>类加载</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring学习笔记之Bean的作用域</title>
    <url>/2016/10/20/Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8BBean%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F/</url>
    <content><![CDATA[<p>在默认情况下，Spring的应用上下文中所有的bean都是单例的形式创建的。也就是说，不管给定的一个bean被注入到其它bean多少次，每次注入的都是同一个实例。</p>
<p>在大多数情况下，单例bean是非常理想的方案。初始化和垃圾回收对象实例所带来的成本只留给一些小规模任务，在这些任务中，让对象保持无状态并且在应用中反复重用这些对象可能并不合理。</p>
<p>有时候你所使用的类可能是易变的，它们会保持一些状态，比如我们在Web购物商城中常见的购物车功能，不同的用户不可能同时使用同一个购物车实例，因此重用是不安全的。</p>
<a id="more"></a>

<h3 id="（一）Spring中的作用域"><a href="#（一）Spring中的作用域" class="headerlink" title="（一）Spring中的作用域"></a>（一）Spring中的作用域</h3><p>Spring提供了多种作用域，可以基于这些作用域来创建bean，包括：</p>
<ul>
<li>单例（Singleton）：在整个应用中，只创建bean的一个实例；</li>
<li>原型（Prototype）：每次注入或者通过Spring上下文获取的时候，都会创建一个新的bean实例；</li>
<li>会话（Session）：在Web应用中，为每个会话创建一个bean实例；</li>
<li>请求（Request）：在Web应用中，为每次请求创建一个bean实例；</li>
</ul>
<p>如果需要自定义bean的作用域，需要使用@Scope注解，他可以与@Component或@Bean组合使用：</p>
<p>@Component<br>@Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)<br>public class Cake implements Dessert {<br>}</p>
<p>这里使用ConfigurableBeanFactory类的SCOPE_PROTOTYPE常亮设置为原型作用域。当然你也可以使用下面这种方式：</p>
<p>@Component<br>@Scope(“prototype”)<br>public class Cake implements Dessert {<br>}</p>
<p>但是尽可能使用ConfigurableBeanFactory.SCOPE_PROTOTYPE，这更不容易出错。</p>
<p>当然也可以在Java配置中将作用域设置为原型bean，例如：</p>
<pre><code>@Bean
@Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)
public Dessert cake(){
    return new Cake();
}</code></pre><p>同样，也可以在XML中配置，应用<bean>元素的scope属性：</p>
<p><bean id="cake" class="cn.javacodes.spring.beans.Cake" scope="prototype"></bean></p>
<h3 id="（二）使用会话和请求作用域"><a href="#（二）使用会话和请求作用域" class="headerlink" title="（二）使用会话和请求作用域"></a>（二）使用会话和请求作用域</h3><p>在Web应用中，我们经常需要操作两种作用域：会话和请求。</p>
<p>就像前面所说，在购物商城的购物车实例上，单例和原型作用域自然不能满足我们的需求，我们希望为每一个会话都创建一个购物车，那么这里会话作用域就是最完美的选择。</p>
<p>下面来简单模拟一下购物车的作用域场景：</p>
<pre><code>@Bean
@Scope(
    value = WebApplicationContext.SCOPE_SESSION,
    proxyMode = ScopedProxyMode.INTERFACES)
public ShoppingCart cart(){
   // ....
}</code></pre><p>这里，将value值设置成了WebApplicationContext中的SCOPTE_SESSION常量（值为session）。这会告诉Spring为Web应用中的每个会话创建一个ShoppingCart。对于每一个会话来说，这个bean实际上相当于是单例的。</p>
<p>这里需要注意，@Scope还有一个proxyMode属性，它被设置为ScopedProxyMode.INTERFACES。我们先不考虑这个属性，先来理解一下对Spring作用域的理解。</p>
<p>现在假设我们要将ShoppingCart bean注入到单例StoreService bean的Setter中，如下所示：</p>
<p>@Component<br>public class StoreService {</p>
<pre><code>private ShoppingCart shoppingCart ;

@Autowired
public  void setShoppingCart(ShoppingCart shoppingCart){
    this.shoppingCart = shoppingCart;
}</code></pre><p>}</p>
<p>因为StoreService是一个单例bean，会在Spring上下文加载的时候创建，当它创建的时候，Spring会试图将ShoppingCart bean注入到setShoppingCart()方法中。但是ShoppingCart bean是会话作用域的，此时并不存在。直到某个用户进入系统，创建了会话以后，才会出现ShoppingCart实例。</p>
<p>另外，系统中将会存在多个ShoppingCart实例：每个用户一个。我们并不想让Spring注入到某个胡定的ShoppingCart实例到StoreService中。我们希望的是当StoreService处理购物车功能时，它所使用的ShoppingCart实例恰好是当前会话所对应的那一个。</p>
<p>Spring并不会将实际的ShoppingCart bean注入到StoreService中，Spring会注入一个到ShoppingCart bean的代理。这个代理会暴露与ShoppingCart相同的方法，所以StoreService会认为他就是一个购物车。但是，当StoreService调用ShoppingCart的方法时，代理会对其进行懒解析并将调用委托给作用域内真正的ShoppingCart bean。如下图所示：</p>
<p><img data-src="https://cdn.javacodes.cn/files/2016/10/2016-10-20_09-27-28.png" alt="QQ截图20161020163515"></p>
<p>现在我们来讨论一下proxyMode属性。我们将proxyMode属性设置为了ScopedProxyMode.INTERFACES，这表明这个代理要实现ShoppingCart接口，并将调用委托给实现bean。</p>
<p>这里我们的ShoppingCart是接口而不是具体的类，这当然是可以的（也是最理想的代理模式）。但如果ShoppingCart是具体的实现类而不是接口的话，Spring就没办法创建基于接口的代理了。此时必须使用CGLib来生成基于类的代理。所以，如果bean类型是具体的类的话，我们必须要将proxyMode设置为ScopedProxyMode.TARGET_CLASS，以此来表明要以生成目标类扩展的方式创建代理。</p>
<p>请求作用域与会话作用域十分类似，也应该以作用域代理的方式进行注入，再次不做赘述。</p>
<h3 id="（三）在XML中声明作用域代理"><a href="#（三）在XML中声明作用域代理" class="headerlink" title="（三）在XML中声明作用域代理"></a>（三）在XML中声明作用域代理</h3><p>在XML中设置作用域代理需要使用Spring aop命名空间的一个元素：</p>
<pre><code>&lt;bean id=&quot;cart&quot; class=&quot;cn.javacodes.spring.beans.ShoppingCart&quot; scope=&quot;session&quot;&gt;
    &lt;aop:scoped-proxy /&gt;
&lt;/bean&gt;</code></pre><p>当然了，在使用aop命名空间之前一定要在xml的顶部进行对命名空间进行声明：</p>
<?xml version="1.0" encoding="UTF-8"?>
<p><beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:aop="http://www.springframework.org/schema/aop"
       xsi:schemaLocation="
       http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd
       http://www.springframework.org/schema/aop
       http://www.springframework.org/schema/aop/spring-aop.xsd"><br>    ……<br></beans></p>
<p>注意：在使用Spring开发web项目时，需要在web.xml中加入如下内容（web2.4以上）：</p>
<web-app>
   ...
  <listener>
<listener-class>org.springframework.web.context.request.RequestContextListener</listener-class>
  </listener>
   ...
</web-app>

<p>web 2.4以下版本需要加入：</p>
<web-app>
 ..
 <filter> 
    <filter-name>requestContextFilter</filter-name> 
    <filter-class>org.springframework.web.filter.RequestContextFilter</filter-class>
 </filter> 
 <filter-mapping> 
    <filter-name>requestContextFilter</filter-name> 
    <url-pattern>/*</url-pattern>
 </filter-mapping>
   ...
</web-app>

<p>另外，&lt;aop:scoped-proxy /&gt;是与@Scope注解的proxyMode属性功能相同的Spring XML配置元素。它会告诉Spring为bean创建一个作用域代理。默认情况下，它会使用CGLib创建目标类的代理。但是我们也可以将proxy-target-class属性设置为false，进而要求它生成基于接口的代理：</p>
<bean id="cart" class="cn.javacodes.spring.beans.ShoppingCart" scope="session">
        <aop:scoped-proxy proxy-target-class="false"/>
    </bean>]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>request</tag>
        <tag>session</tag>
        <tag>Spring</tag>
        <tag>Spring学习笔记</tag>
        <tag>代理</tag>
        <tag>会话</tag>
        <tag>作用域</tag>
        <tag>请求</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring学习笔记之Bean的属性注入</title>
    <url>/2016/09/06/Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8BBean%E7%9A%84%E5%B1%9E%E6%80%A7%E6%B3%A8%E5%85%A5/</url>
    <content><![CDATA[<p>通常，JavaBean的属性值是私有的，同时拥有一组存取器方法，以setXxx()和getXxx()的形式存在。Spring通过Java 的反射机制借助属性的set方法来配置属性的值，以实现setter方式的注入。 </p>
<a id="more"></a>

<p>下面定义一个Person类来演示Spring Bean的属性注入：</p>
<p>package cn.javacodes.spring.beans;<br>/**<br> * Created by eric on 16-8-31.<br> */<br>public class Person {<br>    private String name;<br>    private int age;<br>    private String sex;<br>    private String resume;<br>    private Car car;</p>
<pre><code>public String getName() {
    return name;
}
public void setName(String name) {
    this.name = name;
}
public int getAge() {
    return age;
}
public void setAge(int age) {
    this.age = age;
}
public String getSex() {
    return sex;
}
public void setSex(String sex) {
    this.sex = sex;
}
public String getResume() {
    return resume;
}
public void setResume(String resume) {
    this.resume = resume;
}
public Car getCar() {
    return car;
}
public void setCar(Car car) {
    this.car = car;
}
public Person(String name, int age, String sex, String resume) {
    this.name = name;
    this.age = age;
    this.sex = sex;
    this.resume = resume;
}
public Person(String name, int age, String sex, String resume, Car car) {
    this.name = name;
    this.age = age;
    this.sex = sex;
    this.resume = resume;
    this.car = car;
}
public Person() {
}</code></pre><p>}</p>
<p>Person类中包含一个无参的构造方法，因此可以在Spring中使用下面的XML声明一个<bean>：</p>
<p><bean id="person" class="cn.javacodes.spring.beans.Person"></bean></p>
<p>通过上面的XML生命的<bean>没有对任何属性进行赋值，下面逐步讲解如何为属性进行赋值。</p>
<h3 id="一、注入简单值（字面值）"><a href="#一、注入简单值（字面值）" class="headerlink" title="一、注入简单值（字面值）"></a>一、注入简单值（字面值）</h3><h4 id="1、通过value属性注入"><a href="#1、通过value属性注入" class="headerlink" title="1、通过value属性注入"></a>1、通过value属性注入</h4><p>在Spring中可以使用<property>元素配置Bean的属性。例如现在想给bean person的姓名、年龄、性别、简历等属性赋值，那么可以使用下面的方式：</p>
<pre><code>&lt;bean id=&quot;person&quot; class=&quot;cn.javacodes.spring.beans.Person&quot;&gt;
    &lt;property name=&quot;name&quot; value=&quot;张三&quot;&gt;&lt;/property&gt;
    &lt;property name=&quot;age&quot; value=&quot;16&quot;&gt;&lt;/property&gt;
    &lt;property name=&quot;sex&quot; value=&quot;男&quot;&gt;&lt;/property&gt;
    &lt;property name=&quot;resume&quot; value=&quot;疯狂的Java码农&quot;&gt;&lt;/property&gt;
&lt;/bean&gt;</code></pre><p>一旦Person被实例化，Spring就会调用<property>元素所指定属性的setter方法为该属性注入值。在本实例中，name、sex、resume属性均为String类型的字符串，而我们发现int类型的age属性也可以成功注入简单值，这是因为<property>元素并没有限制只能注入String类型的值，value属性同样可以指定为基本数据类型（包括数值型和布尔型等）。</p>
<h4 id="2、通过子元素注入"><a href="#2、通过子元素注入" class="headerlink" title="2、通过子元素注入"></a>2、通过<value>子元素注入</h4><p>那么我们想象一下，如果我们想注入的值中包含XML的特殊字符怎么办，上述方法是否仍然奏效？不妨尝试一下，例如我想将person的resume属性注入值“&lt;Coder!&gt;”，那么在这个值中，“&lt;&gt;”在XML中拥有特殊的含义，如果仍然使用value属性进行赋值，将会出现异常！</p>
<blockquote>
<p><code>Exception in thread &quot;main&quot; org.springframework.beans.factory.xml.XmlBeanDefinitionStoreException: Line 11 in XML document from class path resource [applicationContext.xml] is invalid; nested exception is org.xml.sax.SAXParseException; lineNumber: 11; columnNumber: 40; 与元素类型 &quot;property&quot; 相关联的 &quot;value&quot; 属性值不能包含 &#39;&lt;&#39; 字符。</code></p>
</blockquote>
<p>那么如何解决这个问题呢？<property>元素中可以添加一个<value>子元素，其作用与value属性基本相同，而当我们想要注入包含特殊字符的字面值时，可以在<value>子元素中使用CDATA节来解决，例如：</p>
<pre><code>&lt;bean id=&quot;person&quot; class=&quot;cn.javacodes.spring.beans.Person&quot;&gt;
    &lt;property name=&quot;name&quot; value=&quot;张三&quot;&gt;&lt;/property&gt;
    &lt;property name=&quot;age&quot; value=&quot;16&quot;&gt;&lt;/property&gt;
    &lt;property name=&quot;sex&quot; value=&quot;男&quot;&gt;&lt;/property&gt;
    &lt;property name=&quot;resume&quot;&gt;
        &lt;value&gt;&lt;!\[CDATA\[&lt;Coder!&gt;\]\]&gt;&lt;/value&gt;
    &lt;/property&gt;
&lt;/bean&gt;</code></pre><h3 id="二、引用其他Bean"><a href="#二、引用其他Bean" class="headerlink" title="二、引用其他Bean"></a>二、引用其他Bean</h3><p>上面使用value属性或<value>子元素注入简单值只是实现简单的硬编码，而在实际开发过程中，经常需要为某一个属性赋值为一个对象，通常为另一个bean。那么如何在Spring中为属性引用其他bean呢？</p>
<p>例如本例中Person实例拥有一个Car类型的属性car，可以使用<property>元素的ref属性为其进行赋值。类Car的源码如下：</p>
<p>package cn.javacodes.spring.beans;<br>/**<br> * Created by huzha on 2016-09-06.<br> */<br>public class Car {<br>    private String brand;<br>    private String model;<br>    private String color;<br>    public Car() {<br>    }<br>    public Car(String brand, String model, String color) {<br>        this.brand = brand;<br>        this.model = model;<br>        this.color = color;<br>    }<br>    public String getBrand() {<br>        return brand;<br>    }<br>    public void setBrand(String brand) {<br>        this.brand = brand;<br>    }<br>    public String getModel() {<br>        return model;<br>    }<br>    public void setModel(String model) {<br>        this.model = model;<br>    }<br>    public String getColor() {<br>        return color;<br>    }<br>    public void setColor(String color) {<br>        this.color = color;<br>    }<br>    @Override<br>    public String toString() {<br>        return “Car{“ +<br>                “brand=’” + brand + ‘’’ +<br>                “, model=’” + model + ‘’’ +<br>                “, color=’” + color + ‘’’ +<br>                ‘}’;<br>    }<br>}</p>
<p>我们首先在XML中声明一个Car类型的<bean>，源码如下：</p>
<pre><code>&lt;bean id=&quot;car&quot; class=&quot;cn.javacodes.spring.beans.Car&quot;&gt;
    &lt;property name=&quot;brand&quot; value=&quot;奥迪&quot;&gt;&lt;/property&gt;
    &lt;property name=&quot;model&quot; value=&quot;A6&quot;&gt;&lt;/property&gt;
    &lt;property name=&quot;color&quot; value=&quot;黑色&quot;&gt;&lt;/property&gt;
&lt;/bean&gt;</code></pre><p>那么可以在person bean中引用这个bean，源码如下：</p>
<pre><code>&lt;bean id=&quot;person&quot; class=&quot;cn.javacodes.spring.beans.Person&quot;&gt;
    &lt;property name=&quot;name&quot; value=&quot;张三&quot;&gt;&lt;/property&gt;
    &lt;property name=&quot;age&quot; value=&quot;16&quot;&gt;&lt;/property&gt;
    &lt;property name=&quot;sex&quot; value=&quot;男&quot;&gt;&lt;/property&gt;
    &lt;property name=&quot;resume&quot;&gt;
        &lt;value&gt;&lt;!\[CDATA\[&lt;Coder!&gt;\]\]&gt;&lt;/value&gt;
    &lt;/property&gt;
    &lt;property name=&quot;car&quot; ref=&quot;car&quot;&gt;&lt;/property&gt;
&lt;/bean&gt;</code></pre><h3 id="三、注入内部Bean"><a href="#三、注入内部Bean" class="headerlink" title="三、注入内部Bean"></a>三、注入内部Bean</h3><p>我们知道，在Spring中bean的默认作用域是单例的，通过上述方式注入bean，意味着这个bean还可能被其他bean引用。例如，可能有另外一个Person类型的bean person1，其car属性同样引用的是id为car的bean，那么意味着这两个人同时拥有同一台奥迪A6，这通常是不现实的。那么如何为一个Bean创建一个独有的内部bean呢？</p>
<p>在Spring中<bean>元素中还可以嵌套其它的<bean>元素，我们称嵌套在内部的<bean>为内部bean，这个概念与Java的内部类十分相似。</p>
<p>我们修改一下person的<bean>声明，代码如下：</p>
<pre><code>&lt;bean id=&quot;person&quot; class=&quot;cn.javacodes.spring.beans.Person&quot;&gt;
    &lt;property name=&quot;name&quot; value=&quot;张三&quot;&gt;&lt;/property&gt;
    &lt;property name=&quot;age&quot; value=&quot;16&quot;&gt;&lt;/property&gt;
    &lt;property name=&quot;sex&quot; value=&quot;男&quot;&gt;&lt;/property&gt;
    &lt;property name=&quot;resume&quot;&gt;
        &lt;value&gt;&lt;!\[CDATA\[&lt;Coder!&gt;\]\]&gt;&lt;/value&gt;
    &lt;/property&gt;
    &lt;property name=&quot;car&quot;&gt;
        &lt;bean class=&quot;cn.javacodes.spring.beans.Car&quot;&gt;
            &lt;property name=&quot;brand&quot; value=&quot;奥迪&quot;&gt;&lt;/property&gt;
            &lt;property name=&quot;model&quot; value=&quot;A6&quot;&gt;&lt;/property&gt;
            &lt;property name=&quot;color&quot; value=&quot;黑色&quot;&gt;&lt;/property&gt;
        &lt;/bean&gt;
    &lt;/property&gt;
&lt;/bean&gt;</code></pre><p>这样我们就成功的注入了一个内部Bean。细心的朋友可能会发现，在这里内部bean没有给定其id属性，因为在这里其id属性似乎并不是那么必要，因为我们永远不会通过id来引用内部bean。这也突出了内部Bean的最大缺点：它们不能被复用。内部Bean仅适用于一次注入，而且也不能被其它Bean所引用。</p>
<p>内部Bean并不局限于在<property>元素中使用，我们同样可以在<constructor-arg>中使用，例如我们修改person的<bean>声明如下：</p>
<pre><code>&lt;bean id=&quot;person&quot; class=&quot;cn.javacodes.spring.beans.Person&quot;&gt;
    &lt;constructor-arg value=&quot;张三&quot;&gt;&lt;/constructor-arg&gt;
    &lt;constructor-arg value=&quot;16&quot;&gt;&lt;/constructor-arg&gt;
    &lt;constructor-arg name=&quot;sex&quot; value=&quot;男&quot;&gt;&lt;/constructor-arg&gt;
    &lt;constructor-arg &gt;
        &lt;value&gt;&lt;!\[CDATA\[&lt;Coder!&gt;\]\]&gt;&lt;/value&gt;
    &lt;/constructor-arg&gt;
    &lt;constructor-arg&gt;
        &lt;bean class=&quot;cn.javacodes.spring.beans.Car&quot;&gt;
            &lt;constructor-arg name=&quot;brand&quot; value=&quot;奥迪&quot;&gt;&lt;/constructor-arg&gt;
            &lt;constructor-arg name=&quot;model&quot; value=&quot;A6&quot;&gt;&lt;/constructor-arg&gt;
            &lt;constructor-arg name=&quot;color&quot; value=&quot;黑色&quot;&gt;&lt;/constructor-arg&gt;
        &lt;/bean&gt;
    &lt;/constructor-arg&gt;
&lt;/bean&gt;</code></pre>]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>Spring学习笔记</tag>
        <tag>属性注入</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring学习笔记之IOC与DI概述</title>
    <url>/2016/09/06/Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8BIOC%E4%B8%8EDI%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<h3 id="一、IOC与DI"><a href="#一、IOC与DI" class="headerlink" title="一、IOC与DI"></a>一、IOC与DI</h3><ul>
<li>IOC(Inversion of Control)：其思想是反转资源获取的方向. 传统的资源查找方式要求组件向容器发起请求查找资源. 作为回应, 容器适时的返回资源. 而应用了 IOC 之后, 则是容器主动地将资源推送给它所管理的组件, 组件所要做的仅是选择一种合适的方式来接受资源. 这种行为也被称为查找的被动形式</li>
<li>DI(Dependency Injection) — IOC 的另一种表述方式：即组件以一些预先定义好的方式(例如: setter 方法)接受来自如容器的资源注入. 相对于 IOC 而言，这种表述更直接</li>
</ul>
<a id="more"></a>

<h3 id="二、案例分析"><a href="#二、案例分析" class="headerlink" title="二、案例分析"></a>二、案例分析</h3><h4 id="1、需求"><a href="#1、需求" class="headerlink" title="1、需求"></a>1、需求</h4><p>从容器中获取B对象，并使B对象的a属性被赋值为容器A对象的引用。 <img data-src="https://cdn.javacodes.cn/files/2016/09/2016-09-06_22-50-55.png" alt="1683738663"></p>
<p>class A{}<br>class B{<br>      private A a;<br>    public void setA(A a){<br>        this.a = a;<br>    }<br>}</p>
<h4 id="2、传统处理方式"><a href="#2、传统处理方式" class="headerlink" title="2、传统处理方式"></a>2、传统处理方式</h4><p><img data-src="https://cdn.javacodes.cn/files/2016/09/2016-09-06_22-51-48.png" alt="1187592820"></p>
<p>A a = getA();<br>B b = getB();<br>b.setA(a);</p>
<h4 id="3、IOC反转资源方向"><a href="#3、IOC反转资源方向" class="headerlink" title="3、IOC反转资源方向"></a>3、IOC反转资源方向</h4><p><img data-src="https://cdn.javacodes.cn/files/2016/09/2016-09-06_22-52-16.png" alt="1497026610"></p>
<p>B b = getB();</p>
<h3 id="三、IOC发展历程"><a href="#三、IOC发展历程" class="headerlink" title="三、IOC发展历程"></a>三、IOC发展历程</h3><p>需求: 生成 HTML 或 PDF 格式的不同类型的报表.</p>
<h4 id="1、IOC前生–分离接口与实现"><a href="#1、IOC前生–分离接口与实现" class="headerlink" title="1、IOC前生–分离接口与实现"></a>1、IOC前生–分离接口与实现</h4><p><img data-src="https://cdn.javacodes.cn/files/2016/09/2016-09-06_22-52-49.png" alt="269383126"></p>
<h4 id="2、IOC前生–采用工厂设计模式"><a href="#2、IOC前生–采用工厂设计模式" class="headerlink" title="2、IOC前生–采用工厂设计模式"></a>2、IOC前生–采用工厂设计模式</h4><p><img data-src="https://cdn.javacodes.cn/files/2016/09/2016-09-06_22-53-13.png" alt="2048962683"></p>
<h4 id="3、IOC–采用反转控制"><a href="#3、IOC–采用反转控制" class="headerlink" title="3、IOC–采用反转控制"></a>3、IOC–采用反转控制</h4><p><img data-src="https://cdn.javacodes.cn/files/2016/09/2016-09-06_22-53-39.png" alt="1508913749"></p>
]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>Spring学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring学习笔记之Spring HelloWorld</title>
    <url>/2016/09/06/Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8BSpring%20HelloWorld/</url>
    <content><![CDATA[<h3 id="一、下载Spring"><a href="#一、下载Spring" class="headerlink" title="一、下载Spring"></a>一、下载Spring</h3><p>官方网站：<a href="http://projects.spring.io/spring-framework/" target="_blank" rel="noopener">http://projects.spring.io/spring-framework/</a> 下载方式：Maven、Gradle Maven依赖描述：</p>
<dependencies>
    <dependency>
        <groupId>org.springframework</groupId>
        <artifactId>spring-context</artifactId>
        <version>4.3.2.RELEASE</version>
    </dependency>
</dependencies>

<a id="more"></a>

<h3 id="二、Spring概述"><a href="#二、Spring概述" class="headerlink" title="二、Spring概述"></a>二、Spring概述</h3><p>Spring是一个开元框架，为简化企业级应用开发而生。使用Spring可以使简单的JavaBean实现以前只有EJB才能实现的功能。Spring是一个IOC反转控制（DI依赖注入）和AOP（面向切面编程）容器框架。</p>
<ul>
<li>轻量级：Spring是非侵入性的-基于Spring开发的应用中对象可以不依赖Spring的 API；</li>
<li>依赖注入（DI, Dependency Injection、IOC）；</li>
<li>面向切面编程（AOP, Aspect Oriented Programming）；</li>
<li>容器：Spring是一个容器，因为它包含并且管理应用对象的生命周期；</li>
<li>框架：Spring实现了使用简单的组件配置组合成一个复杂的应用。在Spring中可以使用XML和Java注解组合这些对象；</li>
<li>一站式：在IOC和AOP的基础上可以整合各种企业应用的开源框架和优秀的第三方类库（实际上Spring自身也提供了表现层的Spring MVC和持久层的Spring JDBC）。</li>
</ul>
<h3 id="三、Spring模块"><a href="#三、Spring模块" class="headerlink" title="三、Spring模块"></a>三、Spring模块</h3><p><img data-src="https://cdn.javacodes.cn/files/2016/09/2016-09-06_22-30-00.png" alt="1807408754"></p>
<h3 id="四、安装Spring-Tool-Suite"><a href="#四、安装Spring-Tool-Suite" class="headerlink" title="四、安装Spring Tool Suite"></a>四、安装Spring Tool Suite</h3><ol>
<li>SPRING TOOL SUITE 是一个 Eclipse 插件，利用该插件可以更方便的在 Eclipse 平台上开发基于 Spring 的应用。</li>
<li>安装方法说明（springsource-tool-suite-3.4.0.RELEASE-e4.3.1-updatesite.zip）：</li>
</ol>
<ul>
<li>Help –&gt; Install New Software…</li>
<li>Click Add…</li>
<li>In dialog Add Site dialog, click Archive…</li>
<li>Navigate to springsource-tool-suite-3.4.0.RELEASE-e4.3.1-updatesite.zip  and click  Open</li>
<li>Clicking OK in the Add Site dialog will bring you back to the dialog ‘Install’</li>
<li>Select the xxx/Spring IDE that has appeared</li>
<li>Click Next  and then Finish</li>
<li>Approve the license</li>
<li>Restart eclipse when that is asked</li>
</ul>
<h3 id="五、搭建Spring开发环境"><a href="#五、搭建Spring开发环境" class="headerlink" title="五、搭建Spring开发环境"></a>五、搭建Spring开发环境</h3><ul>
<li>将以下jar包加入到工程的classpath下：</li>
</ul>
<p><img data-src="https://cdn.javacodes.cn/files/2016/09/2016-09-06_22-30-41.png" alt="1291596684"></p>
<ul>
<li>Spring的配置文件：一个典型的Spring项目需要创建一个或多个Bean配置文件，这些配置文件用于在Spring IOC容器中配置Bean。Bean的配置文件可以放在classpath下，也可以放在其它目录下。</li>
</ul>
<h3 id="六、创建Spring项目"><a href="#六、创建Spring项目" class="headerlink" title="六、创建Spring项目"></a>六、创建Spring项目</h3><ul>
<li>cn.javacodes.spring.beans.HelloWorld</li>
</ul>
<p>package cn.javacodes.spring.beans;<br>public class HelloWorld {<br>    private String name;<br>    public void setName(String name){<br>        this.name = name;<br>    }<br>    public void hello(){<br>        System.out.println(“hello: “ + name);<br>    }<br>}</p>
<ul>
<li>cn.javacodes.spring.beans.Main</li>
</ul>
<p>package cn.javacodes.spring.beans;<br>import org.springframework.context.ApplicationContext;<br>import org.springframework.context.support.ClassPathXmlApplicationContext;<br>public class Main {<br>    public static void main(String[] args) {<br>        // 1. 创建Spring的IOC容器对象<br>        ApplicationContext ctx = new ClassPathXmlApplicationContext(“applicationContext.xml”);<br>        // 2. 从IOC中获取Bean实例<br>        HelloWorld helloWorld = (HelloWorld) ctx.getBean(“helloWorld”);<br>        // 3.调用hello方法<br>        helloWorld.hello();<br>    }<br>}</p>
<ul>
<li>applicationContext.xml</li>
</ul>
<?xml version="1.0" encoding="UTF-8"?>
<p><beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"><br>    &lt;!-- 配置Bean –&gt;<br>    <bean id="helloWorld" class="cn.javacodes.spring.beans.HelloWorld"><br>        <property name="name" value="Spring"></property><br>    </bean><br></beans></p>
]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>Spring学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring学习笔记之处理自动装配的歧义性</title>
    <url>/2016/10/20/Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%A4%84%E7%90%86%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E7%9A%84%E6%AD%A7%E4%B9%89%E6%80%A7/</url>
    <content><![CDATA[<p>之前的文章中已经看到了Spring的自动装配有很大的用处，它可以帮助我们快速的装配bean，但是这里存在一个问题，在之前的装配中，仅有一个bean匹配所需的结果时，自动装配才是有效的。如果不仅只有一个bean能够匹配结果的话，这就会导致Spring不知道该装配哪个bean从而导致装配失败，例如下面这个例子，我们定义了一个Dessert接口，并且有三个类实现了这个接口，分别为Cake、Cookies和IceCream：</p>
<p>@Component<br>public class Cookies implements Dessert {<br>}<br>@Component<br>public class Cake implements Dessert {<br>}<br>@Component<br>public class IceCream implements Dessert {<br>}</p>
<a id="more"></a>

<p>这三个类均使用了@Component注解，在组件扫描的时候，能够发现他们并将其创建为Spring上下文中的bean。下面是测试代码：</p>
<p>import cn.javacodes.spring.beans.Dessert;<br>import cn.javacodes.spring.configuration.SpringConfig;<br>import org.junit.runner.RunWith;<br>import org.springframework.beans.factory.annotation.Autowired;<br>import org.springframework.test.context.ContextConfiguration;<br>import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;<br>import static org.junit.Assert.assertNotNull;<br>/**<br> * Created by Eric on 2016/10/20.<br> */<br>@RunWith(SpringJUnit4ClassRunner.class)<br>@ContextConfiguration(classes = SpringConfig.class)<br>public class Test {<br>    private Dessert dessert ;<br>    @Autowired<br>    public void setDessert(Dessert dessert){<br>        this.dessert = dessert;<br>    }<br>    @org.junit.Test<br>    public void test(){<br>        assertNotNull(dessert);<br>    }<br>}</p>
<p>当Spring试图自动装配setDessert()中的Dessert参数时，它并没有唯一、无歧义的可选值。所以Spring会抛出一个异常：</p>
<p>org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name ‘Test’: Unsatisfied dependency expressed through method ‘setDessert’ parameter 0: No qualifying bean of type [cn.javacodes.spring.beans.Dessert] is defined: expected single matching bean but found 3: cake,cookies,iceCream; nested exception is org.springframework.beans.factory.NoUniqueBeanDefinitionException: No qualifying bean of type [cn.javacodes.spring.beans.Dessert] is defined: expected single matching bean but found 3: cake,cookies,iceCream</p>
<p>为了解决这个问题，Spring提供了多种解决方案，标示首选的bean（primary）和使用限定符（qualifier）。</p>
<h3 id="一、标示首选的bean"><a href="#一、标示首选的bean" class="headerlink" title="一、标示首选的bean"></a>一、标示首选的bean</h3><p>在声明bean的时候，我们可以通过将其中一个可选的bean设置为首选（primary） bean，这样就可以避免歧义性了，使用方式如下，例如我们想将IceCream作为首选bean：</p>
<p>@Component<br>@Primary<br>public class IceCream implements Dessert {<br>}</p>
<p>当然了，你也可以在显式声明bean的时候将其设置为首选bean，比如：</p>
<pre><code>@Bean
@Primary
public Dessert IceCream(){
    return new IceCream();
}</code></pre><p>当然，如果你喜欢使用XML来配置Bean，那么其方法如下：</p>
<pre><code>&lt;bean id=&quot;iceCream&quot; class=&quot;cn.javacodes.spring.beans.IceCream&quot;
      primary=&quot;true&quot; /&gt;</code></pre><p>使用哪种方式告诉Spring首选bean的效果都是一样的，不过，如果你标示了两个或更多的首选bean，那么它就无法工作了，因为这又会带来歧义性的问题。</p>
<p>当然我们可以使用另一种更为强大的机制（限定符）来解决这个问题。</p>
<h3 id="二、使用限定符"><a href="#二、使用限定符" class="headerlink" title="二、使用限定符"></a>二、使用限定符</h3><h4 id="（一）-Qualifier注解"><a href="#（一）-Qualifier注解" class="headerlink" title="（一）@Qualifier注解"></a>（一）@Qualifier注解</h4><p>使用@Primary无法将可选方案的范围限定到唯一一个无歧义的选项，它只能标示一个优先的可选选项。当首选bean的数量超过1个时，我们并没有其它的办法将其限定到唯一的选项上。</p>
<p>Spring提供的限定符可以解决这个问题，@Qualifier注解是使用限定符的主要方式。它可以与@Autowired或@Inject协同使用。例如，我们想确保IceCream注入到setDessert(）之中：</p>
<pre><code>@Autowired
@Qualifier(&quot;iceCream&quot;)
public void setDessert(Dessert dessert){
    this.dessert = dessert;
}</code></pre><p>这是使用限定符最简单的例子了。为@Qualifier注解所设置的参数就是想要注入的bean的ID。所有使用@Component注解声明的类都会创建为bean，并且bean的ID为首字母变为小写的类名，因此这个例子中使用iceCream作为参数指向组件扫描时所创建的IceCream bean。</p>
<p>实际上，更准确的讲，@Qualifier(“iceCream”)所引用的bean要具有String类型的“iceCream”作为限定符。如果没有制定其他的限定符，那么所有的bean都会有一个默认的限定符，它的值为bean的ID。因此框架会将具有“iceCream”限定符的bean注入到setDessert()方法中。这恰巧就是ID为iceCream的bean。</p>
<p>基于默认的限定符看起来是很简单的，不过这里面存在一个问题，如果日后我们进行重构的时候，如果更改了IceCream类的类名比如更改为Gelato的话，那么自动创建的bean的ID就会变为“gelato”，这就无法匹配我们之前所写的限定符了，导致自动装配失败。</p>
<p>所以在这里setDessert()方法上所指定的限定符与要注入的bean的名称是紧耦合的。对类名称的任意改动都会造成限定符失效。</p>
<h4 id="（二）创建自定义的限定符"><a href="#（二）创建自定义的限定符" class="headerlink" title="（二）创建自定义的限定符"></a>（二）创建自定义的限定符</h4><p>我们可以为bean设置自己的限定符，而不是依赖与将bean ID作为限定符。例如：</p>
<p>@Component<br>@Qualifier(“cold”)<br>public class IceCream implements Dessert {<br>}</p>
<p>这样就解决了之前耦合类名的问题，然后就可以在需要的地方使用这个限定符了，例如：</p>
<pre><code>@Autowired
@Qualifier(&quot;cold&quot;)
public void setDessert(Dessert dessert){
    this.dessert = dessert;
}</code></pre><p>当然，@Qualifier注解也可以与显式装配Bean的@Bean注解组合使用，再次不做赘述。</p>
<h4 id="（三）使用自定义限定符的注解"><a href="#（三）使用自定义限定符的注解" class="headerlink" title="（三）使用自定义限定符的注解"></a>（三）使用自定义限定符的注解</h4><p>上面的例子中使用了“cold”作为IceCream的限定符，在这里“cold”更像是一种特性来描述这个bean，当然，面向特性的限定符比bean ID更好一些，但是如果多个bean都具有相同的特性怎么办？</p>
<p>比如我们新加入一个类：</p>
<p>@Component<br>@Qualifier(“cold”)<br>public class Popsicle implements Dessert {<br>}</p>
<p>现在我们有了两个带有“cold”的限定符，自动装配的时候我们再次遇到了歧义性的问题，需要更多的限定符来将其可选范围缩小，现在我们可能想到的解决办法可能是类似像下面这种方式，使用多个@Qualifier注解：</p>
<p>@Component<br>@Qualifier(“cold”)<br>@Qualifier(“creamy”)<br>public class IceCream implements Dessert {<br>}</p>
<p>但是这种方式是不行的，Java语言不允许在同一个条目上重复出现相同类型的注解（Java 8允许出现重复的注解，但是这个注解本身必须在定义的时候带有@Repeatable，可是Spring的@Qualifier注解并没有在定义时加入@Repeatable），为了解决这个问题，我们可以创建一个自定义的限定符注解，它本身需要使用@Qualifier注解来标注，例如：</p>
<p>@Target({ElementType.CONSTRUCTOR,ElementType.FIELD,ElementType.METHOD,ElementType.TYPE})<br>@Retention(RetentionPolicy.RUNTIME)<br>@Qualifier<br>public @interface Cold {<br>}</p>
<p>同样你可以在创建一个Creamy注解来替代@Qualifier(“creamy”)：</p>
<p>@Target({ElementType.CONSTRUCTOR, ElementType.FIELD,ElementType.METHOD,ElementType.TYPE})<br>@Retention(RetentionPolicy.RUNTIME)<br>@Qualifier<br>public @interface Creamy {<br>}</p>
<p>同样的原理，你还可以创建类似@Soft、@Crispy等等其它注解。通过在定义注解的时候添加@Qualifier，这些注解就具有了Qualifier的特性，他们本身世界上就是一个限定符。现在我们重新编辑一下IceCream：</p>
<p>@Component<br>@Cold<br>@Creamy<br>public class IceCream implements Dessert {<br>}</p>
<p>类似的，Popsicle类可以添加@Cold、@Fruity注解：</p>
<p>@Component<br>@Fruity<br>@Cold<br>public class Popsicle implements Dessert {<br>}</p>
<p>最终，在注入点，我们使用必要的限定符注解进行任意组合即可：</p>
<pre><code>@Autowired
@Cold
@Creamy
public void setDessert(Dessert dessert){
    this.dessert = dessert;
}</code></pre><p>这样我们就可以随心所欲的使用自定义限定符注解来缩小匹配范围啦！当然，还是希望Spring可以尽快在新的版本中将@Qualifier注解中加入@Repeatable注解，这样就不用这么麻烦了（我估计要很久，因为Spring还需要保证在相对旧的Java版本上做兼容，Java 8的这一特性估计不会这么快被支持的）！</p>
]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>Spring学习笔记</tag>
        <tag>@Qualifier</tag>
        <tag>Primary</tag>
        <tag>自动装配歧义性</tag>
        <tag>首选Bean</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring学习笔记之自动化装配Bean</title>
    <url>/2016/09/18/Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E8%87%AA%E5%8A%A8%E5%8C%96%E8%A3%85%E9%85%8DBean/</url>
    <content><![CDATA[<p>在Spring中可以使用Java代码、XML和自动化装配三种方式来装配Bean。从便利性角度来说，最强大的还是Spring的自动化配置，如果Spring能够进行自动化装配的话，那何苦还要显式的将这些Bean装配在一起呢？ Spring从两个角度来实现自动化装配： 组件扫描：Spring会自动发现应用上下文中所创建的Bean； 自动装配：Spring自动满足bean之间的依赖。 为了阐述组件扫描和装配，我们需要创建几个Bean，它们代表了一个音响系统中的组件。</p>
<a id="more"></a>

<h3 id="一、创建可被发现的bean"><a href="#一、创建可被发现的bean" class="headerlink" title="一、创建可被发现的bean"></a>一、创建可被发现的bean</h3><p>定义CD的一个接口：</p>
<p>package cn.javacodes.spring.beans.soundsystem;<br>public interface CompactDisc {<br>    void play();<br>}</p>
<p>CompactDisc接口定义了CD播放器对一盘CD所能进行的操作。它将CD播放器的任意实现与CD本身的耦合降低到了最小的程度。 下面创建一个CompactDisc的实现：</p>
<p>package cn.javacodes.spring.beans.soundsystem;<br>import org.springframework.stereotype.Component;<br>@Component<br>public class Transfer implements CompactDisc {<br>    private String title = “transfer”;<br>    private String artist = “周传雄/小刚”;<br>    public void play() {<br>        System.out.println(“正在播放”+artist+”的专辑：” + title);<br>    }<br>}</p>
<p>这里需要注意的是该类使用了@Component注解，表明该类会作为组件类，并告知Spring要为这个组件创建bean。但是在这之前，由于默认组件扫描是不启用的。我们还需要显式配置一下Spring，从而命令它去寻找带有@Component注解的类，并为其创建bean。 下面的这个类展现了完成这件事情的最简介配置方式：</p>
<p>package cn.javacodes.spring.beans.soundsystem;<br>import org.springframework.context.annotation.ComponentScan;<br>import org.springframework.context.annotation.Configuration;<br>@Configuration<br>@ComponentScan<br>public class CDPlayerConfig {<br>}</p>
<p>如果没有其他配置的话，@ComponentScan默认会扫描与配置类相同的包。因为CDPlayerConfig类位于cn.javacodes.spring.beans.soundsystem包中，因此Spring将会扫描这个包以及这个包下的所有子包，查找带有@Component注解标示的类，并在Spring中自动为其创建一个bean。 当然，如果你更加倾向于使用XML来启用组件扫描的话，那么可以使用Spring context命名空间的<a href="context:component-scan">context:component-scan</a>元素。</p>
<?xml version="1.0" encoding="UTF-8"?>
<p><beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:configurator="http://www.springframework.org/schema/c"
       xmlns:avalon="http://www.springframework.org/schema/p"
       xmlns:context="http://www.springframework.org/schema/context"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"><br>    &lt;context:component-scan base-package=”cn.javacodes.spring.beans.soundsystem”/&gt;<br></beans></p>
<p>尽管我们可以使用XML的方案来启用组件扫描，但在后面的讨论中，更多的还是会使用基于Java的配置。 下面我们创建一个简单的JUnit测试，它会创建Spring上下文，并判断CompactDisc是不是真的创建出来了。</p>
<p>package cn.javacodes.spring.beans.soundsystem;<br>import org.junit.Test;<br>import org.junit.runner.RunWith;<br>import org.springframework.beans.factory.annotation.Autowired;<br>import org.springframework.test.context.ContextConfiguration;<br>import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;<br>import static org.junit.Assert.assertNotNull;<br>@RunWith(SpringJUnit4ClassRunner.class)<br>@ContextConfiguration(classes = CDPlayerConfig.class)<br>public class CDPlayerTest {<br>    @Autowired<br>    private CompactDisc cd;<br>    @Test<br>    public void cdShouldNotBeNull(){<br>        assertNotNull(cd);<br>    }<br>}</p>
<p>该类使用了Spring的SpringJUnit4ClassRunner，以便在测试开始的时候自动创建Spring的上下文。注解@ContextConfiguration会告诉它需要在CDPlayerConfig中加载配置。因为CDPlayerConfig类中包含了@ComponentScan注解，因此最终的应用上下文中应该包含CompactDisc bean。 为了证明这一点，在测试代码中有一个CompactDisc属性，并且这个属性带有@Autowired注解，以便于将CompactDisc bean注入到测试代码中，有关与@Autowired注解的更多内容将在后面讲述。最后，有一个简单的测试方法断言cd属性不为null。如果它不为null的话，就意味着Spring能够发现CompactDisc类，自动在Spring上下文中将其创建为bean并将其注入到了测试代码中。 这个代码应该能够通过测试，并以测试成功的颜色显示。</p>
<h3 id="二、为组件扫描的bean命名"><a href="#二、为组件扫描的bean命名" class="headerlink" title="二、为组件扫描的bean命名"></a>二、为组件扫描的bean命名</h3><p>Spring上下文中所有的bean都有一个id。在前面的例子中，即使我们并没有明确的给定Transfer bean一个id，但Spring会根据类名为其给定一个id。具体来讲，Spring会默认给定一个将类名首字母变为小写的id，例如上例中将给定的id为transfer。 如果想为这个bean给定不同的id，你需要做的就是将你所想要给定的id作为参数传递给@Component注解。例如：</p>
<p>package cn.javacodes.spring.beans.soundsystem;<br>import org.springframework.stereotype.Component;<br>@Component(“transfer”)<br>public class Transfer implements CompactDisc {<br>    private String title = “transfer”;<br>    private String artist = “周传雄/小刚”;<br>    public void play() {<br>        System.out.println(“正在播放”+artist+”的专辑：” + title);<br>    }<br>}</p>
<p>还有另外一种为bean命名的方式，使用Java依赖注入规范中提供的@Named注解来为bean设置id：</p>
<p>package cn.javacodes.spring.beans.soundsystem;<br>import javax.inject.Named;<br>@Named(“transfer”)<br>public class Transfer implements CompactDisc {<br>    private String title = “transfer”;<br>    private String artist = “周传雄/小刚”;<br>    public void play() {<br>        System.out.println(“正在播放”+artist+”的专辑：” + title);<br>    }<br>}</p>
<p>Spring支持将@Named作为@Component注解的替代方案。两者之间有一些细微的差别，不过大多数场景种它们使可以相互替换的。但是推荐使用@Component而不是@Named，因为@Component注解看起来更加能够知道它是干什么的。</p>
<h3 id="三、设置组件扫描的基础包"><a href="#三、设置组件扫描的基础包" class="headerlink" title="三、设置组件扫描的基础包"></a>三、设置组件扫描的基础包</h3><p>现在我们已经知道，默认情况下@ComponentScan注解会扫描当前配置类所在的包及其子包，但我们可能更希望将配置类与其它类放在不同的包中，那么为了指定不同的基础包，可以将指定的包名作为参数传递给@ComponentScan注解即可：</p>
<p>@Configuration<br>@ComponentScan(“cn.javacodes.spring.beans.soundsystem”)<br>public class CDPlayerConfig {<br>}</p>
<p>当然也可以更加清晰的指明其是基础包，使用basePackages属性：</p>
<p>@Configuration<br>@ComponentScan(basePackages = “cn.javacodes.spring.beans.soundsystem”)<br>public class CDPlayerConfig {<br>}</p>
<p>这里我们发现basePackages属性是复数形式，我们猜测它是否可以指定多个基础包呢？答案是正确的，如果想要指定多个包，那么只需要将要扫描的包放到一个数组中即可：</p>
<p>@Configuration<br>@ComponentScan(basePackages = {“cn.javacodes.spring.beans.soundsystem”, “cn.javacodes.spring.beans.video”})<br>public class CDPlayerConfig {<br>}</p>
<p>上面的方式中，包名以简单的字符串进行表示，当然这是可以的。但是如果我们日后对代码进行重构，很有可能就会出现问题，所以这种通过简单的字符串来配置基础包的方式是不安全的。为了解决这个问题，我们可以将其指定为包中所包含的类或接口：</p>
<p>package cn.javacodes.spring.configuration;<br>import cn.javacodes.spring.beans.soundsystem.CDPlayer;<br>import cn.javacodes.spring.beans.video.DVDPlayer;<br>import org.springframework.context.annotation.ComponentScan;<br>import org.springframework.context.annotation.Configuration;<br>@Configuration<br>@ComponentScan(basePackageClasses = {CDPlayer.class, DVDPlayer.class})<br>public class CDPlayerConfig {<br>}</p>
<p>注意：这里不再使用basePackages属性，取而代之的是basePackageClasses属性。我们不再使用String类型的包名来指定包，而是为basePackageClasses属性设置的数组中包含了类。这些类所在的包会作为组件扫描的基础包。 当然，使用组件类直接给basePackageClasses属性并不是很好的方式，我们可以考虑在包中创建一个用来进行扫描的空标记接口。通过标记接口的方式，你依然能够保持对重构友好的接口引用，但是可以避免引用任何实际的应用程序代码。</p>
<h3 id="四、通过为bean添加注解实现自动装配"><a href="#四、通过为bean添加注解实现自动装配" class="headerlink" title="四、通过为bean添加注解实现自动装配"></a>四、通过为bean添加注解实现自动装配</h3><p>简单来说，自动装配就是让Spring自动满足bean依赖的一种方法，在满足依赖的过程中，会在Spring应用上下文中寻找匹配某个bean需求的其它bean。为了声明要进行自动装配，我们可以考虑使用Spring的@Autowired注解。 比如下面的CDPlayer类，它的构造器使用了@Autowired注解，表明当Spring创建CDPlayer bean的时候，会通过这个构造器来进行实例化并会传入一个可以设置给CompactDisc类型的bean：</p>
<p>package cn.javacodes.spring.beans.soundsystem;<br>import org.springframework.beans.factory.annotation.Autowired;<br>import org.springframework.stereotype.Component;<br>@Component<br>public class CDPlayer {<br>    private CompactDisc cd;<br>    @Autowired<br>    public CDPlayer(CompactDisc cd) {<br>        this.cd = cd;<br>    }</p>
<pre><code>public void play(){
    cd.play();
}</code></pre><p>}</p>
<p>@Autowired属性不仅可以用在构造器上，还可以用在属性的Setter方法上。比如说，如果CDPlayer有一个setCompactDisc()方法，那么可以采用下面的方式来进行自动装配：</p>
<pre><code>@Autowired
public void setCompactDisc(CompactDisc cd){
    this.cd = cd;
}</code></pre><p>在Spring完成初始化bean之后，它会尽可能的去满足bean的依赖。实际上，Setter方法并没有什么特殊之处，@Autowired可以出现在任何方法上。 假如有且只有一个bean匹配依赖需求的话，那么这个bean将会被封装起来。 如果没有匹配的bean，那么在应用上下文创建的时候，Spring将会抛出一个异常。为了避免异常，可以将@Autowired的required属性设置为false，Spring会尝试执行自动匹配，但是如果没有匹配的bean的话，Spring会让这个bean处于未装配的状态：</p>
<pre><code>@Autowired(required = false)
public CDPlayer(CompactDisc cd) {
    this.cd = cd;
}</code></pre><p>但是，把required属性设置为false的时候你需要注意，如果你的代码中没有null检查的话，这个处于未装配状态的属性有可能会出现空指针异常（NullPointerException）。 如果有多个bean都能满足依赖关系的话，Spring会抛出一个异常，表明没有明确指定要选择哪个bean进行装配，有关于Spring自动化装配的歧义性的问题，我会在后续的文章中进行说明。 @Autowired是Spring特有的注解，如果你不希望在代码中到处使用Spring特有的注解的话，那么可以考虑使用@Inject注解对其进行替换，例如：</p>
<p>package cn.javacodes.spring.beans.soundsystem;<br>import javax.inject.Inject;<br>import javax.inject.Named;<br>@Named<br>public class CDPlayer {<br>    private CompactDisc cd;<br>    @Inject<br>    public CDPlayer(CompactDisc cd) {<br>        this.cd = cd;<br>    }<br>    public void play(){<br>        cd.play();<br>    }<br>}</p>
<p>@Inject注解来源于Java依赖注入规范，同@Named注解一样，@Inject注解与@Autowired注解存在一些细微的差别，但大多数情况下它们可以进行相互替换。</p>
<h3 id="五、验证自动装配"><a href="#五、验证自动装配" class="headerlink" title="五、验证自动装配"></a>五、验证自动装配</h3><p>我们修改一下测试类CDPlayerTest，使其能够借助CDPlayer bean播放CD：</p>
<p>package cn.javacodes.spring.beans.soundsystem;<br>import cn.javacodes.spring.beans.MediaPlayer;<br>import cn.javacodes.spring.configuration.CDPlayerConfig;<br>import org.junit.Rule;<br>import org.junit.Test;<br>import org.junit.contrib.java.lang.system.StandardOutputStreamLog;<br>import org.junit.runner.RunWith;<br>import org.springframework.beans.factory.annotation.Autowired;<br>import org.springframework.test.context.ContextConfiguration;<br>import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;<br>import static org.junit.Assert.assertEquals;<br>import static org.junit.Assert.assertNotNull;<br>@RunWith(SpringJUnit4ClassRunner.class)<br>@ContextConfiguration(classes = CDPlayerConfig.class)<br>public class CDPlayerTest {<br>    @Rule<br>    public final StandardOutputStreamLog log = new StandardOutputStreamLog();<br>    @Autowired<br>    private MediaPlayer player;<br>    @Autowired<br>    private CompactDisc cd;<br>    @Test<br>    public void cdShouldNotBeNull() {<br>        assertNotNull(cd);<br>    }<br>    @Test<br>    public void play() {<br>        player.play();<br>        assertEquals(“正在播放周传雄/小刚的专辑：transfern”, log.getLog());<br>    }<br>}</p>
<p>该类中，除了注入CompactDisc，还将CDPlayer bean注入到了测试代码中（更为通用的MediaPlayer类型）。在play()方法中，我们可以调用CDPlayer的play()方法并断言它的行为与你的预期是否一致。 自动化装配Bean还有更多的细节，我会在后续的文章中进行阐述。</p>
]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>Spring学习笔记</tag>
        <tag>Spring自动装配</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring学习笔记之通过Java代码装配Bean</title>
    <url>/2016/10/20/Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E9%80%9A%E8%BF%87Java%E4%BB%A3%E7%A0%81%E8%A3%85%E9%85%8DBean/</url>
    <content><![CDATA[<p>虽然很多场景下可以使用组件扫描和自动装配来实现Spring的自动化配置，但有些时候自动化配置的方案是行不通的，因此需要明确配置Spring。比如你想讲第三方库中的组件装配到你的应用中，在这种情况下，你必须要显式装配。在进行显式配置的时候，有两种方案，Java和XML。</p>
<p>下面介绍通过Java代码显式装配Bean。</p>
<a id="more"></a>

<h3 id="一、创建配置类"><a href="#一、创建配置类" class="headerlink" title="一、创建配置类"></a>一、创建配置类</h3><p>创建配置类的关键在于@Configuration注解，@Configuration注解表明该类是一个配置类，该类包含了在Spring上下文中如何创建Bean的细节。</p>
<p>package cn.javacodes.spring.configuration;<br>import org.springframework.context.annotation.Configuration;<br>/**<br> * Created by Eric on 2016/10/16.<br> */<br>@Configuration<br>public class CDPlayerConfig {<br>}</p>
<h3 id="二、声明简单的Bean"><a href="#二、声明简单的Bean" class="headerlink" title="二、声明简单的Bean"></a>二、声明简单的Bean</h3><p>要在JavaConfig中声明Bean，我们需要写一个方法，这个方法会创建所需类型的实例，然后给这个方法添加@Bean注解。比如下面的代码声明了CompactDisc Bean：</p>
<pre><code>@Bean
public CompactDisc transfer(){
    return new Transfer();
}</code></pre><p>@Bean注解会告诉Spring这个方法会返回一个对象，该对象要注册为Spring应用上下文中的bean。方法体中包含了最终产生bean对象的逻辑。</p>
<p>默认情况下，bean的ID于带有@Bean注解方法的名称是一样的。在上面的例子中，bean的名字将会是“transfer”。如果你想为它设置一个不同的名字，可以通过name属性指定它的ID：</p>
<pre><code>@Bean(name = &quot;transfer-cd&quot;)
public CompactDisc transfer(){
    return new Transfer();
}</code></pre><p>另外，方法中的方法体可以是任何你想创建Bean的逻辑，比如你想在一组CD中随机选取一个CD进行播放也是可以的。</p>
<h3 id="三、借助JavaConfig实现注入"><a href="#三、借助JavaConfig实现注入" class="headerlink" title="三、借助JavaConfig实现注入"></a>三、借助JavaConfig实现注入</h3><p>前面声明的CompactDisc Bean是非常简单的，因为它没有任何依赖，那么现在想要声明一个CDPlayer Bean，它依赖于CompactDisc。</p>
<h4 id="（一）引用创建Bean的方法"><a href="#（一）引用创建Bean的方法" class="headerlink" title="（一）引用创建Bean的方法"></a>（一）引用创建Bean的方法</h4><pre><code>@Bean
public CDPlayer cdPlayer(){
    return new CDPlayer(transfer());
}</code></pre><p>这里同样使用了@Bean注解，并在构造CDPlayer时将CompactDisc作为CDPlayer构造器的参数传入。</p>
<p>注意：这里虽然看起来是通过调用transfer()方法得到CompactDisc，但由于transfer方法使用了@Bean注解，实际上Spring会拦截所有对它的调用，并确保直接返回该方法所创建的Spring上下文中的bean，而不是每次都对其进行实际的调用。</p>
<p>比如说，假设你引入了另一个其他的CDPlayer Bean，它和之前的那个bean完全一样。</p>
<pre><code>@Bean
public CDPlayer cdPlayer(){
    return new CDPlayer(transfer());
}
@Bean
public CDPlayer anotherCDPlayer(){
    return new CDPlayer(transfer());
}</code></pre><p>默认情况下，Spring中的bean都是单例的，我们并没有必要为第二个CDPlayer Bean创建完全相同的CompactDisc实例。Spring会拦截对@Bean注解标注方法的调用并确保返回的是Spring创建的Bean。</p>
<h4 id="（二）将依赖作为参数"><a href="#（二）将依赖作为参数" class="headerlink" title="（二）将依赖作为参数"></a>（二）将依赖作为参数</h4><p>可以看到通过引用创建Bean的方法来解决这个问题有些让人疑惑，下面这种方式看起来更为容易理解：</p>
<pre><code>@Bean
public CDPlayer cdPlayer(CompactDisc compactDisc){
    return new CDPlayer(compactDisc);
}</code></pre><p>在这里，cdPlayer()方法请求一个CompactDisc作为参数。当Spring调用cdPlayer()方法创建bean的时候，它会自动装配一个CompactDisc到配置方法中。这样方法体就可以在合适的位置使用它，通过这种方式可以避免明确的调用@Bean方法。</p>
<p>通过这种方式来引用其它Bean是最佳的选择，因为它不要求将依赖声明到同一个配置类当中，甚至它不要求必须要在JavaConfig中声明，实际上它可以通过组件扫描功能来自动发现或者通过XML来进行配置。</p>
<p>本例中使用了CDPlayer的构造器实现了DI（依赖注入），但是完全可以使用其它风格的DI，比如，你可以使用setter的方式进行注入。</p>
]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>Spring学习笔记</tag>
        <tag>Java代码装配Bean</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring学习笔记之通过XML装配Bean的一些细节</title>
    <url>/2016/10/20/Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E9%80%9A%E8%BF%87XML%E8%A3%85%E9%85%8DBean%E7%9A%84%E4%B8%80%E4%BA%9B%E7%BB%86%E8%8A%82/</url>
    <content><![CDATA[<h3 id="一、c命名空间"><a href="#一、c命名空间" class="headerlink" title="一、c命名空间"></a>一、c命名空间</h3><p>通过构造器注入Bean的时候通常需要使用到<constructor-arg>元素，作为替代的方案，可以使用Spring的c-命名空间。c-命名空间是在Spring 3.0中加入的，它是在XML中更为简洁地描述构造器参数的方式。要使用c-命名空间，必须要在XML的顶部声明其模式，如下所示：</p>
<?xml version="1.0" encoding="UTF-8"?>
<p><beans xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns="http://www.springframework.org/schema/beans"
       xmlns:c="http://www.springframework.org/schema/c"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"><br></beans></p>
<a id="more"></a>

<p>在c-命名空间和模式声明后，就可以使用它来声明构造器参数了，如下所示：</p>
<p><bean id="compactDisc" class="cn.javacodes.spring.beans.soundsystem.Transfer"></bean></p>
<pre><code>&lt;bean id=&quot;cdPlayer&quot; class=&quot;cn.javacodes.spring.beans.soundsystem.CDPlayer&quot;
      c:cd-ref=&quot;compactDisc&quot; /&gt;</code></pre><p>可以看到上面的方式也有一些问题，c:cd-ref中的cd即为构造器参数的名称，这种方式对于后期代码的重构是非常不友好的，那么为了解决这个问题，可以使用参数的索引来替代参数名称，如下所示：</p>
<pre><code>&lt;bean id=&quot;compactDisc&quot; class=&quot;cn.javacodes.spring.beans.soundsystem.Transfer&quot;&gt;&lt;/bean&gt;
&lt;bean id=&quot;cdPlayer&quot; class=&quot;cn.javacodes.spring.beans.soundsystem.CDPlayer&quot;
      c:_0-ref=&quot;compactDisc&quot; /&gt;</code></pre><p>当然如果构造器只有一个参数，可以连索引一起略去：</p>
<pre><code>&lt;bean id=&quot;compactDisc&quot; class=&quot;cn.javacodes.spring.beans.soundsystem.Transfer&quot;&gt;&lt;/bean&gt;
&lt;bean id=&quot;cdPlayer&quot; class=&quot;cn.javacodes.spring.beans.soundsystem.CDPlayer&quot;
      c:_-ref=&quot;compactDisc&quot; /&gt;</code></pre><p>不过在我的测试中，这种方式在idea中会报错。</p>
<h3 id="二、装配集合"><a href="#二、装配集合" class="headerlink" title="二、装配集合"></a>二、装配集合</h3><h4 id="（一）装配List和Set"><a href="#（一）装配List和Set" class="headerlink" title="（一）装配List和Set"></a>（一）装配List和Set</h4><p>BlankDisc类的代码如下：</p>
<p>package cn.javacodes.spring.beans.soundsystem.collections;<br>import cn.javacodes.spring.beans.soundsystem.CompactDisc;<br>import java.util.List;<br>/**<br> * Created by Eric on 2016/10/16.<br> */<br>public class BlankDisc implements CompactDisc {<br>    private String title;<br>    private String artist;<br>    private List<String> tracks;<br>    public BlankDisc(String title, String artist, List<String> tracks) {<br>        this.title = title;<br>        this.artist = artist;<br>        this.tracks = tracks;<br>    }<br>    public void play() {<br>        System.out.println(“正在播放” + artist + “的专辑：” + title);<br>        for (String track : tracks) {<br>            System.out.println(“-Track：” + track);<br>        }<br>    }<br>}</p>
<p>在Spring中配置这个类的bean时需要提供一个list，当然，你可以给它传递为空值：</p>
<pre><code>&lt;bean id=&quot;compactDisc&quot; class=&quot;cn.javacodes.spring.beans.soundsystem.collections.BlankDisc&quot;&gt;
    &lt;constructor-arg value=&quot;Transfer&quot;&gt;&lt;/constructor-arg&gt;
    &lt;constructor-arg value=&quot;周传雄/小刚&quot;&gt;&lt;/constructor-arg&gt;
    &lt;constructor-arg&gt;&lt;null/&gt;&lt;/constructor-arg&gt;
&lt;/bean&gt;</code></pre><p>不过如果传递null的话，当调用play()方法时，必然会产生NullPointerException异常，通常情况下，我们更多的给它装配一个List。</p>
<p>我们有很多种解决方案，首先，可以使用<list>元素将其声明为一个列表：</p>
<pre><code>&lt;bean id=&quot;compactDisc&quot; class=&quot;cn.javacodes.spring.beans.soundsystem.collections.BlankDisc&quot;&gt;
    &lt;constructor-arg value=&quot;Transfer&quot;&gt;&lt;/constructor-arg&gt;
    &lt;constructor-arg value=&quot;周传雄/小刚&quot;&gt;&lt;/constructor-arg&gt;
    &lt;constructor-arg&gt;
        &lt;list&gt;
            &lt;value&gt;忘记&lt;/value&gt;
            &lt;value&gt;出卖&lt;/value&gt;
            &lt;value&gt;寂寞轰炸&lt;/value&gt;
            &lt;value&gt;游戏爱情&lt;/value&gt;
            &lt;value&gt;心结&lt;/value&gt;
            &lt;value&gt;记事本&lt;/value&gt;
            &lt;value&gt;啤酒泡泡&lt;/value&gt;
            &lt;value&gt;黄昏&lt;/value&gt;
            &lt;value&gt;末班车&lt;/value&gt;
            &lt;value&gt;心血来潮&lt;/value&gt;
            &lt;value&gt;时间&lt;/value&gt;
        &lt;/list&gt;
    &lt;/constructor-arg&gt;
&lt;/bean&gt;</code></pre><p>当然，也可以使用<ref>来替代<value>达到引用其它bean的目的，再次不做赘述。</p>
<p>在我们的例子中构造器参数类型为List，因此使用<list>元素进行注入是合情合理的，尽管如此，我们仍然可以使用<set>元素来进行注入：</p>
<bean id="compactDisc" class="cn.javacodes.spring.beans.soundsystem.collections.BlankDisc">
        <constructor-arg value="Transfer"></constructor-arg>
        <constructor-arg value="周传雄/小刚"></constructor-arg>
        <constructor-arg>
            <set>
                <value>忘记</value>
                <value>出卖</value>
                <value>寂寞轰炸</value>
                <value>游戏爱情</value>
                <value>心结</value>
                <value>记事本</value>
                <value>啤酒泡泡</value>
                <value>黄昏</value>
                <value>末班车</value>
                <value>心血来潮</value>
                <value>时间</value>
            </set>
        </constructor-arg>
    </bean>

<p><set>和<list>元素的区别并不大，其中最重要的区别在于Spring创建要装配的集合时，所创建的是Set还是List。如果是Set的话，所有重复的值都会被忽略掉，并且存放的顺序也不会得到保证，这个相信大家对Set和List的区别都有明确的认识。不过无论哪种情况下，<set>和<list>都可以用来装配List、Set甚至数组。</p>
<h4 id="（二）、装配Map"><a href="#（二）、装配Map" class="headerlink" title="（二）、装配Map"></a>（二）、装配Map</h4><p>我们将上面的BlankDisc稍作改动，将原有的List改为Map：</p>
<pre><code>private String title;
private String artist;
private Map&lt;String,String&gt; tracks;
public BlankDisc(String title, String artist, Map&lt;String, String&gt; tracks) {
    this.title = title;
    this.artist = artist;
    this.tracks = tracks;
}</code></pre><p>装配Map的方式如下：</p>
<pre><code>&lt;bean id=&quot;compactDisc&quot; class=&quot;cn.javacodes.spring.beans.soundsystem.collections.BlankDisc&quot;&gt;
    &lt;constructor-arg value=&quot;Transfer&quot;&gt;&lt;/constructor-arg&gt;
    &lt;constructor-arg value=&quot;周传雄/小刚&quot;&gt;&lt;/constructor-arg&gt;
    &lt;constructor-arg&gt;
        &lt;map&gt;
            &lt;entry key=&quot;忘记&quot; value=&quot;5:12&quot;/&gt;
            &lt;entry key=&quot;出卖&quot; value=&quot;4:54&quot;/&gt;
            &lt;entry …… 
        &lt;/map&gt;
    &lt;/constructor-arg&gt;
&lt;/bean&gt;</code></pre><p>当然<key>和<value>元素可以分别用<key-ref>和<value-ref>元素替代用于引用其它Bean。</p>
<h4 id="（三）、装配Properties"><a href="#（三）、装配Properties" class="headerlink" title="（三）、装配Properties"></a>（三）、装配Properties</h4><p>Properties与Map非常类似，不过区别主要在于Map的key和Value可以是任意类型的对象，而Properties要求key和value必须都是String类型，而很多场景下我们的key和value的确都是String类型，比如数据库连接信息的配置。</p>
<p>为了演示Properties的相关配置，我们创建一个类DataSource：</p>
<p>package cn.javacodes.spring.beans.properties;<br>import java.util.Properties;<br>/**<br> * Created by Eric on 2016/10/16.<br> */<br>public class DataSource {</p>
<pre><code>private Properties properties;
public DataSource(Properties properties) {
    this.properties = properties;
}
public Properties getProperties() {
    return properties;
}
public void setProperties(Properties properties) {
    this.properties = properties;
}</code></pre><p>}</p>
<p>在Spring XML配置如下：</p>
<pre><code>&lt;bean id=&quot;dataSource&quot; class=&quot;cn.javacodes.spring.beans.properties.DataSource&quot;&gt;
    &lt;constructor-arg&gt;
        &lt;props&gt;
            &lt;prop key=&quot;user&quot;&gt;root&lt;/prop&gt;
            &lt;prop key=&quot;password&quot;&gt;123456&lt;/prop&gt;
            &lt;prop key=&quot;url&quot;&gt;jdbc:mysql:///test&lt;/prop&gt;
            &lt;prop key=&quot;driver&quot;&gt;com.mysql.jdbc.Driver&lt;/prop&gt;
        &lt;/props&gt;
    &lt;/constructor-arg&gt;
&lt;/bean&gt;</code></pre><h3 id="三、p命名空间"><a href="#三、p命名空间" class="headerlink" title="三、p命名空间"></a>三、p命名空间</h3><p>我们知道配置bean的属性时需要使用<property>元素，为了简化这种方式，与c命名空间一样，Spring为我们提供了p命名空间。为了使用p-命名空间，必须在xml顶部进行声明：</p>
<?xml version="1.0" encoding="UTF-8"?>
<p><beans xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns="http://www.springframework.org/schema/beans"
       xmlns:p="http://www.springframework.org/schema/p"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"><br>……<br></beans></p>
<p>然后就可以使用p-命名空间了，使用方法如下：</p>
<pre><code>&lt;bean id=&quot;cdPlayer&quot; class=&quot;cn.javacodes.spring.beans.soundsystem.CDPlayer&quot;
    p:cd-ref=&quot;compactDisc&quot;/&gt;</code></pre><p>属性的名称以-ref结尾的，代表Spring要进行装配的是bean的引用而不是字面值（String）。</p>
<h3 id="四、util命名空间"><a href="#四、util命名空间" class="headerlink" title="四、util命名空间"></a>四、util命名空间</h3><p>p-命名空间和c-命名空间都不能对集合类型进行装配，不过我们可以使用util命名空间来简化对集合的装配，声明如下：</p>
<?xml version="1.0" encoding="UTF-8"?>
<p><beans xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns="http://www.springframework.org/schema/beans"
       xmlns:p="http://www.springframework.org/schema/p"
       xmlns:c="http://www.springframework.org/schema/c"
       xmlns:util="http://www.springframework.org/schema/util"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"><br></beans></p>
<p>现在就可以使用util命名空间了，例如：</p>
<pre><code>&lt;util:list id=&quot;trackList&quot;&gt;
    &lt;value&gt;忘记&lt;/value&gt;
    &lt;value&gt;出卖&lt;/value&gt;
    &lt;value&gt;寂寞轰炸&lt;/value&gt;
    &lt;value&gt;游戏爱情&lt;/value&gt;
    &lt;value&gt;心结&lt;/value&gt;
    &lt;value&gt;记事本&lt;/value&gt;
    &lt;value&gt;啤酒泡泡&lt;/value&gt;
    &lt;value&gt;黄昏&lt;/value&gt;
    &lt;value&gt;末班车&lt;/value&gt;
    &lt;value&gt;心血来潮&lt;/value&gt;
    &lt;value&gt;时间&lt;/value&gt;
&lt;/util:list&gt;</code></pre><p>然后就可以像引用其它Bean一样将list轻松引用，如下所示：</p>
<pre><code>&lt;bean id=&quot;compactDisc&quot; class=&quot;cn.javacodes.spring.beans.soundsystem.collections.BlankDisc&quot;
 c:title=&quot;Transfer&quot; c:artist=&quot;周传雄/小刚&quot; c:tracks-ref=&quot;trackList&quot;/&gt;</code></pre><p><a href="util:list">util:list</a>只是util-命名空间提供的众多元素之一，下表列出了util-命名空间提供的所有元素：</p>
<p>元素</p>
<p>描述</p>
<p><a href="util:constant">util:constant</a></p>
<p>引用某个类型的public static域，并墙漆暴露为bean</p>
<p><a href="util:list">util:list</a></p>
<p>创建一个java.util.List类型的bean，其中包含值或引用</p>
<p><a href="util:map">util:map</a></p>
<p>创建一个java.util.Map类型的bean，其中包含值或引用</p>
<p><a href="util:properties">util:properties</a></p>
<p>创建一个java.util.Properties类型的bean</p>
<p><a href="util:property-path">util:property-path</a></p>
<p>引用一个bean的属性（或内嵌属性），并将其暴露为bean</p>
<p><a href="util:set">util:set</a></p>
<p>创建一个java.util.set类型的bean，其中包含值或引用</p>
]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>Spring学习笔记</tag>
        <tag>c命名空间</tag>
        <tag>p命名空间</tag>
        <tag>util命名空间</tag>
        <tag>装配集合</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring学习笔记之配置Bean</title>
    <url>/2016/09/06/Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E9%85%8D%E7%BD%AEBean/</url>
    <content><![CDATA[<h3 id="一、在Spring的IOC容器中配置Bean"><a href="#一、在Spring的IOC容器中配置Bean" class="headerlink" title="一、在Spring的IOC容器中配置Bean"></a>一、在Spring的IOC容器中配置Bean</h3><p>可以通过Spring的XML配置文件来配置Bean，例如：</p>
<p>&lt;!-- 配置Bean –&gt;<br><bean id="helloWorld" class="cn.javacodes.spring.beans.HelloWorld"></bean></p>
<a id="more"></a>

<p>其中：</p>
<ul>
<li>id属性定义了Bean的名字，也作为该Bean在Spring容器中的引用；</li>
<li>class属性定义了该Bean的类型</li>
</ul>
<p>注意：</p>
<ul>
<li>id属性在IOC容器中是唯一的</li>
<li>若id没有指定，Spring自动将类名作为Bean的名字</li>
<li>id可以指定多个名字，名字之间可用逗号、分号、空格分隔</li>
</ul>
<h3 id="二、Spring容器"><a href="#二、Spring容器" class="headerlink" title="二、Spring容器"></a>二、Spring容器</h3><p>在Spring IOC容器读取Bean配置并创建Bean实例之前，必须对它进行实例化。只有容器实例化之后，才可以从IOC容器中获取Bean实例并使用。 Spring提供了两种类型的IOC容器实现，无论使用哪种方式，配置文件时完全相同：</p>
<ul>
<li>BeanFactory：IOC容器的基本（底层）实现。BeanFactory是Spring框架的基础设施，面向Spring本身；</li>
<li>ApplicationContext：提供了更多的高级特性，是BeanFactory的子接口。ApplicationContext面向使用Spring框架的开发者，几乎所有的应用场合都直接使用ApplicationContext而非底层的BeanFactory。</li>
</ul>
<h3 id="三、ApplicationContext"><a href="#三、ApplicationContext" class="headerlink" title="三、ApplicationContext"></a>三、ApplicationContext</h3><p><img data-src="https://cdn.javacodes.cn/files/2016/09/2016-09-06_15-19-57.png" alt="240570506"> ApplicationContext有两个主要的实现类：</p>
<ul>
<li>ClassPathXmlApplicationContext：从类路径下加载配置文件</li>
<li>FileSystemXmlApplicationContext：从文件系统中加载配置文件</li>
</ul>
<p>ConfigurableApplicationContext是ApplicationContext的子接口，增加了refresh()、close()等方法，让ApplicationContext具有了启动、刷新、关闭上下文的能力。</p>
<blockquote>
<p>注意：</p>
<ul>
<li>ApplicationContext在初始化上下文时就会实例化所有的单例Bean，及其scope（作用域）属性为singleton的Bean。</li>
<li>WebApplicationContext是专门为Web应用而准备的，它允许从相对于Web根目录的路径中完成初始化工作。</li>
</ul>
</blockquote>
<h3 id="四、依赖注入"><a href="#四、依赖注入" class="headerlink" title="四、依赖注入"></a>四、依赖注入</h3><p>Spring支持3种依赖注入的方式，分别是：</p>
<ul>
<li>属性注入（Setter注入）</li>
<li>构造器注入</li>
<li>工厂方法注入</li>
</ul>
<h4 id="1、属性注入"><a href="#1、属性注入" class="headerlink" title="1、属性注入"></a>1、属性注入</h4><bean id="helloWorld" class="cn.javacodes.spring.beans.HelloWorld">
        <property name="name" value="Spring 4.0" />
</bean>

<ul>
<li>属性注入即通过setter方法注入Bean的属性值或依赖的对象；</li>
<li>属性注入使用<property>元素，使用name指定Bean的属性名称，value属性或<value>子节点指定属性值，使用ref属性指定依赖的对象；</li>
<li>属性注入是最常用的注入方式；</li>
</ul>
<h4 id="2、构造方法注入"><a href="#2、构造方法注入" class="headerlink" title="2、构造方法注入"></a>2、构造方法注入</h4><p>通过构造方法注入Bean的属性值或依赖的对象，它保证了Bean在实例化后就可以使用。 构造器注入在<constructor-arg>元素里声明属性，<constructor-arg>中常用的属性有value、 index、type等，注意：没有name属性。 （1）按索引匹配入参</p>
<pre><code>&lt;!\-\- 构造器注入-通过索引 --&gt;
&lt;bean id=&quot;car0&quot; class=&quot;cn.javacodes.spring.beans.Car&quot;&gt;
    &lt;constructor-arg value=&quot;A6L&quot; index=&quot;0&quot;&gt;&lt;/constructor-arg&gt;
    &lt;constructor-arg value=&quot;奥迪&quot; index=&quot;1&quot;&gt;&lt;/constructor-arg&gt;
    &lt;constructor-arg value=&quot;15648&quot; index=&quot;2&quot;&gt;&lt;/constructor-arg&gt;
    &lt;constructor-arg value=&quot;240&quot; index=&quot;3&quot;&gt;&lt;/constructor-arg&gt;
&lt;/bean&gt;</code></pre><p>（2）按类型匹配入参</p>
<p>&lt;!-- 构造器注入-通过类型 –&gt;<br>    <bean id="car1" class="cn.javacodes.spring.beans.Car"><br>        <constructor-arg value="卡宴" type="java.lang.String"/><br>        <constructor-arg value="保时捷" type="java.lang.String"/><br>        <constructor-arg value="260" type="double"/><br>    </bean></p>
<h4 id="3、工厂方法注入"><a href="#3、工厂方法注入" class="headerlink" title="3、工厂方法注入"></a>3、工厂方法注入</h4><p>有时候静态工厂方法是实例化对象的唯一方法。Spring支持通过<bean>元素的factory-method属性类装配工厂创建的bean。 例如如下是一个Stage单例类：</p>
<p>package cn.javacodes.spring.beans;<br>/**<br> * Created by eric on 16-8-31.<br> */<br>public class Stage {<br>    private Stage() {<br>    }<br>    private static class StageSingletonHolder {<br>        static Stage instance = new Stage();<br>    }<br>    public static Stage getInstance() {<br>        return StageSingletonHolder.instance;<br>    }<br>}</p>
<p>我们注意到该类只有一个private的构造方法，而并未提供公开的构造方法，因此在Spring中不能直接通过之前所述的方式来获得该类的bean对象。为了解决这个问题，Spirng的<bean>标签提供了一个factory-method属性，配置如下所示：</p>
<p>&lt;!-- 静态工厂方法注入–&gt;<br>    <bean id="theStage" class="cn.javacodes.spring.beans.Stage" factory-method="getInstance" /></p>
]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>Spring学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>TCP加速锐速SS（ServerSpeeder）破解版一键安装</title>
    <url>/2016/10/30/TCP%E5%8A%A0%E9%80%9F%E9%94%90%E9%80%9FSS%EF%BC%88ServerSpeeder%EF%BC%89%E7%A0%B4%E8%A7%A3%E7%89%88%E4%B8%80%E9%94%AE%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<p>锐速（serverspeeder），是一款TCP加速程序，能够增强VPS/服务器连接的稳定性，且有效的提高服务器的带宽利用率，进而提高访问速度。</p>
<a id="more"></a>

<p>老左经常看到论坛、群里有用户提到锐速这款软件可以提高VPS的访问速度、加速应用效率，于是今天就在VULTR VPS中进行尝试安装使用。 大概2月份的时候锐速宣布不再免费，原来宣传的永久免费20M也没了。一时间让广大vps爱好者陷入低谷，不过各路破解高手也是不断抛砖引玉，从开始的改MAC方法到后来的算lic方法，现在连一键安装包都出来了，算是比较成熟了吧。这里转载一个用的比较多的一键安装包，亲测可用，由91yun.org博主带来的。 锐速官方支持的Linux发行版列表：<a href="http://dl.serverspeeder.com/ls.do?m=availables" target="_blank" rel="noopener">http://dl.serverspeeder.com/ls.do?m=availables</a> 脚本已托管在Github：<a href="https://github.com/91yun/serverspeeder" target="_blank" rel="noopener">https://github.com/91yun/serverspeeder</a> 锐速破解版安装方法： <code>wget -N --no-check-certificate https://raw.githubusercontent.com/91yun/serverspeeder/master/serverspeeder-all.sh &amp;&amp; bash serverspeeder-all.sh</code> 锐速破解版卸载方法： <code>chattr -i /serverspeeder/etc/apx* &amp;&amp; /serverspeeder/bin/serverSpeeder.sh uninstall -f</code> 查看锐速启动状态<code>/serverspeeder/bin/serverSpeeder.sh status</code> 锐速破解版功能： 如果内核完全匹配就会自动下载安装。 如果没有完全匹配的内核，会在界面提示可选内核，可以手动选个最接近的尝试 自动下载授权文件 自动修改配置文件 已chattr +i /serverspeeder/etc/apx<em>禁止修改配置文件，可以不用加hosts了 目前只支持CentOS，ubuntu和debian。 PS：*</em>锐速不支持openvz架构**。所以你查看vps的mac地址都是0的就别试了。</p>
]]></content>
      <categories>
        <category>Linux/服务器/网络</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>ServerSpeeder</tag>
        <tag>SS</tag>
        <tag>锐速</tag>
      </tags>
  </entry>
  <entry>
    <title>ThreadLocal 详解</title>
    <url>/2017/03/15/ThreadLocal%20%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="ThreadLocal是什么"><a href="#ThreadLocal是什么" class="headerlink" title="ThreadLocal是什么"></a>ThreadLocal是什么</h2><p>　　早在JDK 1.2的版本中就提供Java.lang.ThreadLocal，ThreadLocal为解决多线程程序的并发问题提供了一种新的思路。使用这个工具类可以很简洁地编写出优美的多线程程序。 　　 　　当使用ThreadLocal维护变量时，ThreadLocal为每个使用该变量的线程提供独立的变量副本，所以每一个线程都可以独立地改变自己的副本，而不会影响其它线程所对应的副本。 　　 　　从线程的角度看，目标变量就象是线程的本地变量，这也是类名中“Local”所要表达的意思。 　　 　　所以，在Java中编写线程局部变量的代码相对来说要笨拙一些，因此造成线程局部变量没有在Java开发者中得到很好的普及。 　　</p>
<a id="more"></a>

<h2 id="ThreadLocal的接口方法"><a href="#ThreadLocal的接口方法" class="headerlink" title="ThreadLocal的接口方法"></a>ThreadLocal的接口方法</h2><p>ThreadLocal类接口很简单，只有4个方法，我们先来了解一下：</p>
<ul>
<li><strong>void set(Object value)</strong>：设置当前线程的线程局部变量的值。</li>
<li><strong>public Object get()</strong>：该方法返回当前线程所对应的线程局部变量。</li>
<li><strong>public void remove()</strong>：将当前线程局部变量的值删除，目的是为了减少内存的占用，该方法是JDK 5.0新增的方法。需要指出的是，当线程结束后，对应该线程的局部变量将自动被垃圾回收，所以显式调用该方法清除线程的局部变量并不是必须的操作，但它可以加快内存回收的速度。</li>
<li><strong>protected Object initialValue()</strong>：返回该线程局部变量的初始值，该方法是一个protected的方法，显然是为了让子类覆盖而设计的。这个方法是一个延迟调用方法，在线程第1次调用get()或set(Object)时才执行，并且仅执行1次。ThreadLocal中的缺省实现直接返回一个null。</li>
</ul>
<p>　　值得一提的是，在JDK5.0中，ThreadLocal已经支持泛型，该类的类名已经变为ThreadLocal。API方法也相应进行了调整，新版本的API方法分别是void set(T value)、T get()以及T initialValue()。 　　 　　ThreadLocal是如何做到为每一个线程维护变量的副本的呢？其实实现的思路很简单：在ThreadLocal类中有一个Map，用于存储每一个线程的变量副本，Map中元素的键为线程对象，而值对应线程的变量副本。我们自己就可以提供一个简单的实现版本：</p>
<pre><code>package com.test;
public class TestNum {
    // ①通过匿名内部类覆盖ThreadLocal的initialValue()方法，指定初始值
    private static ThreadLocal&lt;Integer&gt; seqNum = new ThreadLocal&lt;Integer&gt;() {
        public Integer initialValue() {
            return 0;
        }
    };
    // ②获取下一个序列值
    public int getNextNum() {
        seqNum.set(seqNum.get() + 1);
        return seqNum.get();
    }
    public static void main(String[] args) {
        TestNum sn = new TestNum();
        // ③ 3个线程共享sn，各自产生序列号
        TestClient t1 = new TestClient(sn);
        TestClient t2 = new TestClient(sn);
        TestClient t3 = new TestClient(sn);
        t1.start();
        t2.start();
        t3.start();
    }
    private static class TestClient extends Thread {
        private TestNum sn;
        public TestClient(TestNum sn) {
            this.sn = sn;
        }
        public void run() {
            for (int i = 0; i &lt; 3; i++) {
                // ④每个线程打出3个序列值
                System.out.println(&quot;thread[&quot; + Thread.currentThread().getName() + &quot;] --&gt; sn[&quot;
                         + sn.getNextNum() + &quot;]&quot;);
            }
        }
    }
}</code></pre><p>　　通常我们通过匿名内部类的方式定义ThreadLocal的子类，提供初始的变量值，如例子中①处所示。TestClient线程产生一组序列号，在③处，我们生成3个TestClient，它们共享同一个TestNum实例。运行以上代码，在控制台上输出以下的结果：</p>
<pre><code>thread[Thread-0] --&gt; sn[1]
thread[Thread-1] --&gt; sn[1]
thread[Thread-2] --&gt; sn[1]
thread[Thread-1] --&gt; sn[2]
thread[Thread-0] --&gt; sn[2]
thread[Thread-1] --&gt; sn[3]
thread[Thread-2] --&gt; sn[2]
thread[Thread-0] --&gt; sn[3]
thread[Thread-2] --&gt; sn[3]</code></pre><p>　　考察输出的结果信息，我们发现每个线程所产生的序号虽然都共享同一个TestNum实例，但它们并没有发生相互干扰的情况，而是各自产生独立的序列号，这是因为我们通过ThreadLocal为每一个线程提供了单独的副本。</p>
<h2 id="Thread同步机制的比较"><a href="#Thread同步机制的比较" class="headerlink" title="Thread同步机制的比较"></a>Thread同步机制的比较</h2><p>　　ThreadLocal和线程同步机制相比有什么优势呢？ThreadLocal和线程同步机制都是为了解决多线程中相同变量的访问冲突问题。 　　 　　在同步机制中，通过对象的锁机制保证同一时间只有一个线程访问变量。这时该变量是多个线程共享的，使用同步机制要求程序慎密地分析什么时候对变量进行读写，什么时候需要锁定某个对象，什么时候释放对象锁等繁杂的问题，程序设计和编写难度相对较大。 　　 　　而ThreadLocal则从另一个角度来解决多线程的并发访问。ThreadLocal会为每一个线程提供一个独立的变量副本，从而隔离了多个线程对数据的访问冲突。因为每一个线程都拥有自己的变量副本，从而也就没有必要对该变量进行同步了。ThreadLocal提供了线程安全的共享对象，在编写多线程代码时，可以把不安全的变量封装进ThreadLocal。 　　 　　由于ThreadLocal中可以持有任何类型的对象，低版本JDK所提供的get()返回的是Object对象，需要强制类型转换。但JDK 5.0通过泛型很好的解决了这个问题，在一定程度地简化ThreadLocal的使用，代码清单 9 2就使用了JDK 5.0新的ThreadLocal版本。 　　 　　概括起来说，对于多线程资源共享的问题，同步机制采用了“以时间换空间”的方式，而ThreadLocal采用了“以空间换时间”的方式。前者仅提供一份变量，让不同的线程排队访问，而后者为每一个线程都提供了一份变量，因此可以同时访问而互不影响。 　　 　　spring使用ThreadLocal解决线程安全问题我们知道在一般情况下，只有无状态的Bean才可以在多线程环境下共享，在Spring中，绝大部分Bean都可以声明为singleton作用域。就是因为Spring对一些Bean（如RequestContextHolder、TransactionSynchronizationManager、LocaleContextHolder等）中非线程安全状态采用ThreadLocal进行处理，让它们也成为线程安全的状态，因为有状态的Bean就可以在多线程中共享了。 　　 　　一般的Web应用划分为展现层、服务层和持久层三个层次，在不同的层中编写对应的逻辑，下层通过接口向上层开放功能调用。在一般情况下，从接收请求到返回响应所经过的所有程序调用都同属于一个线程，如图9‑2所示： 　　 　　<img data-src="https://cdn.javacodes.cn/files/2017/03/2017-03-15_15-34-09.gif" alt="">￼ 　　同一线程贯通三层这样你就可以根据需要，将一些非线程安全的变量以ThreadLocal存放，在同一次请求响应的调用线程中，所有关联的对象引用到的都是同一个变量。 　　下面的实例能够体现Spring对有状态Bean的改造思路： 　　代码清单3 TestDao：非线程安全</p>
<pre><code>package com.test;

import java.sql.Connection;
import java.sql.SQLException;
import java.sql.Statement;

public class TestDao {
    private Connection conn;// ①一个非线程安全的变量

    public void addTopic() throws SQLException {
        Statement stat = conn.createStatement();// ②引用非线程安全变量
        // …
    }
}</code></pre><p>　　由于①处的conn是成员变量，因为addTopic()方法是非线程安全的，必须在使用时创建一个新TopicDao实例（非singleton）。下面使用ThreadLocal对conn这个非线程安全的“状态”进行改造： 　　代码清单4 TestDao：线程安全</p>
<pre><code>package com.test;

import java.sql.Connection;
import java.sql.SQLException;
import java.sql.Statement;

public class TestDaoNew {
    // ①使用ThreadLocal保存Connection变量
    private static ThreadLocal&lt;Connection&gt; connThreadLocal = new ThreadLocal&lt;Connection&gt;();

    public static Connection getConnection() {
        // ②如果connThreadLocal没有本线程对应的Connection创建一个新的Connection，
        // 并将其保存到线程本地变量中。
        if (connThreadLocal.get() == null) {
            Connection conn = getConnection();
            connThreadLocal.set(conn);
            return conn;
        } else {
            return connThreadLocal.get();// ③直接返回线程本地变量
        }
    }

    public void addTopic() throws SQLException {
        // ④从ThreadLocal中获取线程对应的Connection
        Statement stat = getConnection().createStatement();
    }
}</code></pre><p>　　不同的线程在使用TopicDao时，先判断connThreadLocal.get()是否是null，如果是null，则说明当前线程还没有对应的Connection对象，这时创建一个Connection对象并添加到本地线程变量中；如果不为null，则说明当前的线程已经拥有了Connection对象，直接使用就可以了。这样，就保证了不同的线程使用线程相关的Connection，而不会使用其它线程的Connection。因此，这个TopicDao就可以做到singleton共享了。 　　 　　当然，这个例子本身很粗糙，将Connection的ThreadLocal直接放在DAO只能做到本DAO的多个方法共享Connection时不发生线程安全问题，但无法和其它DAO共用同一个Connection，要做到同一事务多DAO共享同一Connection，必须在一个共同的外部类使用ThreadLocal保存Connection。</p>
<pre><code>package com.test;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.SQLException;

public class ConnectionManager {

    private static ThreadLocal&lt;Connection&gt; connectionHolder = new ThreadLocal&lt;Connection&gt;() {
        @Override
        protected Connection initialValue() {
            Connection conn = null;
            try {
                conn = DriverManager.getConnection(
                        &quot;jdbc:mysql://localhost:3306/test&quot;, &quot;username&quot;,
                        &quot;password&quot;);
            } catch (SQLException e) {
                e.printStackTrace();
            }
            return conn;
        }
    };

    public static Connection getConnection() {
        return connectionHolder.get();
    }

    public static void setConnection(Connection conn) {
        connectionHolder.set(conn);
    }
}</code></pre><h2 id="java-lang-ThreadLocal的具体实现"><a href="#java-lang-ThreadLocal的具体实现" class="headerlink" title="java.lang.ThreadLocal的具体实现"></a>java.lang.ThreadLocal的具体实现</h2><p>　　那么到底ThreadLocal类是如何实现这种“为每个线程提供不同的变量拷贝”的呢？先来看一下ThreadLocal的set()方法的源码是如何实现的：</p>
<pre><code>/**
    * Sets the current thread&apos;s copy of this thread-local variable
    * to the specified value.  Most subclasses will have no need to
    * override this method, relying solely on the {@link #initialValue}
    * method to set the values of thread-locals.
    *
    * @param value the value to be stored in the current thread&apos;s copy of
    *        this thread-local.
    */
   public void set(T value) {
       Thread t = Thread.currentThread();
       ThreadLocalMap map = getMap(t);
       if (map != null)
           map.set(this, value);
       else
           createMap(t, value);
   }</code></pre><p>　　在这个方法内部我们看到，首先通过getMap(Thread t)方法获取一个和当前线程相关的ThreadLocalMap，然后将变量的值设置到这个ThreadLocalMap对象中，当然如果获取到的ThreadLocalMap对象为空，就通过createMap方法创建。 　　线程隔离的秘密，就在于ThreadLocalMap这个类。ThreadLocalMap是ThreadLocal类的一个静态内部类，它实现了键值对的设置和获取（对比Map对象来理解），每个线程中都有一个独立的ThreadLocalMap副本，它所存储的值，只能被当前线程读取和修改。ThreadLocal类通过操作每一个线程特有的ThreadLocalMap副本，从而实现了变量访问在不同线程中的隔离。因为每个线程的变量都是自己特有的，完全不会有并发错误。还有一点就是，ThreadLocalMap存储的键值对中的键是this对象指向的ThreadLocal对象，而值就是你所设置的对象了。 　　为了加深理解，我们接着看上面代码中出现的getMap和createMap方法的实现：</p>
<pre><code>    /**
     * Get the map associated with a ThreadLocal. Overridden in
     * InheritableThreadLocal.
     *
     * @param  t the current thread
     * @return the map
     */
    ThreadLocalMap getMap(Thread t) {
        return t.threadLocals;
    }

    /**
     * Create the map associated with a ThreadLocal. Overridden in
     * InheritableThreadLocal.
     *
     * @param t the current thread
     * @param firstValue value for the initial entry of the map
     * @param map the map to store.
     */
    void createMap(Thread t, T firstValue) {
        t.threadLocals = new ThreadLocalMap(this, firstValue);
    }
    <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">　　接下来再看一下ThreadLocal类中的get()方法:</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;java</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Returns the value in the current thread&#39;s copy of this</span><br><span class="line">     * thread-local variable.  If the variable has no value for the</span><br><span class="line">     * current thread, it is first initialized to the value returned</span><br><span class="line">     * by an invocation of the &#123;@link #initialValue&#125; method.</span><br><span class="line">     *</span><br><span class="line">     * @return the current thread&#39;s value of this thread-local</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public T get() &#123;</span><br><span class="line">        Thread t &#x3D; Thread.currentThread();</span><br><span class="line">        ThreadLocalMap map &#x3D; getMap(t);</span><br><span class="line">        if (map !&#x3D; null) &#123;</span><br><span class="line">            ThreadLocalMap.Entry e &#x3D; map.getEntry(this);</span><br><span class="line">            if (e !&#x3D; null)</span><br><span class="line">                return (T)e.value;</span><br><span class="line">        &#125;</span><br><span class="line">        return setInitialValue();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


　　再来看setInitialValue()方法：

```java
     /**
     * Variant of set() to establish initialValue. Used instead
     * of set() in case user has overridden the set() method.
     *
     * @return the initial value
     */
    private T setInitialValue() {
        T value = initialValue();
        Thread t = Thread.currentThread();
        ThreadLocalMap map = getMap(t);
        if (map != null)
            map.set(this, value);
        else
            createMap(t, value);
        return value;
    }</code></pre><p>　　获取和当前线程绑定的值时，ThreadLocalMap对象是以this指向的ThreadLocal对象为键进行查找的，这当然和前面set()方法的代码是相呼应的。 　　进一步地，我们可以创建不同的ThreadLocal实例来实现多个变量在不同线程间的访问隔离，为什么可以这么做？因为不同的ThreadLocal对象作为不同键，当然也可以在线程的ThreadLocalMap对象中设置不同的值了。通过ThreadLocal对象，在多线程中共享一个值和多个值的区别，就像你在一个HashMap对象中存储一个键值对和多个键值对一样，仅此而已。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>　　ThreadLocal是解决线程安全问题一个很好的思路，它通过为每个线程提供一个独立的变量副本解决了变量并发访问的冲突问题。在很多情况下，ThreadLocal比直接使用synchronized同步机制解决线程安全问题更简单，更方便，且结果程序拥有更高的并发性。 ConnectionManager.java</p>
<pre><code>package com.test;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.SQLException;

public class ConnectionManager {

    private static ThreadLocal&lt;Connection&gt; connectionHolder = new ThreadLocal&lt;Connection&gt;() {
        @Override
        protected Connection initialValue() {
            Connection conn = null;
            try {
                conn = DriverManager.getConnection(
                        &quot;jdbc:mysql://localhost:3306/test&quot;, &quot;username&quot;,
                        &quot;password&quot;);
            } catch (SQLException e) {
                e.printStackTrace();
            }
            return conn;
        }
    };

    public static Connection getConnection() {
        return connectionHolder.get();
    }

    public static void setConnection(Connection conn) {
        connectionHolder.set(conn);
    }
}</code></pre><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>　　看到网友评论的很激烈，甚至关于ThreadLocalMap不是ThreadLocal里面的，而是Thread里面的这种评论都出现了，于是有了这个后记，下面先把jdk源码贴上，源码最有说服力了。</p>
<pre><code>/**
     * ThreadLocalMap is a customized hash map suitable only for
     * maintaining thread local values. No operations are exported
     * outside of the ThreadLocal class. The class is package private to
     * allow declaration of fields in class Thread.  To help deal with
     * very large and long-lived usages, the hash table entries use
     * WeakReferences for keys. However, since reference queues are not
     * used, stale entries are guaranteed to be removed only when
     * the table starts running out of space.
     */
    static class ThreadLocalMap {...}</code></pre><p>　　源码就是以上，这源码自然是在ThreadLocal里面的，有截图为证。 　　 　　<img data-src="https://cdn.javacodes.cn/files/2017/03/2017-03-15_15-34-09.jpg" alt="">￼ 　　本文是自己在学习ThreadLocal的时候，一时兴起，深入看了源码，思考了此类的作用、使用范围，进而联想到对传统的synchronize共享变量线程安全的问题进行比较，而总结的博文，总结一句话就是一个是锁机制进行时间换空间，一个是存储拷贝进行空间换时间。 (全文完)</p>
<blockquote>
<p>转载自<a href="http://blog.csdn.net/lufeng20" target="_blank" rel="noopener">http://blog.csdn.net/lufeng20</a></p>
</blockquote>
]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>并发</tag>
        <tag>ThreadLocal</tag>
      </tags>
  </entry>
  <entry>
    <title>UI布局优化，什么才是好的设计？</title>
    <url>/2016/09/07/UI%E5%B8%83%E5%B1%80%E4%BC%98%E5%8C%96%EF%BC%8C%E4%BB%80%E4%B9%88%E6%89%8D%E6%98%AF%E5%A5%BD%E7%9A%84%E8%AE%BE%E8%AE%A1%EF%BC%9F/</url>
    <content><![CDATA[<p>今天为大家分享一些Good UI 在一些项目中获取的设计以及运营策略等方面的经验。 这是本人收藏了很久的干货，最近开始做网站产品，又把它翻出来了。 Good UI是一家研究用户体验的设计机构。我们知道成功的页面设计不仅有很高的转化率更便于用户使用，既能满足商业目标更能为用户带来良好的体验。 </p>
<a id="more"></a>

<ol>
<li>用通栏布局代替多栏布局</li>
</ol>
<p><img data-src="https://cdn.javacodes.cn/files/2016/09/2016-09-07_07-52-54-2.png" alt=""></p>
<p>2. 给用户些好处，别急着做生意</p>
<p><img data-src="https://cdn.javacodes.cn/files/2016/09/2016-09-07_07-52-55.png" alt=""></p>
<p>3. 整合相似的功能，去掉零碎的UI元素</p>
<p><img data-src="https://cdn.javacodes.cn/files/2016/09/2016-09-07_07-52-57.png" alt=""></p>
<p>4.利用社会认同效应，别总是自吹自擂</p>
<p><img data-src="https://cdn.javacodes.cn/files/2016/09/2016-09-07_07-52-57-1.png" alt=""></p>
<p>5.主要功能需要多次强化显示</p>
<p><img data-src="https://cdn.javacodes.cn/files/2016/09/2016-09-07_07-52-57-2.png" alt=""></p>
<p>6.区分选中和可点击的状态，不要使用户困惑</p>
<p><img data-src="https://cdn.javacodes.cn/files/2016/09/2016-09-07_07-52-58.png" alt=""></p>
<p>7.布局有层次有重点，而非简单罗列</p>
<p><img data-src="https://cdn.javacodes.cn/files/2016/09/2016-09-07_07-52-58-1.png" alt=""></p>
<p>8. 允许用户撤销操作而不是使用弹窗需要用户确认</p>
<p><img data-src="https://cdn.javacodes.cn/files/2016/09/2016-09-07_07-52-59.png" alt=""></p>
<p>9. 明确的告知用户适用人群而不是简单的面向所用用户</p>
<p><img data-src="https://cdn.javacodes.cn/files/2016/09/2016-09-07_07-52-59-1.png" alt=""></p>
<p>10.简洁明了，直接了当</p>
<p><img data-src="https://cdn.javacodes.cn/files/2016/09/2016-09-07_07-53-00.png" alt=""></p>
<p>11.页面上多使用对比的方法</p>
<p><img data-src="https://cdn.javacodes.cn/files/2016/09/2016-09-07_07-53-00-1.png" alt=""></p>
<p>12.直接标出产地，别总单纯的讲历史</p>
<p><img data-src="https://cdn.javacodes.cn/files/2016/09/2016-09-07_07-53-01.png" alt=""></p>
<p>13.使用简洁的表单</p>
<p><img data-src="https://cdn.javacodes.cn/files/2016/09/2016-09-07_07-53-01-1.png" alt=""></p>
<p>14.把选项列出来而不是藏起来</p>
<p><img data-src="https://cdn.javacodes.cn/files/2016/09/2016-09-07_07-53-01-2.png" alt=""></p>
<p>15.使用连续性的提示符，别让用户误以为页面到了终点</p>
<p><img data-src="https://cdn.javacodes.cn/files/2016/09/2016-09-07_07-53-02.png" alt=""></p>
<p>16.功能专一而不是使用太多的链接</p>
<p><img data-src="https://cdn.javacodes.cn/files/2016/09/2016-09-07_07-53-02-1.png" alt=""></p>
<p>17.提示体统状态</p>
<p><img data-src="https://cdn.javacodes.cn/files/2016/09/2016-09-07_07-53-03.png" alt=""></p>
<p>18. 在动作按钮上增加些吸引人的诱惑</p>
<p><img data-src="https://cdn.javacodes.cn/files/2016/09/2016-09-07_07-53-04.png" alt=""></p>
<p>19.用直接操作来代替无数个菜单</p>
<p><img data-src="https://cdn.javacodes.cn/files/2016/09/2016-09-07_07-53-04-1.png" alt=""></p>
<p>20.直接显示输入框可以省略一个页面</p>
<p><img data-src="https://cdn.javacodes.cn/files/2016/09/2016-09-07_07-53-04-2.png" alt=""></p>
<p>21. 用一些动效过度而不用立即显示变化</p>
<p><img data-src="https://cdn.javacodes.cn/files/2016/09/2016-09-07_07-53-05.png" alt=""></p>
<p>22. 循序渐进的引导用户而非生硬的要求用户注册</p>
<p><img data-src="https://cdn.javacodes.cn/files/2016/09/2016-09-07_07-53-05-1.png" alt=""></p>
<p>23.试着减少线框，减少不必要的注意</p>
<p><img data-src="https://cdn.javacodes.cn/files/2016/09/2016-09-07_07-53-27.png" alt=""></p>
<p>24.向用户展示功能上的便捷之处而不是泛泛的展示特性</p>
<p><img data-src="https://cdn.javacodes.cn/files/2016/09/2016-09-07_07-53-27-1.png" alt=""></p>
<p>25. 用户没有使用记录的时候要善于引导</p>
<p><img data-src="https://cdn.javacodes.cn/files/2016/09/2016-09-07_07-53-28.png" alt=""></p>
<p>26. 给出默认的选项而不需要用户选择</p>
<p><img data-src="https://cdn.javacodes.cn/files/2016/09/2016-09-07_07-53-28-1.png" alt=""></p>
<p>27.保持一致性降低用户的学习成本</p>
<p><img data-src="https://cdn.javacodes.cn/files/2016/09/2016-09-07_07-53-29.png" alt=""></p>
<p>28. 自动补全一些数据，降低用户的操作负担</p>
<p><img data-src="https://cdn.javacodes.cn/files/2016/09/2016-09-07_07-53-29-1.png" alt=""></p>
<p>29. 尊重用户的使用习惯而不是创造新的规则</p>
<p><img data-src="https://cdn.javacodes.cn/files/2016/09/2016-09-07_07-53-30.png" alt=""></p>
<p>30. 提示用户如何规避风险，而不是总想着如何获利</p>
<p><img data-src="https://cdn.javacodes.cn/files/2016/09/2016-09-07_07-53-30-1.png" alt=""></p>
<p>31. 善于引导用户的视觉浏览线，而非单一布局</p>
<p><img data-src="https://cdn.javacodes.cn/files/2016/09/2016-09-07_07-53-31.png" alt=""></p>
<p>32. 将相关的条目分组，不要杂乱无章的排列</p>
<p><img data-src="https://cdn.javacodes.cn/files/2016/09/2016-09-07_07-53-31-1.png" alt=""></p>
<p>33.采用及时校验而不是到最后才提示错误</p>
<p><img data-src="https://cdn.javacodes.cn/files/2016/09/2016-09-07_07-53-31-2.png" alt=""></p>
<p>34.需要用户输入的格式宽松严格限定格式</p>
<p><img data-src="https://cdn.javacodes.cn/files/2016/09/2016-09-07_07-53-32.png" alt=""></p>
<p>35.让用户有一些紧急的意识，别让用户拖得太久</p>
<p><img data-src="https://cdn.javacodes.cn/files/2016/09/2016-09-07_07-53-48.png" alt=""></p>
<p>36. 适当尝试饥饿营销</p>
<p><img data-src="https://cdn.javacodes.cn/files/2016/09/2016-09-07_07-53-48-1.png" alt=""></p>
<p>37. 帮助用户识别</p>
<p><img data-src="https://cdn.javacodes.cn/files/2016/09/2016-09-07_07-53-49.png" alt=""></p>
<p>38. 使用更大的点击区域</p>
<p><img data-src="https://cdn.javacodes.cn/files/2016/09/2016-09-07_07-53-49-1.png" alt=""></p>
<p>39. 增加加载的速度，别让用户等太久</p>
<p><img data-src="https://cdn.javacodes.cn/files/2016/09/2016-09-07_07-53-49-2.png" alt=""></p>
<p>40. 可以给用户提供一些快捷操作</p>
<p><img data-src="https://cdn.javacodes.cn/files/2016/09/2016-09-07_07-53-50.png" alt=""></p>
<p>41. 使用一些对比</p>
<p><img data-src="https://cdn.javacodes.cn/files/2016/09/2016-09-07_07-53-50-1.png" alt=""></p>
<p>42. 初始化的时候给用户一些激励</p>
<p><img data-src="https://cdn.javacodes.cn/files/2016/09/2016-09-07_07-53-51.png" alt=""></p>
<p>43.循序渐进地引导用户，不要简单粗暴地直接呈现给用户</p>
<p><img data-src="https://cdn.javacodes.cn/files/2016/09/2016-09-07_07-53-51-1.png" alt=""></p>
<p>文／神奇的bebe（简书作者） 原文链接：<a href="http://www.jianshu.com/p/2d1c9d8d55a7" target="_blank" rel="noopener">http://www.jianshu.com/p/2d1c9d8d55a7</a> 著作权归作者所有，转载请联系作者获得授权，并标注“简书作者”。</p>
]]></content>
      <categories>
        <category>Web前端</category>
      </categories>
      <tags>
        <tag>UI设计</tag>
        <tag>布局优化</tag>
        <tag>网页布局</tag>
      </tags>
  </entry>
  <entry>
    <title>WordPress 博客同步到 CSDN 插件</title>
    <url>/2016/09/10/WordPress%20%E5%8D%9A%E5%AE%A2%E5%90%8C%E6%AD%A5%E5%88%B0%20CSDN%20%E6%8F%92%E4%BB%B6/</url>
    <content><![CDATA[<blockquote>
<p>原文链接：<a href="http://xuhehuan.com/" target="_blank" rel="noopener">蔓草札记</a> » <a href="http://xuhehuan.com/2027.html" target="_blank" rel="noopener">WordPress 博客同步到 CSDN 插件</a></p>
</blockquote>
<p>在没用 WordPress 博客前就在 CSDN 写了一些日志，后来自己搭建博客后，就希望能够将博客同步到 CSDN 中，无奈 CSDN 在 2011 年 7 月宣布暂不支持 Windows Live Writer 发布博文，直到在2014 年 5 月 29 日才宣布重新<a href="http://blog.csdn.net/csdnproduct/article/details/27504397" target="_blank" rel="noopener">支持离线写博客</a>，让插件同步成为可能，不过目前网上搜到的插件现在都已经失效了。 </p>
<a id="more"></a>

<p>这两天闲时测试了下之前润物无声写的<a href="http://blog.zhourunsheng.com/2011/06/%E5%90%8C%E6%AD%A5wordpress%E6%96%87%E7%AB%A0%E5%88%B0csdn/" target="_blank" rel="noopener">wp2metaweblog 插件</a>，也在网上查了不少关于 MetaWeblog 和 xmlrpc 的说明，但对解决问题都没什么大的帮助，最后只能一点点调试了。功夫不负有心人，终于在今天下午的时候，调试成功了。在 wp2metaweblog 插件的基础上做了些修改，并整理了下代码，防止和原 wp2metaweblog 插件冲突，改名为 WP2CSDNBlog 插件。 WP2CSDNBlog 插件是同步 WordPress 博客日志到 CSDN 博客的，理论上也可用在所有支持 Metaweblog API 的博客系统中，安装后需要到设置页面填下同步需要的信息。 <strong>Version 1.1 支持功能：</strong> 1. 支持发布 wordpress 的博文到 CSDN 博客 2. 支持将 WordPress 中文章链接发布到 CSDN 博客 3. 支持发布文章的自动归类 <strong>Version 1.2 支持功能：</strong> 1. 同时支持发布 wordpress 的博文到网易和新浪博客 <strong>Version 1.3 支持功能：</strong> 1. 支持将 wordpress 的定时发布文章发布到设置的博客 <strong>Version 1.4 支持功能：</strong> 1. 完善对定时发布功能的支持 2. 完善同步文章排版格式问题 <strong>Version 1.5 支持功能：</strong> 1. 修改 CSDN 博客同步文章排版格式 <strong>安装使用：</strong> 1. 上传整个文件夹 wp2csdnblog 到 /wp-content/plugins/ 目录 2. 后台控制面板“插件 (Plugins)”中激活 wp2csdnblog 插件 3. 后台控制面板“配置 (Settings)-&gt;wp2csdnblog”中配置 CSDN 账户信息 <strong>软件配置界面（V1.1 版本）:</strong> <img data-src="https://cdn.javacodes.cn/files/2016/09/2016-09-10_01-45-58.png" alt="wordpress-to-csdn"> <strong>代码地址：</strong><a href="https://gitcafe.com/xhhjin/WP2CSDNBlog/tree/master" target="_blank" rel="noopener">https://gitcafe.com/xhhjin/WP2CSDNBlog/tree/master</a> <strong>代码地址：</strong><a href="https://coding.net/u/xhhjin/p/WP2CSDNBlog" target="_blank" rel="noopener">https://coding.net/u/xhhjin/p/WP2CSDNBlog</a> <strong>百度云下载：</strong><a href="http://pan.baidu.com/s/1c0dHqTy" target="_blank" rel="noopener">http://pan.baidu.com/s/1c0dHqTy</a>（V1.1 版本） 建议通过代码地址下载，百度云下载后续不一定更新。 WP2CSDNBlog 插件，开始同步吧 :） <strong>2015.05.12 更新：</strong> 插件已上传 WordPress plugins，可以在 WordPress 后台安装插件页面直接搜索“wp2csdnblog”安装。 WordPress plugins 地址：<a href="https://wordpress.org/plugins/wp2csdnblog/" target="_blank" rel="noopener">https://wordpress.org/plugins/wp2csdnblog/</a> <strong>2015.06.14 更新：</strong> 更新插件到 V1.2 版本，支持同时同步 WordPress 博客内容到新浪博客和网易博客。 新浪博客设置的用户名是博客的登录名，如果登录名是邮箱，不要忘了邮箱后缀。 网易博客设置的用户名根据邮箱区分。例如：您的邮箱帐号是 163 的：blog_<a href="mailto:admin@163.com">admin@163.com</a>，则用户名是 blog_admin，如果你的邮箱账号是 126 的：blog_<a href="mailto:admin@126.com">admin@126.com</a>，则用户名是 blog_admin@126，其余 yeah.net、188 等非 163 邮箱用户，请参考 126 邮箱的格式。 <strong>2015.06.22 更新：</strong> 更新插件到 V1.3 版本，支持将 wordpress 的定时发布文章发布到设置的博客。 <strong>2015.07.05 更新：</strong> 更新插件到 V1.4 版本，完善对定时发布文章功能的支持，改善同步文章的排版格式。 <strong>2016.05.04 更新：</strong> 更新插件到 V1.5 版本，修改 CSDN 博客同步文章排版格式。 最近一段时间同步 CSDN 和网易博客的文章都没有成功，是 CSDN 和网易服务器返回错误导致的。大家可以用 Windows Live Writer 或者 Word 来发文章测试，如果能发布成功，则说明是插件的问题，反之很可能是服务器的问题，然后建议将服务器返回的错误在下面对应文章下留言。</p>
]]></content>
      <categories>
        <category>随笔杂谈</category>
      </categories>
      <tags>
        <tag>Wordpress</tag>
        <tag>Wordpress插件</tag>
        <tag>WP插件</tag>
        <tag>同步CSDN</tag>
      </tags>
  </entry>
  <entry>
    <title>XPath表达式语法详解</title>
    <url>/2016/07/17/XPath%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%AF%AD%E6%B3%95%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h3 id=""><a href="#" class="headerlink" title=""></a><img data-src="https://cdn.javacodes.cn/files/2016/07/2016-07-17_02-07-40.jpg" alt="06cb9ef8996462aa0d73561fd734811f09cf60_big"></h3><h3 id="XPath路径表达式"><a href="#XPath路径表达式" class="headerlink" title="XPath路径表达式"></a>XPath路径表达式</h3><p>XPath即为XML路径语言，它是一种用来确定XML（标准通用标记语言的子集）文档中某部分位置的语言。XPath基于XML的树状结构，提供在数据结构树中找寻节点的能力。XPath使用路径表达式去确定XML文档中的节点。</p>
<a id="more"></a>

<h3 id="示例XML文档"><a href="#示例XML文档" class="headerlink" title="示例XML文档"></a>示例XML文档</h3><p>我们将利用下面的XML文档描述XPath语法</p>
<?xml version="1.0" encoding="GB2312"?>

<order>
  <item catalog="parts">
    <itemNumber>C2688-67037</itemNumber>
    <description>LCD液晶显示器</description>
    <quantity>1</quantity>
    <price>358.00</price>
  </item>
 <item catalog="parts">
    <itemNumber>C2688-67061</itemNumber>
    <description>音箱</description>
    <quantity>1</quantity>
    <price>16.50</price>
  </item>
  <item catalog="parts">
    <itemNumber>C2688-67010</itemNumber>
    <description>鼠标</description>
    <quantity>1</quantity>
    <price>8.50</price>
  </item>
</order>

<h3 id="从根节点选取“-”"><a href="#从根节点选取“-”" class="headerlink" title="从根节点选取“/”"></a>从根节点选取“/”</h3><p>XML文挡可以表示为树结构节点形式 XPath使用模式表达式识别XML文档的节点。 一个XPath的模式是使用反斜杠“/”分开子元素名称描述路径 下面的XPath表达式选择元素order下元素item中的所有price元素</p>
<blockquote>
<p>/order/item/price</p>
</blockquote>
<p>注释：用“/”路径开始代表元素的绝对路径，不用“/”路径开始代表元素的相对路径</p>
<blockquote>
<p>item/price</p>
</blockquote>
<h3 id="从整个文档选取“-”"><a href="#从整个文档选取“-”" class="headerlink" title="从整个文档选取“//”"></a>从整个文档选取“//”</h3><p>用“//”路径开始代表整个文档满足条件的所有元素，不考虑它们的位置 下面的XPath表达式选择文档中所有的item元素</p>
<blockquote>
<p>//item</p>
</blockquote>
<h3 id="选择未知元素“-”"><a href="#选择未知元素“-”" class="headerlink" title="选择未知元素“*”"></a>选择未知元素“*”</h3><p>通配符 “*”可用于选择未知XML元素 下面的XPath表达式选择元素order中的所有item元素所属的子元素</p>
<blockquote>
<p>/order/item/*</p>
</blockquote>
<p>下面的XPath表达式选择元素order下所有孙子辈的price元素</p>
<blockquote>
<p>/order/*/price</p>
</blockquote>
<p>下面的XPath表达式选择所有具有两个祖先的price元素</p>
<blockquote>
<p>/<em>/</em>/price</p>
</blockquote>
<p>下面的XPath表达式选择文档所有元素</p>
<blockquote>
<p>//*</p>
</blockquote>
<h3 id="选择分支“-”（谓语）"><a href="#选择分支“-”（谓语）" class="headerlink" title="选择分支“[]”（谓语）"></a>选择分支“[]”（谓语）</h3><p>使用方括号[]可以指定特定的元素 下面的XPath表达式选择元素order中的第一个item的子元素</p>
<blockquote>
<p>/order/item[1]</p>
</blockquote>
<p>下面的XPath表达式选择元素order中的最后一个item的子元素</p>
<blockquote>
<p>/order/item[last()]</p>
</blockquote>
<p>下面的XPath表达式选择元素order中具有price元素的item元素</p>
<blockquote>
<p>/order/item[price]</p>
</blockquote>
<p>下面的XPath表达式,从元素order中选择具有price等于12.60元素的item元素</p>
<blockquote>
<p>/order/item[price=16.50]</p>
</blockquote>
<p>下面的XPath表达式,从隶属于元素order的item元素中选择具有price等于12.60元素的price元素</p>
<blockquote>
<p>/order/item[price=16.50]/price</p>
</blockquote>
<h3 id="选择几个路径“-”"><a href="#选择几个路径“-”" class="headerlink" title="选择几个路径“|”"></a>选择几个路径“|”</h3><p>在XPath表达式中，使用 “|” 运算符可以选择几个路径 。实质上是逻辑“与”操作 下面的XPath表达式,从隶属于order的item元素中选择所有itemNumber 和description 元素</p>
<blockquote>
<p>/order/item/itemNumber | /order/item/description</p>
</blockquote>
<p>下面的XPath表达式,从文档中选择所有itemNumber 和description 元素</p>
<blockquote>
<p>//itemNumber | //description</p>
</blockquote>
<p>下面的XPath表达式,从文档中选择所有itemNumber ，description和price 元素</p>
<blockquote>
<p>//itemNumber | //description | //price</p>
</blockquote>
<p>下面的XPath表达式,选取属于order中item下所有itemNumber元素和从文档中选择所有description元素</p>
<blockquote>
<p>/order/item/itemnumber | //description</p>
</blockquote>
<h3 id="选择属性“-”"><a href="#选择属性“-”" class="headerlink" title="选择属性“@”"></a>选择属性“@”</h3><p>在XPath中，所有属性使用@前缀 下面的XPath表达式,选取所有名为catalog的属性</p>
<blockquote>
<p>//@catalog</p>
</blockquote>
<p>下面的XPath表达式,选取所有具有catalog属性的item元素</p>
<blockquote>
<p>//item[@catalog]</p>
</blockquote>
<p>下面的XPath表达式,选取所有具有任何属性的item元素</p>
<blockquote>
<p>//item[@*]</p>
</blockquote>
<p>下面的XPath表达式,选取所有具有catalog等于”parts”属性的item元素</p>
<blockquote>
<p>//item[@catalog=”parts”]</p>
</blockquote>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>（1）选取节点 下面列出了最有用的路径表达式：</p>
<p>表达式</p>
<p>描述</p>
<p>nodename</p>
<p>选取此节点的所有子节点。</p>
<p>/</p>
<p>从根节点选取。</p>
<p>//</p>
<p>从匹配选择的当前节点选择文档中的节点，而不考虑它们的位置。</p>
<p>.</p>
<p>选取当前节点。</p>
<p>..</p>
<p>选取当前节点的父节点。</p>
<p>@</p>
<p>选取属性。</p>
<p>（2）谓语（Predicates） 谓语用来查找某个特定的节点或者包含某个指定的值的节点。 谓语被嵌在方括号[]中。 （3）选取未知节点 XPath 通配符可用来选取未知的 XML 元素。</p>
<p>通配符</p>
<p>描述</p>
<p>*</p>
<p>匹配任何元素节点。</p>
<p>@*</p>
<p>匹配任何属性节点。</p>
<p>node()</p>
<p>匹配任何类型的节点。</p>
<p>（4）选取若干路径 通过在路径表达式中使用“|”运算符，您可以选取若干个路径。 更多有关XPath语法规则请访问<a href="http://www.w3school.com.cn/xpath/xpath_syntax.asp" target="_blank" rel="noopener">W3CSchool</a>。 （转载请注明出处：cdn.javacodes.cn，并加以原文链接）</p>
]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>XML</tag>
        <tag>XPath</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Dom4j操作XML</title>
    <url>/2016/07/16/%E4%BD%BF%E7%94%A8Dom4j%E6%93%8D%E4%BD%9CXML/</url>
    <content><![CDATA[<p><img data-src="https://cdn.javacodes.cn/files/2016/07/2016-07-16_04-17-22.png" alt="DOM4J"></p>
<blockquote>
<p>引言：XML（可扩展标记语言）在软件开发工程中取得了广泛的应用。在Java语言中操作XML有许多方法，最常用的方法就是使用JDom、Dom4j等第三方组件。本文将简单介绍使用Dom4j操作XML的基本方法。</p>
</blockquote>
<a id="more"></a>

<p>本文采用的Dom4j版本为1.6.1，下载地址见文章结尾。 废话不多说，先来看一下本文使用的XML文件内容：</p>
<?xml version="1.0" encoding="UTF-8"?>
<class id="1">
    <student>
        <num>0001</num>
        <name>张三</name>
        <age>19</age>
    </student>

<pre><code>&lt;student&gt;
    &lt;num&gt;0002&lt;/num&gt;
    &lt;name&gt;李四&lt;/name&gt;
    &lt;age&gt;21&lt;/age&gt;
    &lt;hobby&gt;
        &lt;name&gt;足球&lt;/name&gt;
        &lt;name&gt;篮球&lt;/name&gt;
    &lt;/hobby&gt;
&lt;/student&gt;

&lt;teacher&gt;
    &lt;name&gt;王老师&lt;/name&gt;
    &lt;age&gt;40&lt;/age&gt;
    &lt;course&gt;Java&lt;/course&gt;
&lt;/teacher&gt;</code></pre></class>

<p>在这个XML文件中，可以看到根节点为class，它有student和teacher子节点，而student子节点中又包含num、name、age、hobby等孙子辈节点，teacher子节点中包含name、age、course等孙子辈节点。 下面就使用dom4j来操作这个xml文件。</p>
<h3 id="解析XML"><a href="#解析XML" class="headerlink" title="解析XML"></a>解析XML</h3><p>当使用dom4j操作xml时，你想做的第一件事可能就是解析一个Xml文档，这个操作在dom4j中十分容易，使用下面的代码即可以轻松的解析xml文件并返回一个Document对象。</p>
<p>package cn.javacodes.dom4j;</p>
<p>import java.io.File;</p>
<p>import org.dom4j.Document;<br>import org.dom4j.Element;<br>import org.dom4j.io.SAXReader;</p>
<p>public class TestDom4j {</p>
<pre><code>public static void main(String\[\] args) throws Exception {
    // 获取SAX阅读器
    SAXReader reader = new SAXReader();
    // 获取Document对象
    Document doc = reader.read(new File(&quot;d:/DemoXML.xml&quot;));
    // 获取根节点
    Element root = doc.getRootElement();
    // 输出测试
    System.out.println(&quot;根节点：&quot; + root.getName() + &quot;,id=&quot;
            \+ root.attributeValue(&quot;id&quot;));
}</code></pre><p>}</p>
<p>输出结果：</p>
<blockquote>
<p>根节点：class,id=1</p>
</blockquote>
<h3 id="使用迭代器Iterator"><a href="#使用迭代器Iterator" class="headerlink" title="使用迭代器Iterator"></a>使用迭代器Iterator</h3><p>一个Element对象可以通过几个方法来返回一个标准的Java迭代器： （1）迭代所有子元素</p>
<p>// 迭代root元素的所有子元素<br>for (Iterator i = root.elementIterator(); i.hasNext(); ) {<br>      Element element = (Element) i.next();<br>      System.out.println(element.getName());<br>}</p>
<p>输出结果：</p>
<blockquote>
<p>student student teacher</p>
</blockquote>
<p>（2）通过元素名称迭代</p>
<p>// 通过元素名称“student”迭代子元素<br>for ( Iterator i = root.elementIterator( “student” ); i.hasNext(); ) {<br>    Element foo = (Element) i.next();<br>    System.out.println(foo.getName());<br>}</p>
<p>输出结果：</p>
<blockquote>
<p>student student</p>
</blockquote>
<p>（3）迭代所有属性</p>
<p>// 迭代root元素的所有属性<br>for ( Iterator i = root.attributeIterator(); i.hasNext(); ) {<br>      Attribute attribute = (Attribute) i.next();<br>      System.out.println(attribute.getName() + “:” + attribute.getValue());<br>}</p>
<p>输出结果：</p>
<blockquote>
<p>id:1</p>
</blockquote>
<h3 id="获取元素值"><a href="#获取元素值" class="headerlink" title="获取元素值"></a>获取元素值</h3><p>通常我们都需要获取xml元素标签内部的文本，也就是元素值，下面一个简单的例子递归显示所有的元素值：</p>
<p>public  static void showAllElementText(Element e){<br>      for (Iterator i = e.elementIterator(); i.hasNext(); ) {<br>           Element element = (Element) i.next();<br>           if (!element.elements().isEmpty()) {<br>                showAllElementText(element);<br>           } else {<br>                System.out.println(element.getName()+”=”+element.getTextTrim());<br>           }<br>      }<br>}</p>
<p>输出结果</p>
<blockquote>
<p>num=0001 name=张三 age=19 num=0002 name=李四 age=21 name=足球 name=篮球 name=王老师 age=40 course=Java</p>
</blockquote>
<h3 id="使用XPath表达式"><a href="#使用XPath表达式" class="headerlink" title="使用XPath表达式"></a>使用XPath表达式</h3><p>在Dom4j中使用XPath表达式可以更加轻松的操作XML文档，使用XPath表达式可以使用仅一行代码来进行复杂的操作，在Dom4j中使用XPath的几个简单示例代码如下： （1）查询单个节点（默认查找第一个）：</p>
<p>// 获取SAX阅读器<br>SAXReader reader = new SAXReader();<br>// 获取Document对象<br>Document doc = reader.read(new File(“d:/DemoXML.xml”));<br>// 获取student元素的name节点<br>Node node = doc.selectSingleNode(“//student/name”);<br>// 输出测试<br>System.out.println(node.getName() + “=” + node.getText());</p>
<p>（2）查询多个节点</p>
<p>// 获取所有student元素的name节点<br>List<Node> list = doc.selectNodes(“//student”);<br>// 输出测试<br>for (Node node : list) {<br>    System.out.println(node.getName()<br>                 + “:” + node.valueOf(“name”));<br>}</p>
<p>以上为两种经常使用的方法，另外如果你想在一个XHTML文档中查找到所有的超文本链接，可以使用下面这个窍门轻松实现：</p>
<pre><code>public void findLinks(Document document) throws DocumentException {
    List list = document.selectNodes( &quot;//a/@href&quot; );
    for (Iterator iter = list.iterator(); iter.hasNext(); ) {
        Attribute attribute = (Attribute) iter.next();
        String url = attribute.getValue();
    }
}</code></pre><p>如果你需要任何有关学习XPah表达式语言的帮助，你可以访问<a href="http://www.zvon.org/xxl/XPathTutorial/General/examples.html" target="_blank" rel="noopener" title="External Link">Zvon tutorial</a>进行学习，这里可以通过各种各样的例子帮助你学习。</p>
<h3 id="快速循环"><a href="#快速循环" class="headerlink" title="快速循环"></a>快速循环</h3><p>如果你需要操作一个十分庞大的XML文档，那么你应该使用快速循环的方法以避免在每次循环都创建Iterator对象，下面是一个简单的例子：</p>
<pre><code>public void treeWalk(Document document) {
    treeWalk( document.getRootElement() );
}

public void treeWalk(Element element) {
    for ( int i = 0, size = element.nodeCount(); i &lt; size; i++ ) {
        Node node = element.node(i);
        if ( node instanceof Element ) {
            treeWalk( (Element) node );
        }
        else {
            // 这里写你想要做的操作
        }
    }
}</code></pre><h3 id="创建XML-Document对象"><a href="#创建XML-Document对象" class="headerlink" title="创建XML Document对象"></a>创建XML Document对象</h3><p>在使用Dom4j时经常需要创建一个新的document，下面是一个简单的示例：</p>
<p>import org.dom4j.Document;<br>import org.dom4j.DocumentHelper;<br>import org.dom4j.Element;</p>
<p>public class Foo {</p>
<pre><code>public Document createDocument() {
    Document document = DocumentHelper.createDocument();
    Element root = document.addElement( &quot;root&quot; );

    Element author1 = root.addElement( &quot;author&quot; )
        .addAttribute( &quot;name&quot;, &quot;James&quot; )
        .addAttribute( &quot;location&quot;, &quot;UK&quot; )
        .addText( &quot;James Strachan&quot; );

    Element author2 = root.addElement( &quot;author&quot; )
        .addAttribute( &quot;name&quot;, &quot;Bob&quot; )
        .addAttribute( &quot;location&quot;, &quot;US&quot; )
        .addText( &quot;Bob McWhirter&quot; );

    return document;
}</code></pre><p>}</p>
<h3 id="写入XML文件"><a href="#写入XML文件" class="headerlink" title="写入XML文件"></a>写入XML文件</h3><p>使用Dom4j将Document对象写入到XML文件十分简单，你只需要1行代码即可解决：</p>
<p>document.write( new FileWriter( “foo.xml” ));</p>
<p>如果你想修改输出的格式，例如更易读的排版或者压缩（紧凑）的排版，再或者你想通过Writer或OutputStream进行输出，那么你可以使用XMLWriter类：</p>
<p>import org.dom4j.Document;<br>import org.dom4j.io.OutputFormat;<br>import org.dom4j.io.XMLWriter;</p>
<p>public class Foo {</p>
<pre><code>public void write(Document document) throws IOException {

    // 写入到一个文件
    XMLWriter writer = new XMLWriter(
        new FileWriter( &quot;output.xml&quot; )
    );
    writer.write( document );
    writer.close();


    // 更加美观的排版
    OutputFormat format = OutputFormat.createPrettyPrint();
    writer = new XMLWriter( System.out, format );
    writer.write( document );

    // 更加紧凑的排版
    format = OutputFormat.createCompactFormat();
    writer = new XMLWriter( System.out, format );
    writer.write( document );
}</code></pre><p>}</p>
<h3 id="Document对象与XML代码互转"><a href="#Document对象与XML代码互转" class="headerlink" title="Document对象与XML代码互转"></a>Document对象与XML代码互转</h3><p>如果你想通过一个Document对象或其他任何节点对象（例如Attribute或Element），你可以通过asXML()方法将它转换为XML文本字符串，例如：</p>
<pre><code>Document document = ...;
String text = document.asXML();</code></pre><p>如果你想从一个XML文本字符串转为一个Document对象，你可以使用DocumentHelper.parseText()方法进行解析：</p>
<pre><code>String text = &quot;&lt;person&gt; &lt;name&gt;James&lt;/name&gt; &lt;/person&gt;&quot;;
Document document = DocumentHelper.parseText(text);</code></pre><h3 id="XSLT"><a href="#XSLT" class="headerlink" title="XSLT"></a>XSLT</h3><p>通过Sum公司提供的JAXP API在一个Document上应用XSLT十分简单。这里有一个使用JAXP创建一个transformer并应用到Document上的例子：</p>
<p>import javax.xml.transform.Transformer;<br>import javax.xml.transform.TransformerFactory;</p>
<p>import org.dom4j.Document;<br>import org.dom4j.io.DocumentResult;<br>import org.dom4j.io.DocumentSource;</p>
<p>public class Foo {</p>
<pre><code>public Document styleDocument(
    Document document, 
    String stylesheet
) throws Exception {

    // 使用JAXP加载transformer
    TransformerFactory factory = TransformerFactory.newInstance();
    Transformer transformer = factory.newTransformer( 
        new StreamSource( stylesheet ) 
    );

    // 样式化document
    DocumentSource source = new DocumentSource( document );
    DocumentResult result = new DocumentResult();
    transformer.transform( source, result );

    // 返回转换后的document
    Document transformedDoc = result.getDocument();
    return transformedDoc;
}</code></pre><p>}</p>
<blockquote>
<p>（本文为本站原创，转载请注明来源：cdn.javacodes.cn并加以文章链接）</p>
</blockquote>
]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>XML</tag>
        <tag>dom4j</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Jackson解析JSON和序列化</title>
    <url>/2016/09/07/%E4%BD%BF%E7%94%A8Jackson%E8%A7%A3%E6%9E%90JSON%E5%92%8C%E5%BA%8F%E5%88%97%E5%8C%96/</url>
    <content><![CDATA[<p>在Web开发过程中，利用JSON可以帮助我们更加方便的开发我们的应用。那么在Java语言中，如何实现Java实例与JSON之间的相互转换（序列化与反序列化）呢？目前流行的JSON第三方类库有Jackson、Gson、Fastjson等，本文将简单介绍如何使用Jackson进行JSON的解析与序列化。</p>
<h3 id="一、获取Jackson"><a href="#一、获取Jackson" class="headerlink" title="一、获取Jackson"></a>一、获取Jackson</h3><p>获取Jackson可以通过Maven或直接下载jar包两种方式，通常我们只需要下载Jackson的jackson-core核心包即可，如果希望使用更多功能（例如注解），还需要下载另外的jar包。Jackson为我们提供了以下jar包：</p>
<ol>
<li>jackson-core.jar——核心包（必须），提供基于“流模式”解析的API。</li>
<li>jackson-databind——数据绑定包（可选），提供基于“对象绑定”和“树模型”相关API。</li>
<li>jackson-annotations——注解包（可选），提供注解功能。</li>
</ol>
<p>目前Jackson的最新版本为2.8.2。</p>
<a id="more"></a>

<h4 id="1、通过Maven获取"><a href="#1、通过Maven获取" class="headerlink" title="1、通过Maven获取"></a>1、通过Maven获取</h4><p>使用Maven获取Jackson十分方便，只需要在pom.xml中加入如下依赖即可：</p>
<pre><code>&lt;dependency&gt;
    &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;
    &lt;artifactId&gt;jackson-core&lt;/artifactId&gt;
    &lt;version&gt;2.8.2&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;
    &lt;artifactId&gt;jackson-annotations&lt;/artifactId&gt;
    &lt;version&gt;2.8.2&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;
    &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;
    &lt;version&gt;2.8.2&lt;/version&gt;
&lt;/dependency&gt;</code></pre><h4 id="2、直接下载jar包"><a href="#2、直接下载jar包" class="headerlink" title="2、直接下载jar包"></a>2、直接下载jar包</h4><p>官方为我们提供了两种直接下载jar包的途径：</p>
<ol>
<li>Central Maven repository：<a href="http://repo1.maven.org/maven2/com/fasterxml/jackson/core/" target="_blank" rel="noopener">http://repo1.maven.org/maven2/com/fasterxml/jackson/core/</a></li>
<li>Wiki：<a href="https://github.com/FasterXML/jackson-core/wiki" target="_blank" rel="noopener">https://github.com/FasterXML/jackson-core/wiki</a></li>
</ol>
<h3 id="二、用于测试的Java类"><a href="#二、用于测试的Java类" class="headerlink" title="二、用于测试的Java类"></a>二、用于测试的Java类</h3><p>为了方便我们学习和测试Jackson，我们首先准备一个Java类User，代码如下：</p>
<p>//JSON序列化和反序列化使用的User类<br>import java.util.Date;</p>
<p>public class User {<br>    private String name;<br>    private Integer age;<br>    private Date birthday;<br>    private String email;</p>
<pre><code>public String getName() {
    return name;
}
public void setName(String name) {
    this.name = name;
}

public Integer getAge() {
    return age;
}
public void setAge(Integer age) {
    this.age = age;
}

public Date getBirthday() {
    return birthday;
}
public void setBirthday(Date birthday) {
    this.birthday = birthday;
}

public String getEmail() {
    return email;
}
public void setEmail(String email) {
    this.email = email;
}</code></pre><p>}</p>
<h3 id="三、JSON序列化（Java对象转JSON）"><a href="#三、JSON序列化（Java对象转JSON）" class="headerlink" title="三、JSON序列化（Java对象转JSON）"></a>三、JSON序列化（Java对象转JSON）</h3><p>在使用Jackson之前，我们先来了解一下Jackson中的一个核心类：ObjectMapper，我们几乎所有的操作都在使用该类的API。 ObjectMapper有多个JSON序列化的方法，可以把JSON字符串保存File、OutputStream等不同的介质中。</p>
<ul>
<li>writeValue(File arg0, Object arg1)把arg1转成json序列，并保存到arg0文件中。</li>
<li>writeValue(OutputStream arg0, Object arg1)把arg1转成json序列，并保存到arg0输出流中。</li>
<li>writeValueAsBytes(Object arg0)把arg0转成json序列，并把结果输出成字节数组。</li>
<li>writeValueAsString(Object arg0)把arg0转成json序列，并把结果输出成字符串。</li>
</ul>
<p>这些方法使用起来都十分简单，为了简洁直观的介绍Jackson的使用方法，我们只介绍writeValueAsString(Object obj)的使用方法，用于将Java对象转换为一个JSON字符串，代码如下：</p>
<p>package cn.javacodes.jackson.test;</p>
<p>import com.fasterxml.jackson.core.JsonProcessingException;<br>import com.fasterxml.jackson.databind.ObjectMapper;</p>
<p>import java.text.ParseException;<br>import java.text.SimpleDateFormat;<br>import java.util.ArrayList;<br>import java.util.List;</p>
<p>/**<br> * Created by huzha on 2016-09-07.<br> */<br>public class JacksonTest {<br>    public static void main(String[] args) throws JsonProcessingException, ParseException {<br>        User user = new User();<br>        user.setName(“Eric”);<br>        user.setEmail(“<a href="mailto:huzhanfei@cdn.javacodes.cn">huzhanfei@cdn.javacodes.cn</a>“);<br>        user.setAge(20);<br>        user.setBirthday(new SimpleDateFormat(“yyyy-MM-dd”).parse(“1995-08-23”));</p>
<pre><code>    ObjectMapper mapper = new ObjectMapper();
    //User类转JSON
    //输出结果：{&quot;name&quot;:&quot;Eric&quot;,&quot;age&quot;:20,&quot;birthday&quot;:809107200000,&quot;email&quot;:&quot;huzhanfei@cdn.javacodes.cn&quot;}
    String json = mapper.writeValueAsString(user);
    System.out.println(json);

    //Java集合转JSON
    //输出结果：\[{&quot;name&quot;:&quot;Eric&quot;,&quot;age&quot;:20,&quot;birthday&quot;:809107200000,&quot;email&quot;:&quot;huzhanfei@cdn.javacodes.cn&quot;}\]
    List&lt;User&gt; users = new ArrayList&lt;User&gt;();
    users.add(user);
    String jsonlist = mapper.writeValueAsString(users);
    System.out.println(jsonlist);
}</code></pre><p>}</p>
<h3 id="四、JSON反序列化（JSON转Java对象）"><a href="#四、JSON反序列化（JSON转Java对象）" class="headerlink" title="四、JSON反序列化（JSON转Java对象）"></a>四、JSON反序列化（JSON转Java对象）</h3><p>Jackson为我们提供了许多JSON反序列化的方法，其中比较常用的方法如下： <img data-src="https://cdn.javacodes.cn/files/2016/09/2016-09-07_13-16-42.png" alt="QQ截图20160907211130"> 我们可以将文件、URL、字符串、流、字节数组等作为数据源进行解析，废话不多说，看例子：</p>
<p>package cn.javacodes.jackson.test;</p>
<p>import com.fasterxml.jackson.databind.ObjectMapper;</p>
<p>import java.io.IOException;<br>import java.text.ParseException;</p>
<p>/**<br> * Created by huzha on 2016-09-07.<br> */<br>public class JacksonTest {<br>    public static void main(String[] args) throws IOException, ParseException {<br>        String json = “{“name”:”Eric”,”age”:20,”birthday”:809107200000,”email”:”<a href="mailto:huzhanfei@cdn.javacodes.cn">huzhanfei@cdn.javacodes.cn</a>“}”;<br>        ObjectMapper mapper = new ObjectMapper();<br>        User user = mapper.readValue(json,User.class);<br>        // 输出结果：User{name=’Eric’, age=20, birthday=Wed Aug 23 00:00:00 CST 1995, email=’huzhanfei@cdn.javacodes.cn’}<br>        System.out.println(user.toString());<br>    }</p>
<p>}</p>
<h3 id="五、JSON注解"><a href="#五、JSON注解" class="headerlink" title="五、JSON注解"></a>五、JSON注解</h3><p>Jackson提供了一系列注解，方便对JSON序列化和反序列化进行控制，下面介绍一些常用的注解。 @JsonIgnore 此注解用于属性上，作用是进行JSON操作时忽略该属性。 @JsonFormat 此注解用于属性上，作用是把Date类型直接转化为想要的格式，如@JsonFormat(pattern = “yyyy-MM-dd HH-mm-ss”)。 @JsonProperty 此注解用于属性上，作用是把该属性的名称序列化为另外一个名称，如把trueName属性序列化为name，@JsonProperty(“name”)。 例如我们对User类进行一些修改，修改部分代码如下：</p>
<pre><code>//序列化时忽略此属性
@JsonIgnore
private Integer age;

//将日期进行格式化
@JsonFormat(pattern = &quot;yyyy-MM-dd&quot;)
private Date birthday;

//将email序列化为e-mail
@JsonProperty(&quot;e-mail&quot;)
private String email;</code></pre><p>再次通过上述序列化方法进行转换，查看输出结果为：</p>
<p>{“name”:”Eric”,”birthday”:”1995-08-22”,”e-mail”:”<a href="mailto:huzhanfei@cdn.javacodes.cn">huzhanfei@cdn.javacodes.cn</a>“}</p>
<p>可以看到注解已经起了效果。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在Java中使用Jackson解析和序列化JSON是十分方便的，而且Jackson在性能上也是十分出色的。使用Jackson操作JSON的核心是ObjectMapper类，我们几乎所有的操作都是通过这个类的实例来进行的。当然，如果你有兴趣，也可以尝试使用Gson或FastJson操作JSON，他们的使用方法大致上是相同的。</p>
]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Jackson</tag>
        <tag>JSON</tag>
      </tags>
  </entry>
  <entry>
    <title>全面理解HTTP</title>
    <url>/2016/07/16/%E5%85%A8%E9%9D%A2%E7%90%86%E8%A7%A3HTTP/</url>
    <content><![CDATA[<p><img data-src="https://cdn.javacodes.cn/files/2016/07/2016-07-15_16-08-11.png" alt=""></p>
<blockquote>
<p>引言：作为一名软件工程Web专业学生，对于HTTP的熟悉掌握是必不可少的，特此做记录，打造自己的HTTP栈。</p>
</blockquote>
<h2 id="URL与URI"><a href="#URL与URI" class="headerlink" title="URL与URI"></a>URL与URI</h2><p>我们经常接触到的就是URL了，它就是我们访问web的一个字符串地址，那么URI是什么呢？他们是什么关系呢？ URL：uniform resource location 统一资源定位符 URI：uniform resource identifier 统一资源标识符 这也就是说，URI是一种资源的标识；而URL也是一种URI，也是一种资源的标识，但它也指明了如何定位Locate到这个资源。 URI是一种抽象的资源标识，<strong>既可以是绝对的，也可以是相对的</strong>。但是URL是一种URI，它指明了定位的信息，必须是绝对的。</p>
<a id="more"></a>

<h2 id="报文-通信的桥梁"><a href="#报文-通信的桥梁" class="headerlink" title="报文-通信的桥梁"></a>报文-通信的桥梁</h2><p>客户端和服务器端通过相互发送<strong>报文</strong>进行通信，要深刻理解HTTP协议，就需要理解报文的格式和内容。</p>
<h3 id="报文的组成"><a href="#报文的组成" class="headerlink" title="报文的组成"></a>报文的组成</h3><p><img data-src="https://cdn.javacodes.cn/files/2016/07/2016-07-15_16-08-13.png" alt=""></p>
<p>无论是请求报文还是响应报文都需要有报文首部，当然报文主体并不是必需的。 一般来说，请求报文的格式如下：</p>
<p><img data-src="https://cdn.javacodes.cn/files/2016/07/2016-07-15_16-08-14.png" alt=""></p>
<p>看一下百度网站的请求报文：</p>
<p><img data-src="https://cdn.javacodes.cn/files/2016/07/2016-07-15_16-08-15.png" alt=""></p>
<p>简单的报文形式：</p>
<pre><code>GET / HTTP/1.1    //请求行，包含用于请求的方法，请求的URI，HTTP版本
//以下为各种首部字段
Host: www.baidu.com
Connection: keep-alive
Upgrade-Insecure-Requests: 1
User-Agent: Mozilla/5.0...
Accept-Encoding: gzip, deflate, sdch
Accept-Language: zh-CN,zh;q=0.8</code></pre><p>响应报文的格式如下：</p>
<p><img data-src="https://cdn.javacodes.cn/files/2016/07/2016-07-15_16-08-15-1.png" alt=""></p>
<p>看一下百度网站的响应报文：</p>
<p><img data-src="https://cdn.javacodes.cn/files/2016/07/2016-07-15_16-08-16.png" alt=""></p>
<pre><code>HTTP/1.1 200 OK   //状态行，包含表明响应结果的状态码，原因短语和HTTP版本
//以下为各种首部字段
Server: bfe/1.0.8.5
Date: Tue, 06 Oct 2015 14:48:28 GMT
Content-Type: text/html;charset=utf-8
Transfer-Encoding: chunked
Connection: keep-alive
Cache-Control: private</code></pre><h2 id="告知服务器意图的HTTP方法"><a href="#告知服务器意图的HTTP方法" class="headerlink" title="告知服务器意图的HTTP方法"></a>告知服务器意图的HTTP方法</h2><p>发送HTTP的方法有许多种，最常用的便是GET和POST，下面就这两种进行详细地说明。</p>
<ol>
<li><strong>GET</strong> GET方法用来请求访问URI所指定的资源，<strong>（我想访问你的某个资源）</strong>并不对服务器上的内容产生任何作用结果；每次GET的内容都是相同的。GET方式把请求所需要的参数放到<code>URL</code>中，直接就可以在URL中看见，有大小限制。</li>
<li><strong>POST</strong> POST方法用来传输实体主体，目的并不是获取响应的主体内容，<strong>（我要把这条信息告诉你）</strong>，POST方式则是把内容放在<code>报文内容</code>中，因此只要报文的内容没有限制，它的大小就没有限制。</li>
<li><strong>总结</strong> GET用于获取某个内容，POST用于提交某种数据请求。 按照使用场景来说，一般用户注册的内容属于私密的，这应该使用POST方式；而针对某一内容的查询，为了快速的响应，可以使用GET方式。</li>
</ol>
<h2 id="无状态协议与Cookie"><a href="#无状态协议与Cookie" class="headerlink" title="无状态协议与Cookie"></a>无状态协议与Cookie</h2><p>HTTP是一种无状态协议，也就是每一次发送都是一次新的开始，服务器并不知道也没有必要知道当前连接的客户端是否之前有过交集，那么当需要进行保存用户登录状态时，则出现了麻烦，这个时候使用Cookie来保存状态。 Cookie会根据服务器端发送的响应报文内的一个叫做<strong>Set-Cookie</strong>的首部字段，通知客户端保存Cookie（保存在自己的电脑里），当下次客户端发送请求时，<strong>Cookie值会被添加到请求报文中发送出去。</strong></p>
<h2 id="持久连接"><a href="#持久连接" class="headerlink" title="持久连接"></a>持久连接</h2><p>使用浏览器浏览一个包含多张图片的HTML页面时，浏览器会发起多次请求，如图所示：</p>
<p><img data-src="https://cdn.javacodes.cn/files/2016/07/2016-07-15_16-08-17.png" alt=""></p>
<p>显而易见每次请求会造成<strong>无谓的TCP连接建立和断开，增加通信量的开销。</strong></p>
<h4 id="引入持久连接"><a href="#引入持久连接" class="headerlink" title="引入持久连接"></a>引入持久连接</h4><p>持久连接的特点是，只要任意一端没有明确提出断开连接，则保持TCP连接状态。目前HTTP/1.1中默认为持久连接。</p>
<pre><code>Connection:keep-alive</code></pre><p><img data-src="https://cdn.javacodes.cn/files/2016/07/2016-07-15_16-08-18.png" alt=""></p>
<h2 id="管线化"><a href="#管线化" class="headerlink" title="管线化"></a>管线化</h2><p>管线化可以同时并行发送多个请求，不需要一个一个等待响应了。</p>
<h2 id="常见的状态码"><a href="#常见的状态码" class="headerlink" title="常见的状态码"></a>常见的状态码</h2><p><img data-src="https://cdn.javacodes.cn/files/2016/07/2016-07-15_16-08-20.png" alt=""></p>
<h2 id="确保安全的HTTPS"><a href="#确保安全的HTTPS" class="headerlink" title="确保安全的HTTPS"></a>确保安全的HTTPS</h2><p>HTTP+加密+认证+完整性保护 = HTTPS 一些登陆界面和购物结算界面使用HTTPS通信，也就是改用<code>https://</code>，HTTPS说简单点就是它的通信接口部分被SSL和TLS协议代替而已。</p>
<p><img data-src="https://cdn.javacodes.cn/files/2016/07/2016-07-15_16-08-21.png" alt=""></p>
<h2 id="身份认证"><a href="#身份认证" class="headerlink" title="身份认证"></a>身份认证</h2><p>有一些网址或者服务需要用户的身份信息，因此需要随时知道这些消息，但是肯定不能每次都让用户输入用户密码，因此关于认证就有下面几种方式：</p>
<p><img data-src="https://cdn.javacodes.cn/files/2016/07/2016-07-15_16-08-22.png" alt=""></p>
<p>在这里主要说一下FormBase认证，也就是<strong>表单认证</strong>。</p>
<h4 id="使用Cookie来管理Session"><a href="#使用Cookie来管理Session" class="headerlink" title="使用Cookie来管理Session"></a>使用Cookie来管理Session</h4><ol>
<li>客户端把用户IE和密码等登录信息放入报文的实体部分，以<strong>POST</strong>方式发送给服务器。</li>
<li>服务器进行身份认证，产生SessionID，加入到Set-Cookie内，返回给客户端。</li>
<li>客户端接收到SessionID后，将其加入Cookie，下次请求时，浏览器会自动发送Cookie。</li>
</ol>
<blockquote>
<p>在传输过程中，一种安全地保存密码方式是，先利用给密码加盐的方式增加额外信息，再使用散列hash函数计算出散列值后保存。</p>
</blockquote>
<p>书籍推荐：《图解HTTP》，轻松理解更全面的HTTP知识。</p>
<blockquote>
<p>文／LuckyJing（简书作者） 原文链接：<a href="http://www.jianshu.com/p/81632fea327c" target="_blank" rel="noopener">http://www.jianshu.com/p/81632fea327c</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Linux/服务器/网络</category>
      </categories>
      <tags>
        <tag>网络协议</tag>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title>关于本站</title>
    <url>/2015/10/06/%E5%85%B3%E4%BA%8E%E6%9C%AC%E7%AB%99/</url>
    <content><![CDATA[<h3 id="博客简介"><a href="#博客简介" class="headerlink" title="博客简介"></a>博客简介</h3><p>老H博客是一个以Java语言为主的技术分享博客，主要分享有关Java语言、Android、数据库、Web前端、计算机网络、服务器搭建、操作系统等相关技术经验。本站内容如无特殊注明来源均为原创文章，转载请遵循“创作共用”版权协议。</p>
<h3 id="博主简介"><a href="#博主简介" class="headerlink" title="博主简介"></a>博主简介</h3><p>博主目前为本科在校生，喜爱编程、互联网等一些计算机相关的技术，主要擅长领域为Java Web应用开发。博主受Java语言的影响，崇尚免费、开源，希望将更多的技术分享给大众。</p>
<a id="more"></a>

<h3 id="博客大事记"><a href="#博客大事记" class="headerlink" title="博客大事记"></a>博客大事记</h3><h4 id="2017年3月："><a href="#2017年3月：" class="headerlink" title="2017年3月："></a><strong>2017年3月：</strong></h4><ul>
<li>改用更加极简的单栏博客主题Simple</li>
</ul>
<h4 id="2016年11月："><a href="#2016年11月：" class="headerlink" title="2016年11月："></a>2016年11月：</h4><ul>
<li>改用更为简洁的黑糖主题</li>
<li>更新SSL证书</li>
</ul>
<h4 id="2016年7月："><a href="#2016年7月：" class="headerlink" title="2016年7月："></a>2016年7月：</h4><ul>
<li>弃用wpdx主题，改为Owl主题；</li>
<li>网站迁移至腾讯云CVM云服务器；</li>
<li>网站全面启用https协议</li>
</ul>
<h4 id="2015年10月7日："><a href="#2015年10月7日：" class="headerlink" title="2015年10月7日："></a>2015年10月7日：</h4><ul>
<li>放弃DUX主题，改用WP大学wpdx 2.4版本主题；</li>
<li>启用用户中心，支持用户投稿；增加站内信息功能；</li>
<li>增加问答中心功能；</li>
<li>网页静态文件存储于七牛云CDN</li>
</ul>
<h4 id="2015年10月6日："><a href="#2015年10月6日：" class="headerlink" title="2015年10月6日："></a>2015年10月6日：</h4><ul>
<li>博客正式运行。</li>
</ul>
<h4 id="2015年8月："><a href="#2015年8月：" class="headerlink" title="2015年8月："></a>2015年8月：</h4><ul>
<li>初步搭建博客，主题使用DUX主题，平台基于Wordpress。</li>
</ul>
<h3 id="版权声明"><a href="#版权声明" class="headerlink" title="版权声明"></a>版权声明</h3><p>为了保护和分享JavaCodes的作品，本站正式采用“创作共用”的授权协议。 <a href="http://creativecommons.org/" target="_blank" rel="noopener">Creative Commons</a>（<a href="http://cn.creativecommons.org/" target="_blank" rel="noopener">创作共用</a>）是网络上的数字作品（文学、美术、音乐等）许可授权机制，它致力于让任何创造性作品都有机会被更多人分享和再创造，共同促进人类知识作品在其生命周期内产生最大价值。 JavaCodes使用如下授权方式：</p>
<p><strong>署名·非商业用途·保持一致</strong></p>
<p><strong>你可以免费：</strong> ·拷贝、分发、呈现和表演当前作品 ·制作派生作品 <strong>但是必须基于以下条款：</strong> <strong>署名。</strong> 你必须明确标明原始作者的名字。 <strong>非商业用途。</strong> 你不可将当前作品用于商业目的。 <strong>保持一致。</strong> 如果你基于当前作品更改、变换或构造新作品，你应当按照与当前协议完全相同的协议分发最终作品。 对于任何二次使用或分发，你必须让其他人明确当前作品的授权条款，在得到作者的明确允许下，这里的某些条款可以放弃。 你的合理使用以及其他权利不受上述规定的影响。 英文版本的授权说明如下：</p>
<p>　　<strong>Attribution-NonCommercial-ShareAlike</strong></p>
<p><strong>You are free:</strong> ·to copy, distribute, display, and perform the work ·to make derivative works <strong>Under the following conditions:</strong> <strong>Attribution.</strong> You must attribute the work in the manner specified by the author or licensor. <strong>Noncommercial.</strong> You may not use this work for commercial purposes. <strong>Share Alike.</strong> If you alter, transform, or build upon this work, you may distribute the resulting work only under a license identical to this one. For any reuse or distribution, you must make clear to others the license terms of this work. Any of these conditions can be waived if you get permission from the copyright holder. <strong>Your fair use and other rights are in no way affected by the above.</strong> 关于授权协议的其他相关说明： ·为什么不使用“保留所有权利”（All Rights Reserved）的授权协议。 “版权”（Copyright）的概念是为了限制他人任意使用创作物的自由。我们通常熟知的唯一一种版权声明方式“保留所有权利”（All Rights Reserved）已经被滥用到任何人都可能触犯版权法律，人们只知道在自己的任何大小的作品（甚至本身也是在别人的成果基础上的再创造）都无以复加地声明为“保留所有权利”。这样的结果一方面导致原创者应有的权利得不到尊重，另一方面是很多优秀的作品（无论是艺术作品、文学作品、个人思想还是其他数字作品等）都无法得到最大价值利用或最广泛传播。虽然在很多国家的版权法律默认地赋予原创者很多权利，但是越来越多的人们开始意识到自己并非需要保留所有权利。相反他们更愿意选择“保留部分权利”（Some Rights Reserved）或“不保留权利”（No Rights Reserved）。而创作共用授权协议则可以更好的进行分享和传播网络上的数字作品，使得分享思想能在自己权益得到保护的前提下更好地实现。 ·使用本站内容的授权的参考示例。 注明出处或作者，如引用自（出处），原作者为某某，如果是在网上发布，需要以超链接形式标明文章原始出处。 非商业用途，不能为某种利益而擅自改动或者删除作者名发表在任何商业媒体上。 如果基于原作品内容进行再创作，应使用“署名·非商业用途·保持一致”的协议分发最终作品。</p>
]]></content>
      <categories>
        <category>随笔杂谈</category>
      </categories>
  </entry>
  <entry>
    <title>动态规划算法问题（经典找零案例）</title>
    <url>/2017/03/20/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%AE%97%E6%B3%95%E9%97%AE%E9%A2%98%EF%BC%88%E7%BB%8F%E5%85%B8%E6%89%BE%E9%9B%B6%E6%A1%88%E4%BE%8B%EF%BC%89/</url>
    <content><![CDATA[<p>问题： 给定数组arr，arr中的所有的值都为正数且不重复。每个值代表一种面值的货币，每种面值的货币可以使用任意张，再给定一个整数aim代表要找的钱数，求换钱有多少种方法。</p>
<a id="more"></a>

<h2 id="暴力搜索方法"><a href="#暴力搜索方法" class="headerlink" title="暴力搜索方法"></a>暴力搜索方法</h2><h3 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h3><p>若给定arr={5, 10, 25, 1}，aim=1000。</p>
<ul>
<li>用0张5元的货币，让[10, 25, 1]组成剩下的1000元，最终方法数记作——res1；</li>
<li>用1张5元的货币，让[10, 25, 1]组成剩下的995元，最终方法数记作——res2；</li>
<li>用2张5元的货币，让[10, 25, 1]组成剩下的990元，最终方法数记作——res3；</li>
<li>用3张5元的货币，让[10, 25, 1]组成剩下的985元，最终方法数记作——res4；</li>
<li>……</li>
<li>用200张5元的货币，让[10, 25, 1]组成剩下的0元，最终方法数记作——res201；</li>
</ul>
<p>则res1、res2……res201的累加和即为最终的结果。</p>
<h3 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h3><p>定义递归函数：<code>int process1(arr, index, aim)</code>, 它的含义是如果用arr[index……N-1]这些面值的钱组成aim，返回总的方法数。</p>
<pre><code>public static int coins1(int[] arr, int aim) {
    long startTime = System.currentTimeMillis();
    if (arr == null || arr.length == 0 || aim &lt; 0) {
        return 0;
    }
    int result = process1(arr,0,aim);
    long endTime = System.currentTimeMillis();
    System.out.println(&quot;暴力搜索方法所用时间：&quot; + (endTime - startTime) +&quot;ms&quot;);
    return result;
}

public static int process1(int[] arr, int index, int aim) {
    int res = 0;
    // 判断是否所有面值的货币均已经计算完
    if (index == arr.length) {
        // 判断本次递归调用时钱的总数是否已经凑够，如果已经凑够则将总方法数加1
        res = aim == 0 ? 1 : 0; 
    } else { 
        // 循环计算i张当前面值的货币
        for (int i = 0; arr[index] * i &lt;= aim; i++) {
            // 递归调用当使用i张当前面值的货币时，用其它货币组成剩下的钱
            res += process1(arr, index + 1, aim - arr[index] * i);
        }
    }
    return res;
}</code></pre><p>暴力搜索方法比较好理解，但他在计算中存在大量的重复递归过程。 例如已经使用了0张5元和1张10元货币的情况下，后续将求： <code>process1(arr,2,990)</code> 而当计算使用2张5元和0张10元时，后续同样需要求： <code>process1(arr,2,990)</code> 因此这种重复的递归运算将造成大量的时间浪费。</p>
<h2 id="记忆搜索方法"><a href="#记忆搜索方法" class="headerlink" title="记忆搜索方法"></a>记忆搜索方法</h2><h3 id="思路分析-1"><a href="#思路分析-1" class="headerlink" title="思路分析"></a>思路分析</h3><p>由于暴力搜索方法中存在大量的重复递归，因此我们可以使用一个“记忆库”用于存储已经计算过的值，在本题中，使用index货币组成剩下的aim钱的值是一一对应的，因此可以使用int mem[index][aim]数组表示记忆库，其元素值为可以组成的方法数。</p>
<h3 id="具体实现-1"><a href="#具体实现-1" class="headerlink" title="具体实现"></a>具体实现</h3><ul>
<li><p>每计算完一个process(index,aim)，都将结果放入mem中，index和aim组成共同的key，返回结果为value。</p>
</li>
<li><p>要进入一个递归过程时，先以index和aim组成的key在mem中进行查询，如果已经存在value，则直接使用，如果不存在，再进入递归过程。</p>
<pre><code>public static int process2(int[] arr, int index, int aim, int[][] mem) {
    int res = 0;
    // 判断是否所有面值的货币均已经计算完
    if (index == arr.length) {
        // 判断本次递归调用时钱的总数是否已经凑够，如果已经凑够则将总方法数加1
        res = aim == 0 ? 1 : 0;
    } else {
        int memVal = 0;
        // 循环计算i张当前面值的货币
        for (int i = 0; arr[index] * i &lt;= aim; i++) {
            // 获取记忆库中当使用i张index货币时，用其它货币组成剩下的钱
            memVal = mem[index + 1][aim - arr[index] * i];
            // 判断记忆库中存在记录
            if (memVal != 0) {
                // 将记忆库中的方法数累加到结果中
                res += memVal == -1 ? 0 : memVal;
            } else {
                // 递归调用当使用i张当前面值的货币时，用其它货币组成剩下的钱
                res += process2(arr, index + 1, aim - arr[index] * i, mem);
            }
        }
    }
    // 将使用index货币组成aim钱的结果存储到记忆库中
    mem[index][aim] = res == 0 ? -1 : res;
    return res;
}</code></pre></li>
</ul>
<h2 id="动态规划方法"><a href="#动态规划方法" class="headerlink" title="动态规划方法"></a>动态规划方法</h2><h3 id="思路分析-2"><a href="#思路分析-2" class="headerlink" title="思路分析"></a>思路分析</h3><p>如果arr长度为N，生成行数为N，列数为aim+1的矩阵dp。 dp[i][j]的含义是在使用arr[0]…arr[i]货币的情况下，组成钱数j的方法数。 <img data-src="https://cdn.javacodes.cn/files/2017/03/2017-03-19_17-51-32.jpg" alt="">￼</p>
<ol>
<li>如果完全不用arr[i]货币，只使用arr[0]…arr[i-1]货币时，方法数为dp[i-1][j]。</li>
<li>如果用1张arr[i]货币，剩下的钱使用arr[0]…arr[i-1]货币组成，方法数为dp[i-1][j-1*arr[i]]。</li>
<li>如果用2张arr[i]货币，剩下的钱使用arr[0]…arr[i-1]货币组成，方法数为dp[i-1][j-1*arr[i]]。</li>
<li>如果用3张arr[i]货币，剩下的钱使用arr[0]…arr[i-1]货币组成，方法数为dp[i-1][j-1*arr[i]]。</li>
<li>……</li>
</ol>
<p>dp[i][j]的值即为上述所有值得累加和。 求每一个位置都需要枚举，时间复杂度为O(aim)。dp一共有N*aim个位置，所以总的时间复杂度为O(N*aim2) 最终的结果值即为矩阵最右下角的dp[N-1][aim]。</p>
<h4 id="记忆搜索方法与动态规划方法的联系"><a href="#记忆搜索方法与动态规划方法的联系" class="headerlink" title="记忆搜索方法与动态规划方法的联系"></a>记忆搜索方法与动态规划方法的联系</h4><ul>
<li>记忆化搜索方法就是某种形态的动态规划方法。</li>
<li>记忆化搜索不关心到达某一个递归路径的路程。只是单纯地堆计算过的递归过程进行记录，避免重复递归的过程。</li>
<li>动态规划方法则是规定好每一个递归霍城的计算顺序，一次进行计算，后面的计算过程严格依赖前面的计算过程。</li>
<li>两者都是空间换时间的方法，也有枚举的过程，区别在于动态规划规定计算顺序，而记忆搜索不用规定。</li>
</ul>
<h4 id="什么是动态规划方法"><a href="#什么是动态规划方法" class="headerlink" title="什么是动态规划方法"></a>什么是动态规划方法</h4><ul>
<li>本质是利用申请的空间来记录每一个暴力搜索的计算过程，下次要用结果的时候直接使用，而不再进行重复的递归过程。</li>
<li>动态规划规定每一种递归状态的计算顺序，依次进行计算。从简单到复杂，按顺序计算。</li>
</ul>
<h3 id="具体实现-2"><a href="#具体实现-2" class="headerlink" title="具体实现"></a>具体实现</h3><pre><code>public static int process3(int[] arr, int aim) {
    // 创建dp矩阵
    int[][] dp = new int[arr.length][aim + 1];
    for (int i = 0; i &lt; dp.length; i++) {
        dp[i][0] = 1; // 凑成0元的方法必然是什么货币都不用，只有1种
        if (i == 0) {
            // 如果只是用arr[0]这一种货币，则能凑到j钱置1
            for (int j = 0; j &lt; dp[i].length; j++) {
                dp[i][j] = j % arr[i] == 0 ? 1 : 0;
            }
        } else {
            for (int j = 1; j &lt; dp[i].length; j++) {
                int temp = 0;
                // 枚举使用k张arr[i]货币后dp[i-1]中组成剩下钱数的方法数
                for (int k = 0; k * arr[i] &lt;= j; k++) {
                    temp += dp[i - 1][j - k * arr[i]];//方法数累加
                }
                dp[i][j] = temp;
            }
        }
    }
    // 返回dp矩阵最右下角的值即为最后结果
    return dp[arr.length - 1][aim];
}</code></pre><h2 id="动态规划方法的再优化"><a href="#动态规划方法的再优化" class="headerlink" title="动态规划方法的再优化"></a>动态规划方法的再优化</h2><h3 id="思路分析-3"><a href="#思路分析-3" class="headerlink" title="思路分析"></a>思路分析</h3><p>由于动态规划方法的执行顺序有着严格的规定，因此使得对算法的进一步优化成为可能。 对于刚才的问题中，我们需要枚举<code>dp[i-1][j-k*arr[i]]</code>(k=1,2,3…)并与<code>dp[i-1][j]</code>累加，实际上<code>dp[i-1][j-k*arr[i]]</code>(k=1,2,3…)的累加值就是<code>dp[i][j-arr[i]]</code>。 <img data-src="https://cdn.javacodes.cn/files/2017/03/2017-03-19_17-51-32-2.jpg" alt="">￼ 所以可以简化为： <code>dp[i][j] = dp[i][j-arr[i]] + dp[i-1][j]</code> 从而彻底省略枚举过程。时间复杂度从O(N<em>aim2)变为O(N</em>aim)</p>
<h3 id="具体实现-3"><a href="#具体实现-3" class="headerlink" title="具体实现"></a>具体实现</h3><p>经过优化后的代码实现如下：</p>
<pre><code>public static int process4(int[] arr, int aim) {
    // 创建dp矩阵
    int[][] dp = new int[arr.length][aim + 1];
    for (int i = 0; i &lt; dp.length; i++) {
        dp[i][0] = 1; // 凑成0元的方法必然是什么货币都不用，只有1种
        for (int j = 1; j &lt; dp[i].length; j++) {
            if (i == 0) {
                dp[i][j] = j % arr[i] == 0 ? 1 : 0;
            } else if(j &gt;= arr[i]){
                dp[i][j] = dp[i][j - arr[i]] + dp[i - 1][j];
            } else {
                dp[i][j] = dp[i - 1][j];
            }
        }
    }
    // 返回dp矩阵最右下角的值即为最后结果
    return dp[arr.length - 1][aim];
}</code></pre><h2 id="动态规划方法的空间优化"><a href="#动态规划方法的空间优化" class="headerlink" title="动态规划方法的空间优化"></a>动态规划方法的空间优化</h2><p>我们可以看到，经过优化的动态规划方法速度已经非常让人满意，但是它的空间浪费却很严重，我们发现动态规划方法是严格的矩阵从上至下、从左至右的方向顺序计算，那么其实真正每次计算式只需要用到的是当前行与当前行的上一行，因此其实我们可以将原本的dp二维矩阵简化为一维向量。 通过读取和修改向量本身的元素值来达到目的，修改后的代码如下所示：</p>
<pre><code>public static int process5(int[] arr, int aim) {
    // 创建dp向量
    int[] dp = new int[aim + 1];
    for (int i = 0; i &lt; arr.length; i++) {
        dp[0] = 1; // 凑成0元的方法必然是什么货币都不用，只有1种
        for (int j = 1; j &lt; dp.length; j++) {
            if (i == 0) {
                dp[j] = j % arr[i] == 0 ? 1 : 0;
            } else if(j &gt;= arr[i]){
                dp[j] += dp[j - arr[i]];
            }
        }
    }
    // 返回dp向量尾元素即最终结果
    return dp[aim];
}</code></pre><h2 id="各种计算方法的运行速度对比"><a href="#各种计算方法的运行速度对比" class="headerlink" title="各种计算方法的运行速度对比"></a>各种计算方法的运行速度对比</h2><p>上述所有的实现代码中，都加入了记录算法开始时间和结束时间的代码，我们通过运行测试，得到下面的结果： <img data-src="https://cdn.javacodes.cn/files/2017/03/2017-03-19_17-51-32-1.jpg" alt="">￼</p>
<ul>
<li>可以看到，暴力搜索方法毋庸置疑是速度最慢的，因为其存在大量的重复递归过程。</li>
<li>记忆化搜索方法由于避免了重复递归，因此效率更高一些。</li>
<li>经过优化的动态规划方法可以看到在我的实测环境中，运行时间近乎为0ms，可以说是非常快的。</li>
</ul>
<h2 id="暴力递归优化成动态规划方法的大体过程"><a href="#暴力递归优化成动态规划方法的大体过程" class="headerlink" title="暴力递归优化成动态规划方法的大体过程"></a>暴力递归优化成动态规划方法的大体过程</h2><ol>
<li>实现暴力递归方法；</li>
<li>在暴力搜索方法的函数中看看哪些参数可以代表递归过程。</li>
<li>找到代表递归过程的参数之后，记忆化搜索方法的实现非常容易。</li>
<li>通过分析记忆化搜索的依赖路径，进而实现动态规划。</li>
<li>根据记忆化搜索方法改出动态规划方法，进而看看是否能够化简，如果能化简，还能实现时间复杂度更低的动态规划方法。</li>
</ol>
<h2 id="动态规划方法的关键点"><a href="#动态规划方法的关键点" class="headerlink" title="动态规划方法的关键点"></a>动态规划方法的关键点</h2><ol>
<li><strong>最优化原理</strong>：也就是<strong>最优子结构性质</strong>。指一个最优化策略具有这样的性质，不论过去状态和决策如何，对前面的决策所形成的状态而言，余下的诸决策必须构成最优策略。简单来说就是一个最优化策略的子策略总是最优的，如果一个问题满足最优化原理，就成为其具有最优子结构性质。</li>
<li><strong>无后效性</strong>：指某状态下决策的收益，只与状态和决策相关，与到达该状态的路径无关。</li>
<li><strong>子问题的重叠性</strong>：动态规划将原来具有指数级时间复杂度的暴力搜索算法改进成了具有多项式时间复杂度的算法。其中的关键在于解决冗余，这是动态规划算法的根本目的。</li>
</ol>
<blockquote>
<p>本文为博主学习牛客网课程<a href="https://www.nowcoder.com/courses/semester/algorithm" target="_blank" rel="noopener">《直通BAT-面试算法精讲课》</a>的学习笔记 如果需要购买该课程，可以使用博主的优惠码：<strong>Adg00aI</strong>，获取10元优惠。</p>
</blockquote>
]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>完美配置CentOS+Nginx+MySQL+PHP（LNMP）网站环境</title>
    <url>/2016/07/18/%E5%AE%8C%E7%BE%8E%E9%85%8D%E7%BD%AECentOS+Nginx+MySQL+PHP%EF%BC%88LNMP%EF%BC%89%E7%BD%91%E7%AB%99%E7%8E%AF%E5%A2%83/</url>
    <content><![CDATA[<p><img data-src="https://cdn.javacodes.cn/files/2016/07/2016-07-18_04-24-10.jpg" alt="6597283071912770216"></p>
<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ol>
<li><p>配置防火墙，开启80端口、3306端口、如需使用SSH还应开启22端口、使用FTP需开启21端口、如果网站使用SSL访问需开启443端口： 删除原有的 iptables , 添加合适的配置</p>
<p>rm -rf /etc/sysconfig/iptables<br>vi /etc/sysconfig/iptables</p>
<a id="more"></a>

<p>添加如下内容 :</p>
<p>################################ 添加好之后防火墙规则如下所示################################<br># Firewall configuration written by system-config-firewall<br># Manual customization of this file is not recommended.<br>*filter<br>:INPUT ACCEPT [0:0]<br>:FORWARD ACCEPT [0:0]<br>:OUTPUT ACCEPT [0:0]<br>-A INPUT -m state –state ESTABLISHED,RELATED -j ACCEPT<br>-A INPUT -p icmp -j ACCEPT<br>-A INPUT -i lo -j ACCEPT<br>-A INPUT -m state –state NEW -m tcp -p tcp –dport 22 -j ACCEPT<br>-A INPUT -m state –state NEW -m tcp -p tcp –dport 80 -j ACCEPT<br>-A INPUT -m state –state NEW -m tcp -p tcp –dport 8080 -j ACCEPT<br>-A INPUT -m state –state NEW -m tcp -p tcp –dport 8081 -j ACCEPT<br>-A INPUT -m state –state NEW -m tcp -p tcp –dport 8082 -j ACCEPT<br>-A INPUT -m state –state NEW -m tcp -p tcp –dport 3306 -j ACCEPT<br>-A INPUT -j REJECT –reject-with icmp-host-prohibited<br>-A FORWARD -j REJECT –reject-with icmp-host-prohibited<br>COMMIT<br>#######################################################################################</p>
<p><code>:wq</code>保存退出, 重启防火墙使配置生效</p>
<p>/etc/init.d/iptables restart</p>
</li>
<li><p>关闭SELINUX</p>
<p>rm -rf  /etc/selinux/config<br>vi /etc/selinux/config</p>
<p>添加一行内容:</p>
<p>SELINUX=disabled</p>
<p><code>:wq</code>保存退出</p>
<p>#重启系统<br>shutdown -r now</p>
</li>
<li><p>安装第三方yum源</p>
<p>#安装下载工具<br>yum install wget<br>#下载<br>wget <a href="http://www.atomicorp.com/installers/atomic" target="_blank" rel="noopener">http://www.atomicorp.com/installers/atomic</a><br>#安装<br>sh ./atomic<br>#更新yum源<br>yum check-update</p>
</li>
</ol>
<h2 id="开始安装"><a href="#开始安装" class="headerlink" title="开始安装"></a>开始安装</h2><h3 id="一-安装nginx"><a href="#一-安装nginx" class="headerlink" title="一. 安装nginx"></a>一. 安装nginx</h3><p>#删除系统自带的软件包<br>yum remove httpd* php*<br>#安装nginx<br>yum install -y nginx<br>#设置nginx开机启动<br>chkconfig nginx on<br>#启动nginx<br>service nginx start</p>
<h3 id="二-安装PHP"><a href="#二-安装PHP" class="headerlink" title="二. 安装PHP"></a>二. 安装PHP</h3><ol>
<li><p>检查当前安装的PHP包</p>
<p>yum list installed | grep php</p>
<p>如果有安装的PHP包，先删除他们, 如:</p>
<p>yum remove php.x86_64 php-cli.x86_64 php-common.x86_64</p>
</li>
<li><p>配置安装包源:</p>
<p># Centos 5.X<br>rpm -Uvh <a href="http://mirror.webtatic.com/yum/el5/latest.rpm" target="_blank" rel="noopener">http://mirror.webtatic.com/yum/el5/latest.rpm</a><br># CentOs 6.x<br>rpm -Uvh <a href="http://mirror.webtatic.com/yum/el6/latest.rpm" target="_blank" rel="noopener">http://mirror.webtatic.com/yum/el6/latest.rpm</a><br># CentOs 7.X<br>rpm -Uvh <a href="https://mirror.webtatic.com/yum/el7/epel-release.rpm" target="_blank" rel="noopener">https://mirror.webtatic.com/yum/el7/epel-release.rpm</a><br>rpm -Uvh <a href="https://mirror.webtatic.com/yum/el7/webtatic-release.rpm" target="_blank" rel="noopener">https://mirror.webtatic.com/yum/el7/webtatic-release.rpm</a></p>
<p>如果想删除上面安装的包，重新安装</p>
<p>rpm -qa | grep webstatic<br>rpm -e  [上面搜索到的包即可]</p>
</li>
<li><p>执行安装</p>
<p>yum -y install php56w.x86_64<br>yum -y –enablerepo=webtatic install php56w-devel<br>yum -y install php56w-xml.x86_64 php56w-gd.x86_64 php56w-ldap.x86_64 php56w-mbstring.x86_64 php56w-mcrypt.x86_64 php56w-mysql.x86_64 php56w-pdo.x86_64 php56w-opcache.x86_64</p>
</li>
<li><p>安装PHP FPM</p>
<p>yum -y install php56w-fpm<br>#设置php-fpm开机启动<br>chkconfig php-fpm on<br>#启动php-fpm<br>/etc/init.d/php-fpm start</p>
<p>注：如果想更换到php5.5或5.4版本, 直接把上面的56w换成55w或者54w就可以了</p>
</li>
</ol>
<h3 id="三-安装-MySQL"><a href="#三-安装-MySQL" class="headerlink" title="三. 安装 MySQL"></a>三. 安装 MySQL</h3><ol>
<li><p>安装</p>
<p>yum install -y mysql mysql-server<br>#启动MySQL<br>/etc/init.d/mysqld start<br>#设为开机启动<br>chkconfig mysqld on<br>#拷贝配置文件（注意：如果/etc目录下面默认有一个my.cnf，直接覆盖即可）<br>cp /usr/share/mysql/my-medium.cnf /etc/my.cnf</p>
</li>
<li><p>为root账户设置密码</p>
<p>mysql_secure_installation<br># 回车，根据提示输入Y，输入2次密码，回车，根据提示一路输入Y，最后出现：Thanks for using MySQL!<br>#  MySql密码设置完成，重新启动 MySQL：<br>#重启<br>/etc/init.d/mysqld restart<br>#停止<br>/etc/init.d/mysqld stop<br>#启动<br>/etc/init.d/mysqld start</p>
</li>
</ol>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><h3 id="1-配置nginx"><a href="#1-配置nginx" class="headerlink" title="1. 配置nginx"></a>1. 配置nginx</h3><p>rm -rf /etc/nginx/conf.d/*<br>vi /etc/nginx/conf.d/default.conf</p>
<p>添加如下内容 :</p>
<p>server{<br>    listen      80;<br>    server_name _;<br>    index index.php index.html index.htm;<br>    root  /var/www;</p>
<pre><code>location ~ .*.(php|php5)?$
{
        #fastcgi_pass  unix:/tmp/php-cgi.sock;
        fastcgi_pass  127.0.0.1:9000;
        fastcgi_index index.php;
        include fastcgi.conf;
}

location / {
    try\_files $uri $uri/ /index.php?$query\_string;
}</code></pre><p>}</p>
<blockquote>
<p><em>说明: <code>/var/www</code> 为web根目录, <code>location / ...</code> 为url的rewrite,隐藏 <code>index.php</code></em></p>
</blockquote>
<h3 id="2-配置php-fpm"><a href="#2-配置php-fpm" class="headerlink" title="2. 配置php-fpm"></a>2. 配置php-fpm</h3><p>vi /etc/php-fpm.d/<a href="http://www.conf" target="_blank" rel="noopener">www.conf</a></p>
<p>将用户和用户组设置为nginx, 默认为 Apache, 如:</p>
<p>#修改用户为nginx<br>user = nginx<br> #修改组为nginx<br>group = nginx</p>
<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>启动命令:</p>
<p># nginx 重启 | 启动 | 停止<br>service nginx restart | start | stop<br># php-fpm 重启 | 启动 | 停止<br>service php-fpm restart | start | stop<br># mysql 重启 | 启动 | 停止<br>service mysqld restart | start | stop</p>
<p>一些文件的目录:</p>
<p># nginx.conf<br>/etc/nginx/nginx.conf<br># php.ini<br>/etc/php.ini<br># my.cnf<br>/etc/my.cnf<br># 项目根目录<br>/var/www</p>
<h2 id="开始测试"><a href="#开始测试" class="headerlink" title="开始测试"></a>开始测试</h2><p>vi /var/www/index.php</p>
<p>添加以下代码</p>
<?php
phpinfo();
?>

<p><code>:wq!</code> 保存退出</p>
<p>#设置权限<br>chown nginx.nginx /var/www -R<br>#重启nginx<br>service nginx restart<br>#重启php-fpm<br>service php-fpm restart</p>
<p>在客户端浏览器输入服务器IP地址(如: 127.0.0.1)，可以看到相关的配置信息！ 说明lnmp配置成功！  </p>
<blockquote>
<p>本文参考自：<a href="http://www.jianshu.com/p/447e02d7951d" target="_blank" rel="noopener">点击进入</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Linux/服务器/网络</category>
      </categories>
      <tags>
        <tag>CentOs</tag>
        <tag>LNMP</tag>
        <tag>MySQL</tag>
        <tag>Nginx</tag>
        <tag>PHP</tag>
        <tag>服务器搭建</tag>
      </tags>
  </entry>
  <entry>
    <title>浅析ClassNotFoundException与NoClassDefFoundError</title>
    <url>/2017/03/18/%E6%B5%85%E6%9E%90ClassNotFoundException%E4%B8%8ENoClassDefFoundError/</url>
    <content><![CDATA[<p>最近接到电话面试中，面试官问我ClassNotFoundException与NoClassDefFoundError有什么样的区别，至于前者经常遇到，我还是能答上一些，至于后者，完全没遇到过啊，只好瞎编了，都忘记当时是怎么回答的。然后面试官问我他们都会出现在哪些情况，ClassNotFoundException我还可以说出几种情况，可是后者这下不能编了，只好求饶。结果面试官还给我讲解了一下，感觉非常尴尬。 回来以后又查阅了一些相关的资料，并尝试了一下，整理分享给网友。</p>
<a id="more"></a>

<h3 id="ClassNotFoundException"><a href="#ClassNotFoundException" class="headerlink" title="ClassNotFoundException"></a>ClassNotFoundException</h3><p>这个异常我们遇到的频率还是很高的，先来看看官方文档中的定义：</p>
<blockquote>
<p>当应用程序试图使用以下方法通过<strong>字符串名</strong>加载类时，抛出该异常：</p>
<ul>
<li>Class 类中的 forName 方法。</li>
<li>ClassLoader 类中的 findSystemClass 方法。</li>
<li>ClassLoader 类中的 loadClass 方法。</li>
</ul>
<p>但是没有找到具有指定名称的类的定义。 从 1.4 版本开始，此异常已经更新，以符合通用的异常链机制。在构造时提供并通过 <code>getException()</code> 方法访问的“加载类时引发的可选异常”，现在被称为原因，它可以通过 <code>Throwable.getCause()</code> 方法以及与上面提到的“遗留方法”来访问。</p>
</blockquote>
<p>也就是说在<strong>类加载</strong>阶段，通过类全名加载类时，如果不能找到这个类，就会抛出ClassNotFoundException，当然，通常在开发中可能出现该异常的情况总结如下：</p>
<ol>
<li>所需要的支持类库放错了地方，并没有放在类路径(CLASSPATH环境变量)里面。</li>
<li>使用了重复的类库，且版本不一致。导致低版本的被优先使用。</li>
<li>类名错了，一般是使用Class.forName的时候，手工指定了类名的情况。</li>
<li>没有导入纯JAVA驱动包。</li>
</ol>
<p>当然啦，我经常遇到这个异常，尤其是在使用JDBC加载驱动的时候，驱动类的类全名真的是很难记的有木有！</p>
<h3 id="NoClassDefFoundError"><a href="#NoClassDefFoundError" class="headerlink" title="NoClassDefFoundError"></a>NoClassDefFoundError</h3><p>可以看到这个错误的类名以Error结尾，因此它属于JVM虚拟机错误，不需要程序员捕获，下图是它的继承结构： <img data-src="https://cdn.javacodes.cn/files/2017/03/2017-03-18_02-57-20.jpg" alt="">￼ 还是同样先来看下官方文档中的定义：</p>
<blockquote>
<p>当 Java 虚拟机或 ClassLoader 实例试图在类的定义中加载（作为通常方法调用的一部分或者作为使用 new 表达式创建的新实例的一部分），但无法找到该类的定义时，抛出此异常。 当前执行的类被编译时，所搜索的类定义存在，但无法再找到该定义。</p>
</blockquote>
<p>通俗的说，就是编译的时候有这个类，而<strong>运行期</strong>的时候，这个类找不到了！就会抛出NoClassDefFoundError异常。 想要演示这个异常的出现很简单，只需要在编译好的class文件中将对应类的class文件删除，运行的时候就会抛出这个异常啦！ 那么在实际开发中，通常会在哪些情况遇到该异常呢？通常我们在开发过程中，肯定不会刻意的去删除某个class文件，但仍然有出现该异常的情况。 比如我们在使用第三方jar包时，有些SDK也会设定自己的Classpath。编译过程结束后在运行的过程中就要将已开发的应用和所有引入的jar包拷贝到应用服务器的相应目录下才可以运行，而应用服务器使用的Classpath也很有可能与SDK的不同，在这个过程中就有很大的几率造成双方环境不一致。所以很多开发者就会遇到在SDK中可以编译，运行也没有问题，但是同样的程序放到应用服务器上就出现NoClassDefFoundErr这个异常这种情况。</p>
<blockquote>
<p><strong>参考文章</strong>： 1. JavaTM Platform Standard Edition 6 的 API 规范 2. <a href="http://blog.csdn.net/fengkuangqi/article/details/32324053" target="_blank" rel="noopener">NoClassDefDoundErr与ClassNotFoundException区别</a></p>
</blockquote>
]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>类加载</tag>
        <tag>异常</tag>
      </tags>
  </entry>
  <entry>
    <title>常用JVM启动参数</title>
    <url>/2017/03/11/%E5%B8%B8%E7%94%A8JVM%E5%90%AF%E5%8A%A8%E5%8F%82%E6%95%B0/</url>
    <content><![CDATA[<h3 id="verbose"><a href="#verbose" class="headerlink" title="-verbose"></a>-verbose</h3><p>java -verbose[:class|gc|jni] 在输出设备上显示虚拟机运行信息。</p>
<ul>
<li>-verbose:class：监视输出运行期间的类加载情况</li>
<li>-verbose:gc：监视输出运行期间的内存回收GC情况</li>
<li>-verbose:jni：监视输出native方法调用的相关情况，一般用于诊断jni调用错误信息。</li>
</ul>
<a id="more"></a>

<h3 id="堆设置"><a href="#堆设置" class="headerlink" title="堆设置"></a>堆设置</h3><ul>
<li><strong>-Xms:</strong>初始堆大小</li>
<li><strong>-Xmx:</strong>最大堆大小</li>
<li><strong>-XX:NewSize=n:</strong>设置年轻代大小</li>
<li><strong>-XX:NewRatio=n:</strong>设置年轻代和年老代的比值。如:为3，表示年轻代与年老代比值为1：3，年轻代占整个年轻代年老代和的1/4</li>
<li><strong>-XX:SurvivorRatio=n:</strong>年轻代中Eden区与两个Survivor区的比值。注意Survivor区有两个。如：3，表示Eden：Survivor=3：2，一个Survivor区占整个年轻代的1/5</li>
<li><strong>-XX:MaxPermSize=n:</strong>设置持久代大小</li>
</ul>
<h3 id="收集器设置"><a href="#收集器设置" class="headerlink" title="收集器设置"></a>收集器设置</h3><ul>
<li><strong>-XX:+UseSerialGC:</strong>设置串行收集器</li>
<li><strong>-XX:+UseParallelGC:</strong>设置并行收集器</li>
<li><strong>-XX:+UseParalledlOldGC:</strong>设置并行年老代收集器</li>
<li><strong>-XX:+UseConcMarkSweepGC:</strong>设置并发收集器</li>
</ul>
<h3 id="垃圾回收统计信息"><a href="#垃圾回收统计信息" class="headerlink" title="垃圾回收统计信息"></a>垃圾回收统计信息</h3><ul>
<li><strong>-XX:+PrintGC</strong></li>
<li><strong>-XX:+PrintGCDetails</strong></li>
<li><strong>-XX:+PrintGCTimeStamps</strong></li>
<li><strong>-Xloggc:filename</strong></li>
</ul>
<h3 id="并行收集器设置"><a href="#并行收集器设置" class="headerlink" title="并行收集器设置"></a>并行收集器设置</h3><ul>
<li><strong>-XX:ParallelGCThreads=n:</strong>设置并行收集器收集时使用的CPU数。并行收集线程数。</li>
<li><strong>-XX:MaxGCPauseMillis=n:</strong>设置并行收集最大暂停时间</li>
<li><strong>-XX:GCTimeRatio=n:</strong>设置垃圾回收时间占程序运行时间的百分比。公式为1/(1+n)</li>
</ul>
<h3 id="并发收集器设置"><a href="#并发收集器设置" class="headerlink" title="并发收集器设置"></a>并发收集器设置</h3><ul>
<li><strong>-XX:+CMSIncrementalMode:</strong>设置为增量模式。适用于单CPU情况。</li>
<li><strong>-XX:ParallelGCThreads=n:</strong>设置并发收集器年轻代收集方式为并行收集时，使用的CPU数。并行收集线程数。</li>
</ul>
]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>深入分析 Java 中的中文编码问题</title>
    <url>/2016/07/05/%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90%20Java%20%E4%B8%AD%E7%9A%84%E4%B8%AD%E6%96%87%E7%BC%96%E7%A0%81%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>编码问题一直困扰着开发人员，尤其在 Java 中更加明显，因为 Java 是跨平台语言，不同平台之间编码之间的切换较多。本文将向你详细介绍 Java 中编码问题出现的根本原因，你将了解到：Java 中经常遇到的几种编码格式的区别；Java 中经常需要编码的场景；出现中文问题的原因分析；在开发 Java web 程序时可能会存在编码的几个地方，一个 HTTP 请求怎么控制编码格式？如何避免出现中文问题？</p>
<a id="more"></a>

<h2 id="几种常见的编码格式"><a href="#几种常见的编码格式" class="headerlink" title="几种常见的编码格式"></a>几种常见的编码格式</h2><h3 id="为什么要编码"><a href="#为什么要编码" class="headerlink" title="为什么要编码"></a>为什么要编码</h3><p>不知道大家有没有想过一个问题，那就是为什么要编码？我们能不能不编码？要回答这个问题必须要回到计算机是如何表示我们人类能够理解的符号的，这些符号也就是我们人类使用的语言。由于人类的语言有太多，因而表示这些语言的符号太多，无法用计算机中一个基本的存储单元—— byte 来表示，因而必须要经过拆分或一些翻译工作，才能让计算机能理解。我们可以把计算机能够理解的语言假定为英语，其它语言要能够在计算机中使用必须经过一次翻译，把它翻译成英语。这个翻译的过程就是编码。所以可以想象只要不是说英语的国家要能够使用计算机就必须要经过编码。这看起来有些霸道，但是这就是现状，这也和我们国家现在在大力推广汉语一样，希望其它国家都会说汉语，以后其它的语言都翻译成汉语，我们可以把计算机中存储信息的最小单位改成汉字，这样我们就不存在编码问题了。 所以总的来说，编码的原因可以总结为：</p>
<ol>
<li>计算机中存储信息的最小单元是一个字节即 8 个 bit，所以能表示的字符范围是 0~255 个</li>
<li>人类要表示的符号太多，无法用一个字节来完全表示</li>
<li>要解决这个矛盾必须需要一个新的数据结构 char，从 char 到 byte 必须编码</li>
</ol>
<h3 id="如何“翻译”"><a href="#如何“翻译”" class="headerlink" title="如何“翻译”"></a>如何“翻译”</h3><p>明白了各种语言需要交流，经过翻译是必要的，那又如何来翻译呢？计算中提拱了多种翻译方式，常见的有 ASCII、ISO-8859-1、GB2312、GBK、UTF-8、UTF-16 等。它们都可以被看作为字典，它们规定了转化的规则，按照这个规则就可以让计算机正确的表示我们的字符。目前的编码格式很多，例如 GB2312、GBK、UTF-8、UTF-16 这几种格式都可以表示一个汉字，那我们到底选择哪种编码格式来存储汉字呢？这就要考虑到其它因素了，是存储空间重要还是编码的效率重要。根据这些因素来正确选择编码格式，下面简要介绍一下这几种编码格式。</p>
<ul>
<li>ASCII 码</li>
</ul>
<p>学过计算机的人都知道 ASCII 码，总共有 128 个，用一个字节的低 7 位表示，0<del>31 是控制字符如换行回车删除等；32</del>126 是打印字符，可以通过键盘输入并且能够显示出来。</p>
<ul>
<li>ISO-8859-1</li>
</ul>
<p>128 个字符显然是不够用的，于是 ISO 组织在 ASCII 码基础上又制定了一些列标准用来扩展 ASCII 编码，它们是 ISO-8859-1~ISO-8859-15，其中 ISO-8859-1 涵盖了大多数西欧语言字符，所有应用的最广泛。ISO-8859-1 仍然是单字节编码，它总共能表示 256 个字符。</p>
<ul>
<li>GB2312</li>
</ul>
<p>它的全称是《信息交换用汉字编码字符集 基本集》，它是双字节编码，总的编码范围是 A1-F7，其中从 A1-A9 是符号区，总共包含 682 个符号，从 B0-F7 是汉字区，包含 6763 个汉字。</p>
<ul>
<li>GBK</li>
</ul>
<p>全称叫《汉字内码扩展规范》，是国家技术监督局为 windows95 所制定的新的汉字内码规范，它的出现是为了扩展 GB2312，加入更多的汉字，它的编码范围是 8140~FEFE（去掉 XX7F）总共有 23940 个码位，它能表示 21003 个汉字，它的编码是和 GB2312 兼容的，也就是说用 GB2312 编码的汉字可以用 GBK 来解码，并且不会有乱码。</p>
<ul>
<li>GB18030</li>
</ul>
<p>全称是《信息交换用汉字编码字符集》，是我国的强制标准，它可能是单字节、双字节或者四字节编码，它的编码与 GB2312 编码兼容，这个虽然是国家标准，但是实际应用系统中使用的并不广泛。</p>
<ul>
<li>UTF-16</li>
</ul>
<p>说到 UTF 必须要提到 Unicode（Universal Code 统一码），ISO 试图想创建一个全新的超语言字典，世界上所有的语言都可以通过这本字典来相互翻译。可想而知这个字典是多么的复杂，关于 Unicode 的详细规范可以参考相应文档。Unicode 是 Java 和 XML 的基础，下面详细介绍 Unicode 在计算机中的存储形式。 UTF-16 具体定义了 Unicode 字符在计算机中存取方法。UTF-16 用两个字节来表示 Unicode 转化格式，这个是定长的表示方法，不论什么字符都可以用两个字节表示，两个字节是 16 个 bit，所以叫 UTF-16。UTF-16 表示字符非常方便，每两个字节表示一个字符，这个在字符串操作时就大大简化了操作，这也是 Java 以 UTF-16 作为内存的字符存储格式的一个很重要的原因。</p>
<ul>
<li>UTF-8</li>
</ul>
<p>UTF-16 统一采用两个字节表示一个字符，虽然在表示上非常简单方便，但是也有其缺点，有很大一部分字符用一个字节就可以表示的现在要两个字节表示，存储空间放大了一倍，在现在的网络带宽还非常有限的今天，这样会增大网络传输的流量，而且也没必要。而 UTF-8 采用了一种变长技术，每个编码区域有不同的字码长度。不同类型的字符可以是由 1~6 个字节组成。 UTF-8 有以下编码规则：</p>
<ol>
<li>如果一个字节，最高位（第 8 位）为 0，表示这是一个 ASCII 字符（00 - 7F）。可见，所有 ASCII 编码已经是 UTF-8 了。</li>
<li>如果一个字节，以 11 开头，连续的 1 的个数暗示这个字符的字节数，例如：110xxxxx 代表它是双字节 UTF-8 字符的首字节。</li>
<li>如果一个字节，以 10 开始，表示它不是首字节，需要向前查找才能得到当前字符的首字节</li>
</ol>
<h2 id="Java-中需要编码的场景"><a href="#Java-中需要编码的场景" class="headerlink" title="Java 中需要编码的场景"></a>Java 中需要编码的场景</h2><p>前面描述了常见的几种编码格式，下面将介绍 Java 中如何处理对编码的支持，什么场合中需要编码。</p>
<h3 id="I-O-操作中存在的编码"><a href="#I-O-操作中存在的编码" class="headerlink" title="I/O 操作中存在的编码"></a>I/O 操作中存在的编码</h3><p>我们知道涉及到编码的地方一般都在字符到字节或者字节到字符的转换上，而需要这种转换的场景主要是在 I/O 的时候，这个 I/O 包括磁盘 I/O 和网络 I/O，关于网络 I/O 部分在后面将主要以 Web 应用为例介绍。下图是 Java 中处理 I/O 问题的接口：</p>
<h5 id=""><a href="#" class="headerlink" title=""></a><img data-src="https://cdn.javacodes.cn/files/2016/07/2016-07-05_04-01-41.png" alt="Figure xxx. Requires a heading"></h5><p>Reader 类是 Java 的 I/O 中读字符的父类，而 InputStream 类是读字节的父类，InputStreamReader 类就是关联字节到字符的桥梁，它负责在 I/O 过程中处理读取字节到字符的转换，而具体字节到字符的解码实现它由 StreamDecoder 去实现，在 StreamDecoder 解码过程中必须由用户指定 Charset 编码格式。值得注意的是如果你没有指定 Charset，将使用本地环境中的默认字符集，例如在中文环境中将使用 GBK 编码。 写的情况也是类似，字符的父类是 Writer，字节的父类是 OutputStream，通过 OutputStreamWriter 转换字符到字节。如下图所示：</p>
<h5 id="-1"><a href="#-1" class="headerlink" title=""></a><img data-src="https://cdn.javacodes.cn/files/2016/07/2016-07-05_04-01-43.png" alt="Figure xxx. Requires a heading"></h5><p>同样 StreamEncoder 类负责将字符编码成字节，编码格式和默认编码规则与解码是一致的。 如下面一段代码，实现了文件的读写功能：</p>
<h5 id="清单-1-I-O-涉及的编码示例"><a href="#清单-1-I-O-涉及的编码示例" class="headerlink" title="清单 1.I/O 涉及的编码示例"></a>清单 1.I/O 涉及的编码示例</h5><p> String file = “c:/stream.txt”;<br> String charset = “UTF-8”;<br> // 写字符换转成字节流<br> FileOutputStream outputStream = new FileOutputStream(file);<br> OutputStreamWriter writer = new OutputStreamWriter(<br> outputStream, charset);<br> try {<br>    writer.write(“这是要保存的中文字符”);<br> } finally {<br>    writer.close();<br> }<br> // 读取字节转换成字符<br> FileInputStream inputStream = new FileInputStream(file);<br> InputStreamReader reader = new InputStreamReader(<br> inputStream, charset);<br> StringBuffer buffer = new StringBuffer();<br> char[] buf = new char[64];<br> int count = 0;<br> try {<br>    while ((count = reader.read(buf)) != -1) {<br>        buffer.append(buffer, 0, count);<br>    }<br> } finally {<br>    reader.close();<br> }</p>
<p>在我们的应用程序中涉及到 I/O 操作时只要注意指定统一的编解码 Charset 字符集，一般不会出现乱码问题，有些应用程序如果不注意指定字符编码，中文环境中取操作系统默认编码，如果编解码都在中文环境中，通常也没问题，但是还是强烈的不建议使用操作系统的默认编码，因为这样，你的应用程序的编码格式就和运行环境绑定起来了，在跨环境下很可能出现乱码问题。  </p>
<h3 id="内存中操作中的编码"><a href="#内存中操作中的编码" class="headerlink" title="内存中操作中的编码"></a>内存中操作中的编码</h3><p>在 Java 开发中除了 I/O 涉及到编码外，最常用的应该就是在内存中进行字符到字节的数据类型的转换，Java 中用 String 表示字符串，所以 String 类就提供转换到字节的方法，也支持将字节转换为字符串的构造函数。如下代码示例：</p>
<p> String s = “这是一段中文字符串”;<br> byte[] b = s.getBytes(“UTF-8”);<br> String n = new String(b,”UTF-8”);</p>
<p>另外一个是已经被被废弃的 ByteToCharConverter 和 CharToByteConverter 类，它们分别提供了 convertAll 方法可以实现 byte[] 和 char[] 的互转。如下代码所示：</p>
<p> ByteToCharConverter charConverter = ByteToCharConverter.getConverter(“UTF-8”);<br> char c[] = charConverter.convertAll(byteArray);<br> CharToByteConverter byteConverter = CharToByteConverter.getConverter(“UTF-8”);<br> byte[] b = byteConverter.convertAll(c);</p>
<p>这两个类已经被 Charset 类取代，Charset 提供 encode 与 decode 分别对应 char[] 到 byte[] 的编码和 byte[] 到 char[] 的解码。如下代码所示：</p>
<p> Charset charset = Charset.forName(“UTF-8”);<br> ByteBuffer byteBuffer = charset.encode(string);<br> CharBuffer charBuffer = charset.decode(byteBuffer);</p>
<p>编码与解码都在一个类中完成，通过 forName 设置编解码字符集，这样更容易统一编码格式，比 ByteToCharConverter 和 CharToByteConverter 类更方便。 Java 中还有一个 ByteBuffer 类，它提供一种 char 和 byte 之间的软转换，它们之间转换不需要编码与解码，只是把一个 16bit 的 char 格式，拆分成为 2 个 8bit 的 byte 表示，它们的实际值并没有被修改，仅仅是数据的类型做了转换。如下代码所以：</p>
<p> ByteBuffer heapByteBuffer = ByteBuffer.allocate(1024);<br> ByteBuffer byteBuffer = heapByteBuffer.putChar(c);</p>
<p>以上这些提供字符和字节之间的相互转换只要我们设置编解码格式统一一般都不会出现问题。  </p>
<h2 id="Java-中如何编解码"><a href="#Java-中如何编解码" class="headerlink" title="Java 中如何编解码"></a>Java 中如何编解码</h2><p>前面介绍了几种常见的编码格式，这里将以实际例子介绍 Java 中如何实现编码及解码，下面我们以“I am 君山”这个字符串为例介绍 Java 中如何把它以 ISO-8859-1、GB2312、GBK、UTF-16、UTF-8 编码格式进行编码的。</p>
<h5 id="清单-2-String-编码"><a href="#清单-2-String-编码" class="headerlink" title="清单 2.String 编码"></a>清单 2.String 编码</h5><p> public static void encode() {<br>        String name = “I am 君山”;<br>        toHex(name.toCharArray());<br>        try {<br>            byte[] iso8859 = name.getBytes(“ISO-8859-1”);<br>            toHex(iso8859);<br>            byte[] gb2312 = name.getBytes(“GB2312”);<br>            toHex(gb2312);<br>            byte[] gbk = name.getBytes(“GBK”);<br>            toHex(gbk);<br>            byte[] utf16 = name.getBytes(“UTF-16”);<br>            toHex(utf16);<br>            byte[] utf8 = name.getBytes(“UTF-8”);<br>            toHex(utf8);<br>        } catch (UnsupportedEncodingException e) {<br>            e.printStackTrace();<br>        }<br> }</p>
<p>我们把 name 字符串按照前面说的几种编码格式进行编码转化成 byte 数组，然后以 16 进制输出，我们先看一下 Java 是如何进行编码的。 下面是 Java 中编码需要用到的类图</p>
<h5 id="图-1-Java-编码类图"><a href="#图-1-Java-编码类图" class="headerlink" title="图 1. Java 编码类图"></a>图 1. Java 编码类图</h5><p><img data-src="https://cdn.javacodes.cn/files/2016/07/2016-07-05_04-01-44.jpg" alt="图 1. Java 编码类图"> 首先根据指定的 charsetName 通过 Charset.forName(charsetName) 设置 Charset 类，然后根据 Charset 创建 CharsetEncoder 对象，再调用 CharsetEncoder.encode 对字符串进行编码，不同的编码类型都会对应到一个类中，实际的编码过程是在这些类中完成的。下面是 String. getBytes(charsetName) 编码过程的时序图</p>
<h5 id="图-2-Java-编码时序图"><a href="#图-2-Java-编码时序图" class="headerlink" title="图 2.Java 编码时序图"></a>图 2.Java 编码时序图</h5><p><img data-src="https://cdn.javacodes.cn/files/2016/07/2016-07-05_04-01-46.jpg" alt="图 2.Java 编码时序图"> 从上图可以看出根据 charsetName 找到 Charset 类，然后根据这个字符集编码生成 CharsetEncoder，这个类是所有字符编码的父类，针对不同的字符编码集在其子类中定义了如何实现编码，有了 CharsetEncoder 对象后就可以调用 encode 方法去实现编码了。这个是 String.getBytes 编码方法，其它的如 StreamEncoder 中也是类似的方式。下面看看不同的字符集是如何将前面的字符串编码成 byte 数组的？ 如字符串“I am 君山”的 char 数组为 49 20 61 6d 20 541b 5c71，下面把它按照不同的编码格式转化成相应的字节。</p>
<h3 id="按照-ISO-8859-1-编码"><a href="#按照-ISO-8859-1-编码" class="headerlink" title="按照 ISO-8859-1 编码"></a>按照 ISO-8859-1 编码</h3><p>字符串“I am 君山”用 ISO-8859-1 编码，下面是编码结果：</p>
<h5 id="-2"><a href="#-2" class="headerlink" title=""></a><img data-src="https://cdn.javacodes.cn/files/2016/07/2016-07-05_04-01-48.gif" alt="Figure xxx. Requires a heading"></h5><p>从上图看出 7 个 char 字符经过 ISO-8859-1 编码转变成 7 个 byte 数组，ISO-8859-1 是单字节编码，中文“君山”被转化成值是 3f 的 byte。3f 也就是“？”字符，所以经常会出现中文变成“？”很可能就是错误的使用了 ISO-8859-1 这个编码导致的。中文字符经过 ISO-8859-1 编码会丢失信息，通常我们称之为“黑洞”，它会把不认识的字符吸收掉。由于现在大部分基础的 Java 框架或系统默认的字符集编码都是 ISO-8859-1，所以很容易出现乱码问题，后面将会分析不同的乱码形式是怎么出现的。</p>
<h3 id="按照-GB2312-编码"><a href="#按照-GB2312-编码" class="headerlink" title="按照 GB2312 编码"></a>按照 GB2312 编码</h3><p>字符串“I am 君山”用 GB2312 编码，下面是编码结果：</p>
<h5 id="-3"><a href="#-3" class="headerlink" title=""></a><img data-src="https://cdn.javacodes.cn/files/2016/07/2016-07-05_04-01-49.gif" alt="Figure xxx. Requires a heading"></h5><p>GB2312 对应的 Charset 是 sun.nio.cs.ext. EUC_CN 而对应的 CharsetDecoder 编码类是 sun.nio.cs.ext. DoubleByte，GB2312 字符集有一个 char 到 byte 的码表，不同的字符编码就是查这个码表找到与每个字符的对应的字节，然后拼装成 byte 数组。查表的规则如下：</p>
<p> c2b[c2bIndex[char &gt;&gt; 8] + (char &amp; 0xff)]</p>
<p>如果查到的码位值大于 oxff 则是双字节，否则是单字节。双字节高 8 位作为第一个字节，低 8 位作为第二个字节，如下代码所示：</p>
<p> if (bb &gt; 0xff) {    // DoubleByte<br>            if (dl - dp &lt; 2)<br>                return CoderResult.OVERFLOW;<br>            da[dp++] = (byte) (bb &gt;&gt; 8);<br>            da[dp++] = (byte) bb;<br> } else {                      // SingleByte<br>            if (dl - dp &lt; 1)<br>                return CoderResult.OVERFLOW;<br>            da[dp++] = (byte) bb;<br> }</p>
<p>从上图可以看出前 5 个字符经过编码后仍然是 5 个字节，而汉字被编码成双字节，在第一节中介绍到 GB2312 只支持 6763 个汉字，所以并不是所有汉字都能够用 GB2312 编码。</p>
<h3 id="按照-GBK-编码"><a href="#按照-GBK-编码" class="headerlink" title="按照 GBK 编码"></a>按照 GBK 编码</h3><p>字符串“I am 君山”用 GBK 编码，下面是编码结果：</p>
<h5 id="-4"><a href="#-4" class="headerlink" title=""></a><img data-src="https://cdn.javacodes.cn/files/2016/07/2016-07-05_04-01-51.gif" alt="Figure xxx. Requires a heading"></h5><p>你可能已经发现上图与 GB2312 编码的结果是一样的，没错 GBK 与 GB2312 编码结果是一样的，由此可以得出 GBK 编码是兼容 GB2312 编码的，它们的编码算法也是一样的。不同的是它们的码表长度不一样，GBK 包含的汉字字符更多。所以只要是经过 GB2312 编码的汉字都可以用 GBK 进行解码，反过来则不然。</p>
<h3 id="按照-UTF-16-编码"><a href="#按照-UTF-16-编码" class="headerlink" title="按照 UTF-16 编码"></a>按照 UTF-16 编码</h3><p>字符串“I am 君山”用 UTF-16 编码，下面是编码结果：</p>
<h5 id="-5"><a href="#-5" class="headerlink" title=""></a><img data-src="https://cdn.javacodes.cn/files/2016/07/2016-07-05_04-01-53.gif" alt="Figure xxx. Requires a heading"></h5><p>用 UTF-16 编码将 char 数组放大了一倍，单字节范围内的字符，在高位补 0 变成两个字节，中文字符也变成两个字节。从 UTF-16 编码规则来看，仅仅将字符的高位和地位进行拆分变成两个字节。特点是编码效率非常高，规则很简单，由于不同处理器对 2 字节处理方式不同，Big-endian（高位字节在前，低位字节在后）或 Little-endian（低位字节在前，高位字节在后）编码，所以在对一串字符串进行编码是需要指明到底是 Big-endian 还是 Little-endian，所以前面有两个字节用来保存 BYTE_ORDER_MARK 值，UTF-16 是用定长 16 位（2 字节）来表示的 UCS-2 或 Unicode 转换格式，通过代理对来访问 BMP 之外的字符编码。</p>
<h3 id="按照-UTF-8-编码"><a href="#按照-UTF-8-编码" class="headerlink" title="按照 UTF-8 编码"></a>按照 UTF-8 编码</h3><p>字符串“I am 君山”用 UTF-8 编码，下面是编码结果：</p>
<h5 id="-6"><a href="#-6" class="headerlink" title=""></a><img data-src="https://cdn.javacodes.cn/files/2016/07/2016-07-05_04-01-54.gif" alt="Figure xxx. Requires a heading"></h5><p>UTF-16 虽然编码效率很高，但是对单字节范围内字符也放大了一倍，这无形也浪费了存储空间，另外 UTF-16 采用顺序编码，不能对单个字符的编码值进行校验，如果中间的一个字符码值损坏，后面的所有码值都将受影响。而 UTF-8 这些问题都不存在，UTF-8 对单字节范围内字符仍然用一个字节表示，对汉字采用三个字节表示。它的编码规则如下：</p>
<h5 id="清单-3-UTF-8-编码代码片段"><a href="#清单-3-UTF-8-编码代码片段" class="headerlink" title="清单 3.UTF-8 编码代码片段"></a>清单 3.UTF-8 编码代码片段</h5><p> private CoderResult encodeArrayLoop(CharBuffer src,<br> ByteBuffer dst){<br>            char[] sa = src.array();<br>            int sp = src.arrayOffset() + src.position();<br>            int sl = src.arrayOffset() + src.limit();<br>            byte[] da = dst.array();<br>            int dp = dst.arrayOffset() + dst.position();<br>            int dl = dst.arrayOffset() + dst.limit();<br>            int dlASCII = dp + Math.min(sl - sp, dl - dp);<br>            // ASCII only loop<br>            while (dp &lt; dlASCII &amp;&amp; sa[sp] &lt; ‘u0080’)<br>                da[dp++] = (byte) sa[sp++];<br>            while (sp &lt; sl) {<br>                char c = sa[sp];<br>                if (c &lt; 0x80) {<br>                    // Have at most seven bits<br>                    if (dp &gt;= dl)<br>                        return overflow(src, sp, dst, dp);<br>                    da[dp++] = (byte)c;<br>                } else if (c &lt; 0x800) {<br>                    // 2 bytes, 11 bits<br>                    if (dl - dp &lt; 2)<br>                        return overflow(src, sp, dst, dp);<br>                    da[dp++] = (byte)(0xc0 | (c &gt;&gt; 6));<br>                    da[dp++] = (byte)(0x80 | (c &amp; 0x3f));<br>                } else if (Character.isSurrogate(c)) {<br>                    // Have a surrogate pair<br>                    if (sgp == null)<br>                        sgp = new Surrogate.Parser();<br>                    int uc = sgp.parse(c, sa, sp, sl);<br>                    if (uc &lt; 0) {<br>                        updatePositions(src, sp, dst, dp);<br>                        return sgp.error();<br>                    }<br>                    if (dl - dp &lt; 4)<br>                        return overflow(src, sp, dst, dp);<br>                    da[dp++] = (byte)(0xf0 | ((uc &gt;&gt; 18)));<br>                    da[dp++] = (byte)(0x80 | ((uc &gt;&gt; 12) &amp; 0x3f));<br>                    da[dp++] = (byte)(0x80 | ((uc &gt;&gt;  6) &amp; 0x3f));<br>                    da[dp++] = (byte)(0x80 | (uc &amp; 0x3f));<br>                    sp++;  // 2 chars<br>                } else {<br>                    // 3 bytes, 16 bits<br>                    if (dl - dp &lt; 3)<br>                        return overflow(src, sp, dst, dp);<br>                    da[dp++] = (byte)(0xe0 | ((c &gt;&gt; 12)));<br>                    da[dp++] = (byte)(0x80 | ((c &gt;&gt;  6) &amp; 0x3f));<br>                    da[dp++] = (byte)(0x80 | (c &amp; 0x3f));<br>                }<br>                sp++;<br>            }<br>            updatePositions(src, sp, dst, dp);<br>            return CoderResult.UNDERFLOW;<br> }</p>
<p>UTF-8 编码与 GBK 和 GB2312 不同，不用查码表，所以在编码效率上 UTF-8 的效率会更好，所以在存储中文字符时 UTF-8 编码比较理想。</p>
<h3 id="几种编码格式的比较"><a href="#几种编码格式的比较" class="headerlink" title="几种编码格式的比较"></a>几种编码格式的比较</h3><p>对中文字符后面四种编码格式都能处理，GB2312 与 GBK 编码规则类似，但是 GBK 范围更大，它能处理所有汉字字符，所以 GB2312 与 GBK 比较应该选择 GBK。UTF-16 与 UTF-8 都是处理 Unicode 编码，它们的编码规则不太相同，相对来说 UTF-16 编码效率最高，字符到字节相互转换更简单，进行字符串操作也更好。它适合在本地磁盘和内存之间使用，可以进行字符和字节之间快速切换，如 Java 的内存编码就是采用 UTF-16 编码。但是它不适合在网络之间传输，因为网络传输容易损坏字节流，一旦字节流损坏将很难恢复，想比较而言 UTF-8 更适合网络传输，对 ASCII 字符采用单字节存储，另外单个字符损坏也不会影响后面其它字符，在编码效率上介于 GBK 和 UTF-16 之间，所以 UTF-8 在编码效率上和编码安全性上做了平衡，是理想的中文编码方式。</p>
<h2 id="Java-Web-涉及到的编码"><a href="#Java-Web-涉及到的编码" class="headerlink" title="Java Web 涉及到的编码"></a>Java Web 涉及到的编码</h2><p>对于使用中文来说，有 I/O 的地方就会涉及到编码，前面已经提到了 I/O 操作会引起编码，而大部分 I/O 引起的乱码都是网络 I/O，因为现在几乎所有的应用程序都涉及到网络操作，而数据经过网络传输都是以字节为单位的，所以所有的数据都必须能够被序列化为字节。在 Java 中数据被序列化必须继承 Serializable 接口。 这里有一个问题，你是否认真考虑过一段文本它的实际大小应该怎么计算，我曾经碰到过一个问题：就是要想办法压缩 Cookie 大小，减少网络传输量，当时有选择不同的压缩算法，发现压缩后字符数是减少了，但是并没有减少字节数。所谓的压缩只是将多个单字节字符通过编码转变成一个多字节字符。减少的是 String.length()，而并没有减少最终的字节数。例如将“ab”两个字符通过某种编码转变成一个奇怪的字符，虽然字符数从两个变成一个，但是如果采用 UTF-8 编码这个奇怪的字符最后经过编码可能又会变成三个或更多的字节。同样的道理比如整型数字 1234567 如果当成字符来存储，采用 UTF-8 来编码占用 7 个 byte，采用 UTF-16 编码将会占用 14 个 byte，但是把它当成 int 型数字来存储只需要 4 个 byte 来存储。所以看一段文本的大小，看字符本身的长度是没有意义的，即使是一样的字符采用不同的编码最终存储的大小也会不同，所以从字符到字节一定要看编码类型。 另外一个问题，你是否考虑过，当我们在电脑中某个文本编辑器里输入某个汉字时，它到底是怎么表示的？我们知道，计算机里所有的信息都是以 01 表示的，那么一个汉字，它到底是多少个 0 和 1 呢？我们能够看到的汉字都是以字符形式出现的，例如在 Java 中“淘宝”两个字符，它在计算机中的数值 10 进制是 28120 和 23453，16 进制是 6bd8 和 5d9d，也就是这两个字符是由这两个数字唯一表示的。Java 中一个 char 是 16 个 bit 相当于两个字节，所以两个汉字用 char 表示在内存中占用相当于四个字节的空间。 这两个问题搞清楚后，我们看一下 Java Web 中那些地方可能会存在编码转换？ 用户从浏览器端发起一个 HTTP 请求，需要存在编码的地方是 URL、Cookie、Parameter。服务器端接受到 HTTP 请求后要解析 HTTP 协议，其中 URI、Cookie 和 POST 表单参数需要解码，服务器端可能还需要读取数据库中的数据，本地或网络中其它地方的文本文件，这些数据都可能存在编码问题，当 Servlet 处理完所有请求的数据后，需要将这些数据再编码通过 Socket 发送到用户请求的浏览器里，再经过浏览器解码成为文本。这些过程如下图所示：</p>
<h5 id="图-3-一次-HTTP-请求的编码示例"><a href="#图-3-一次-HTTP-请求的编码示例" class="headerlink" title="图 3. 一次 HTTP 请求的编码示例"></a>图 3. 一次 HTTP 请求的编码示例</h5><p><img data-src="https://cdn.javacodes.cn/files/2016/07/2016-07-05_04-01-56.gif" alt="图 3. 一次 HTTP 请求的编码示例"> 如上图所示一次 HTTP 请求设计到很多地方需要编解码，它们编解码的规则是什么？下面将会重点阐述一下：</p>
<h3 id="URL-的编解码"><a href="#URL-的编解码" class="headerlink" title="URL 的编解码"></a>URL 的编解码</h3><p>用户提交一个 URL，这个 URL 中可能存在中文，因此需要编码，如何对这个 URL 进行编码？根据什么规则来编码？有如何来解码？如下图一个 URL：</p>
<h5 id="图-4-URL-的几个组成部分"><a href="#图-4-URL-的几个组成部分" class="headerlink" title="图 4.URL 的几个组成部分"></a>图 4.URL 的几个组成部分</h5><p><img data-src="https://cdn.javacodes.cn/files/2016/07/2016-07-05_04-01-57.gif" alt="图 4.URL 的几个组成部分"> 上图中以 Tomcat 作为 Servlet Engine 为例，它们分别对应到下面这些配置文件中： Port 对应在 Tomcat 的 <Connector port="8080"/> 中配置，而 Context Path 在 <Context path="/examples"/> 中配置，Servlet Path 在 Web 应用的 web.xml 中的</p>
 <servlet-mapping> 
        <servlet-name>junshanExample</servlet-name> 
        <url-pattern>/servlets/servlet/*</url-pattern> 
 </servlet-mapping>

<p><url-pattern> 中配置，PathInfo 是我们请求的具体的 Servlet，QueryString 是要传递的参数，注意这里是在浏览器里直接输入 URL 所以是通过 Get 方法请求的，如果是 POST 方法请求的话，QueryString 将通过表单方式提交到服务器端，这个将在后面再介绍。 上图中 PathInfo 和 QueryString 出现了中文，当我们在浏览器中直接输入这个 URL 时，在浏览器端和服务端会如何编码和解析这个 URL 呢？为了验证浏览器是怎么编码 URL 的我们选择 FireFox 浏览器并通过 HTTPFox 插件观察我们请求的 URL 的实际的内容，以下是 URL：HTTP://localhost:8080/examples/servlets/servlet/ 君山 ?author= 君山在中文 FireFox3.6.12 的测试结果</p>
<h5 id="图-5-HTTPFox-的测试结果"><a href="#图-5-HTTPFox-的测试结果" class="headerlink" title="图 5. HTTPFox 的测试结果"></a>图 5. HTTPFox 的测试结果</h5><p><img data-src="https://cdn.javacodes.cn/files/2016/07/2016-07-05_04-01-59.jpg" alt="图 5. HTTPFox 的测试结果"> 君山的编码结果分别是：e5 90 9b e5 b1 b1，be fd c9 bd，查阅上一届的编码可知，PathInfo 是 UTF-8 编码而 QueryString 是经过 GBK 编码，至于为什么会有“%”？查阅 URL 的编码规范 RFC3986 可知浏览器编码 URL 是将非 ASCII 字符按照某种编码格式编码成 16 进制数字然后将每个 16 进制表示的字节前加上“%”，所以最终的 URL 就成了上图的格式了。 默认情况下中文 IE 最终的编码结果也是一样的，不过 IE 浏览器可以修改 URL 的编码格式在选项 -&gt; 高级 -&gt; 国际里面的发送 UTF-8 URL 选项可以取消。 从上面测试结果可知浏览器对 PathInfo 和 QueryString 的编码是不一样的，不同浏览器对 PathInfo 也可能不一样，这就对服务器的解码造成很大的困难，下面我们以 Tomcat 为例看一下，Tomcat 接受到这个 URL 是如何解码的。 解析请求的 URL 是在 org.apache.coyote.HTTP11.InternalInputBuffer 的 parseRequestLine 方法中，这个方法把传过来的 URL 的 byte[] 设置到 org.apache.coyote.Request 的相应的属性中。这里的 URL 仍然是 byte 格式，转成 char 是在 org.apache.catalina.connector.CoyoteAdapter 的 convertURI 方法中完成的：</p>
<p> protected void convertURI(MessageBytes uri, Request request)<br> throws Exception {<br>        ByteChunk bc = uri.getByteChunk();<br>        int length = bc.getLength();<br>        CharChunk cc = uri.getCharChunk();<br>        cc.allocate(length, -1);<br>        String enc = connector.getURIEncoding();<br>        if (enc != null) {<br>            B2CConverter conv = request.getURIConverter();<br>            try {<br>                if (conv == null) {<br>                    conv = new B2CConverter(enc);<br>                    request.setURIConverter(conv);<br>                }<br>            } catch (IOException e) {…}<br>            if (conv != null) {<br>                try {<br>                    conv.convert(bc, cc, cc.getBuffer().length -<br> cc.getEnd());<br>                    uri.setChars(cc.getBuffer(), cc.getStart(),<br> cc.getLength());<br>                    return;<br>                } catch (IOException e) {…}<br>            }<br>        }<br>        // Default encoding: fast conversion<br>        byte[] bbuf = bc.getBuffer();<br>        char[] cbuf = cc.getBuffer();<br>        int start = bc.getStart();<br>        for (int i = 0; i &lt; length; i++) {<br>            cbuf[i] = (char) (bbuf[i + start] &amp; 0xff);<br>        }<br>        uri.setChars(cbuf, 0, length);<br> }</p>
<p>从上面的代码中可以知道对 URL 的 URI 部分进行解码的字符集是在 connector 的 <Connector URIEncoding=”UTF-8”/> 中定义的，如果没有定义，那么将以默认编码 ISO-8859-1 解析。所以如果有中文 URL 时最好把 URIEncoding 设置成 UTF-8 编码。 QueryString 又如何解析？ GET 方式 HTTP 请求的 QueryString 与 POST 方式 HTTP 请求的表单参数都是作为 Parameters 保存，都是通过 request.getParameter 获取参数值。对它们的解码是在 request.getParameter 方法第一次被调用时进行的。request.getParameter 方法被调用时将会调用 org.apache.catalina.connector.Request 的 parseParameters 方法。这个方法将会对 GET 和 POST 方式传递的参数进行解码，但是它们的解码字符集有可能不一样。POST 表单的解码将在后面介绍，QueryString 的解码字符集是在哪定义的呢？它本身是通过 HTTP 的 Header 传到服务端的，并且也在 URL 中，是否和 URI 的解码字符集一样呢？从前面浏览器对 PathInfo 和 QueryString 的编码采取不同的编码格式不同可以猜测到解码字符集肯定也不会是一致的。的确是这样 QueryString 的解码字符集要么是 Header 中 ContentType 中定义的 Charset 要么就是默认的 ISO-8859-1，要使用 ContentType 中定义的编码就要设置 connector 的 <Connector URIEncoding=”UTF-8” useBodyEncodingForURI=”true”/> 中的 useBodyEncodingForURI 设置为 true。这个配置项的名字有点让人产生混淆，它并不是对整个 URI 都采用 BodyEncoding 进行解码而仅仅是对 QueryString 使用 BodyEncoding 解码，这一点还要特别注意。 从上面的 URL 编码和解码过程来看，比较复杂，而且编码和解码并不是我们在应用程序中能完全控制的，所以在我们的应用程序中应该尽量避免在 URL 中使用非 ASCII 字符，不然很可能会碰到乱码问题，当然在我们的服务器端最好设置 <Connector/> 中的 URIEncoding 和 useBodyEncodingForURI 两个参数。</p>
<h3 id="HTTP-Header-的编解码"><a href="#HTTP-Header-的编解码" class="headerlink" title="HTTP Header 的编解码"></a>HTTP Header 的编解码</h3><p>当客户端发起一个 HTTP 请求除了上面的 URL 外还可能会在 Header 中传递其它参数如 Cookie、redirectPath 等，这些用户设置的值很可能也会存在编码问题，Tomcat 对它们又是怎么解码的呢？ 对 Header 中的项进行解码也是在调用 request.getHeader 是进行的，如果请求的 Header 项没有解码则调用 MessageBytes 的 toString 方法，这个方法将从 byte 到 char 的转化使用的默认编码也是 ISO-8859-1，而我们也不能设置 Header 的其它解码格式，所以如果你设置 Header 中有非 ASCII 字符解码肯定会有乱码。 我们在添加 Header 时也是同样的道理，不要在 Header 中传递非 ASCII 字符，如果一定要传递的话，我们可以先将这些字符用 org.apache.catalina.util.URLEncoder 编码然后再添加到 Header 中，这样在浏览器到服务器的传递过程中就不会丢失信息了，如果我们要访问这些项时再按照相应的字符集解码就好了。</p>
<h3 id="POST-表单的编解码"><a href="#POST-表单的编解码" class="headerlink" title="POST 表单的编解码"></a>POST 表单的编解码</h3><p>在前面提到了 POST 表单提交的参数的解码是在第一次调用 request.getParameter 发生的，POST 表单参数传递方式与 QueryString 不同，它是通过 HTTP 的 BODY 传递到服务端的。当我们在页面上点击 submit 按钮时浏览器首先将根据 ContentType 的 Charset 编码格式对表单填的参数进行编码然后提交到服务器端，在服务器端同样也是用 ContentType 中字符集进行解码。所以通过 POST 表单提交的参数一般不会出现问题，而且这个字符集编码是我们自己设置的，可以通过 request.setCharacterEncoding(charset) 来设置。 另外针对 multipart/form-data 类型的参数，也就是上传的文件编码同样也是使用 ContentType 定义的字符集编码，值得注意的地方是上传文件是用字节流的方式传输到服务器的本地临时目录，这个过程并没有涉及到字符编码，而真正编码是在将文件内容添加到 parameters 中，如果用这个编码不能编码时将会用默认编码 ISO-8859-1 来编码。</p>
<h3 id="HTTP-BODY-的编解码"><a href="#HTTP-BODY-的编解码" class="headerlink" title="HTTP BODY 的编解码"></a>HTTP BODY 的编解码</h3><p>当用户请求的资源已经成功获取后，这些内容将通过 Response 返回给客户端浏览器，这个过程先要经过编码再到浏览器进行解码。这个过程的编解码字符集可以通过 response.setCharacterEncoding 来设置，它将会覆盖 request.getCharacterEncoding 的值，并且通过 Header 的 Content-Type 返回客户端，浏览器接受到返回的 socket 流时将通过 Content-Type 的 charset 来解码，如果返回的 HTTP Header 中 Content-Type 没有设置 charset，那么浏览器将根据 Html 的 <meta HTTP-equiv="Content-Type" content="text/html; charset=GBK" /> 中的 charset 来解码。如果也没有定义的话，那么浏览器将使用默认的编码来解码。</p>
<h3 id="其它需要编码的地方"><a href="#其它需要编码的地方" class="headerlink" title="其它需要编码的地方"></a>其它需要编码的地方</h3><p>除了 URL 和参数编码问题外，在服务端还有很多地方可能存在编码，如可能需要读取 xml、velocity 模版引擎、JSP 或者从数据库读取数据等。 xml 文件可以通过设置头来制定编码格式</p>
 <?xml version="1.0" encoding="UTF-8"?>

<p>Velocity 模版设置编码格式：</p>
<p> services.VelocityService.input.encoding=UTF-8</p>
<p>JSP 设置编码格式：</p>
<p> &lt;%@page contentType=”text/html; charset=UTF-8”%&gt;</p>
<p>访问数据库都是通过客户端 JDBC 驱动来完成，用 JDBC 来存取数据要和数据的内置编码保持一致，可以通过设置 JDBC URL 来制定如 MySQL：url=”jdbc:mysql://localhost:3306/DB?useUnicode=true&amp;characterEncoding=GBK”。</p>
<h2 id="常见问题分析"><a href="#常见问题分析" class="headerlink" title="常见问题分析"></a>常见问题分析</h2><p>在了解了 Java Web 中可能需要编码的地方后，下面看一下，当我们碰到一些乱码时，应该怎么处理这些问题？出现乱码问题唯一的原因都是在 char 到 byte 或 byte 到 char 转换中编码和解码的字符集不一致导致的，由于往往一次操作涉及到多次编解码，所以出现乱码时很难查找到底是哪个环节出现了问题，下面就几种常见的现象进行分析。</p>
<h3 id="中文变成了看不懂的字符"><a href="#中文变成了看不懂的字符" class="headerlink" title="中文变成了看不懂的字符"></a>中文变成了看不懂的字符</h3><p>例如，字符串“淘！我喜欢！”变成了“Ì Ô £ ¡Î Ò Ï²»¶ £ ¡”编码过程如下图所示</p>
<h5 id="-7"><a href="#-7" class="headerlink" title=""></a><img data-src="https://cdn.javacodes.cn/files/2016/07/2016-07-05_04-02-01.gif" alt="Figure xxx. Requires a heading"></h5><p>字符串在解码时所用的字符集与编码字符集不一致导致汉字变成了看不懂的乱码，而且是一个汉字字符变成两个乱码字符。</p>
<h3 id="一个汉字变成一个问号"><a href="#一个汉字变成一个问号" class="headerlink" title="一个汉字变成一个问号"></a>一个汉字变成一个问号</h3><p>例如，字符串“淘！我喜欢！”变成了“？？？？？？”编码过程如下图所示</p>
<h5 id="-8"><a href="#-8" class="headerlink" title=""></a><img data-src="https://cdn.javacodes.cn/files/2016/07/2016-07-05_04-02-03.gif" alt="Figure xxx. Requires a heading"></h5><p>将中文和中文符号经过不支持中文的 ISO-8859-1 编码后，所有字符变成了“？”，这是因为用 ISO-8859-1 进行编解码时遇到不在码值范围内的字符时统一用 3f 表示，这也就是通常所说的“黑洞”，所有 ISO-8859-1 不认识的字符都变成了“？”。  </p>
<h3 id="一个汉字变成两个问号"><a href="#一个汉字变成两个问号" class="headerlink" title="一个汉字变成两个问号"></a>一个汉字变成两个问号</h3><p>例如，字符串“淘！我喜欢！”变成了“？？？？？？？？？？？？”编码过程如下图所示</p>
<h5 id="-9"><a href="#-9" class="headerlink" title=""></a><img data-src="https://cdn.javacodes.cn/files/2016/07/2016-07-05_04-02-05.gif" alt="Figure xxx. Requires a heading"></h5><p>这种情况比较复杂，中文经过多次编码，但是其中有一次编码或者解码不对仍然会出现中文字符变成“？”现象，出现这种情况要仔细查看中间的编码环节，找出出现编码错误的地方。  </p>
<h3 id="一种不正常的正确编码"><a href="#一种不正常的正确编码" class="headerlink" title="一种不正常的正确编码"></a>一种不正常的正确编码</h3><p>还有一种情况是在我们通过 request.getParameter 获取参数值时，当我们直接调用</p>
<p> String value = request.getParameter(name);</p>
<p>会出现乱码，但是如果用下面的方式</p>
<p> String value = String(request.getParameter(name).getBytes(“<br> ISO-8859-1”), “GBK”);</p>
<p>解析时取得的 value 会是正确的汉字字符，这种情况是怎么造成的呢？ 看下如所示：</p>
<h5 id="-10"><a href="#-10" class="headerlink" title=""></a><img data-src="https://cdn.javacodes.cn/files/2016/07/2016-07-05_04-02-06.gif" alt="Figure xxx. Requires a heading"></h5><p>这种情况是这样的，ISO-8859-1 字符集的编码范围是 0000-00FF，正好和一个字节的编码范围相对应。这种特性保证了使用 ISO-8859-1 进行编码和解码可以保持编码数值“不变”。虽然中文字符在经过网络传输时，被错误地“拆”成了两个欧洲字符，但由于输出时也是用 ISO-8859-1，结果被“拆”开的中文字的两半又被合并在一起，从而又刚好组成了一个正确的汉字。虽然最终能取得正确的汉字，但是还是不建议用这种不正常的方式取得参数值，因为这中间增加了一次额外的编码与解码，这种情况出现乱码时因为 Tomcat 的配置文件中 useBodyEncodingForURI 配置项没有设置为”true”，从而造成第一次解析式用 ISO-8859-1 来解析才造成乱码的。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文首先总结了几种常见编码格式的区别，然后介绍了支持中文的几种编码格式，并比较了它们的使用场景。接着介绍了 Java 那些地方会涉及到编码问题，已经 Java 中如何对编码的支持。并以网络 I/O 为例重点介绍了 HTTP 请求中的存在编码的地方，以及 Tomcat 对 HTTP 协议的解析，最后分析了我们平常遇到的乱码问题出现的原因。 综上所述，要解决中文问题，首先要搞清楚哪些地方会引起字符到字节的编码以及字节到字符的解码，最常见的地方就是读取会存储数据到磁盘，或者数据要经过网络传输。然后针对这些地方搞清楚操作这些数据的框架的或系统是如何控制编码的，正确设置编码格式，避免使用软件默认的或者是操作系统平台默认的编码格式。  </p>
<blockquote>
<p><strong>来自：IBM developerWorks</strong> <strong>作者：许 令波, Java 工程师, 淘宝网</strong> <strong>链接：<a href="https://www.ibm.com/developerworks/cn/java/j-lo-chinesecoding/" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/java/j-lo-chinesecoding/</a></strong></p>
</blockquote>
]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>编码</tag>
      </tags>
  </entry>
  <entry>
    <title>深入剖析 ConcurrentHashMap</title>
    <url>/2017/03/14/%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90%20ConcurrentHashMap/</url>
    <content><![CDATA[<h3 id="术语定义"><a href="#术语定义" class="headerlink" title="术语定义"></a>术语定义</h3><p>术语</p>
<p>英文</p>
<p>解释</p>
<p>哈希算法</p>
<p>hash algorithm</p>
<p>是一种将任意内容的输入转换成相同长度输出的加密方式，其输出被称为哈希值。 </p>
<a id="more"></a>

<p>哈希表</p>
<p>hash table</p>
<p>根据设定的哈希函数H(key)和处理冲突方法将一组关键字映象到一个有限的地址区间上，并以关键字在地址区间中的象作为记录在表中的存储位置，这种表称为哈希表或散列，所得存储位置称为哈希地址或散列地址。</p>
<h3 id="线程不安全的HashMap"><a href="#线程不安全的HashMap" class="headerlink" title="线程不安全的HashMap"></a>线程不安全的HashMap</h3><p>因为多线程环境下，使用HashMap进行put操作会引起死循环，导致CPU利用率接近100%，所以在并发情况下不能使用HashMap，如以下代码</p>
<pre><code>final HashMap&lt;String, String&gt; map = new HashMap&lt;String, String&gt;(2);
Thread t = new Thread(new Runnable() {
    @Override
    public void run() {
        for (int i = 0; i &lt; 10000; i++) {
            new Thread(new Runnable() {
                @Override
                public void run() {
                    map.put(UUID.randomUUID().toString(), &quot;&quot;);
                }
            }, &quot;ftf&quot; + i).start();
        }
    }
}, &quot;ftf&quot;);
t.start();
t.join();</code></pre><h3 id="效率低下的HashTable容器"><a href="#效率低下的HashTable容器" class="headerlink" title="效率低下的HashTable容器"></a>效率低下的HashTable容器</h3><p>HashTable容器使用synchronized来保证线程安全，但在线程竞争激烈的情况下HashTable的效率非常低下。因为当一个线程访问HashTable的同步方法时，其他线程访问HashTable的同步方法时，可能会进入阻塞或轮询状态。如线程1使用put进行添加元素，线程2不但不能使用put方法添加元素，并且也不能使用get方法来获取元素，所以竞争越激烈效率越低。</p>
<h3 id="锁分段技术"><a href="#锁分段技术" class="headerlink" title="锁分段技术"></a>锁分段技术</h3><p>HashTable容器在竞争激烈的并发环境下表现出效率低下的原因是所有访问HashTable的线程都必须竞争同一把锁，那假如容器里有多把锁，每一把锁用于锁容器其中一部分数据，那么当多线程访问容器里不同数据段的数据时，线程间就不会存在锁竞争，从而可以有效的提高并发访问效率，这就是ConcurrentHashMap所使用的锁分段技术，首先将数据分成一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问。</p>
<h3 id="ConcurrentHashMap的结构"><a href="#ConcurrentHashMap的结构" class="headerlink" title="ConcurrentHashMap的结构"></a>ConcurrentHashMap的结构</h3><p>我们通过ConcurrentHashMap的类图来分析ConcurrentHashMap的结构。 <img data-src="https://cdn.javacodes.cn/files/2017/03/2017-03-14_15-20-05.jpg" alt="">￼ ConcurrentHashMap是由Segment数组结构和HashEntry数组结构组成。Segment是一种可重入锁ReentrantLock，在ConcurrentHashMap里扮演锁的角色，HashEntry则用于存储键值对数据。一个ConcurrentHashMap里包含一个Segment数组，Segment的结构和HashMap类似，是一种数组和链表结构， 一个Segment里包含一个HashEntry数组，每个HashEntry是一个链表结构的元素， 每个Segment守护者一个HashEntry数组里的元素,当对HashEntry数组的数据进行修改时，必须首先获得它对应的Segment锁。 <img data-src="https://cdn.javacodes.cn/files/2017/03/2017-03-14_15-20-04.jpg" alt="">￼</p>
<h3 id="ConcurrentHashMap的初始化"><a href="#ConcurrentHashMap的初始化" class="headerlink" title="ConcurrentHashMap的初始化"></a>ConcurrentHashMap的初始化</h3><p>ConcurrentHashMap初始化方法是通过initialCapacity，loadFactor, concurrencyLevel几个参数来初始化segments数组，段偏移量segmentShift，段掩码segmentMask和每个segment里的HashEntry数组 。 初始化segments数组。让我们来看一下初始化segmentShift，segmentMask和segments数组的源代码。</p>
<pre><code>if (concurrencyLevel &gt; MAX_SEGMENTS)
    concurrencyLevel = MAX_SEGMENTS;

// Find power-of-two sizes best matching arguments
int sshift = 0;
int ssize = 1;
while (ssize &lt; concurrencyLevel) {
    ++sshift;
    ssize &lt;&lt;= 1;
}
segmentShift = 32 - sshift;
segmentMask = ssize - 1;
this.segments = Segment.newArray(ssize);</code></pre><p>由上面的代码可知segments数组的长度ssize通过concurrencyLevel计算得出。为了能通过按位与的哈希算法来定位segments数组的索引，必须保证segments数组的长度是2的N次方（power-of-two size），所以必须计算出一个是大于或等于concurrencyLevel的最小的2的N次方值来作为segments数组的长度。假如concurrencyLevel等于14，15或16，ssize都会等于16，即容器里锁的个数也是16。注意concurrencyLevel的最大大小是65535，意味着segments数组的长度最大为65536，对应的二进制是16位。 初始化segmentShift和segmentMask。这两个全局变量在定位segment时的哈希算法里需要使用，sshift等于ssize从1向左移位的次数，在默认情况下concurrencyLevel等于16，1需要向左移位移动4次，所以sshift等于4。segmentShift用于定位参与hash运算的位数，segmentShift等于32减sshift，所以等于28，这里之所以用32是因为ConcurrentHashMap里的hash()方法输出的最大数是32位的，后面的测试中我们可以看到这点。segmentMask是哈希运算的掩码，等于ssize减1，即15，掩码的二进制各个位的值都是1。因为ssize的最大长度是65536，所以segmentShift最大值是16，segmentMask最大值是65535，对应的二进制是16位，每个位都是1。 初始化每个Segment。输入参数initialCapacity是ConcurrentHashMap的初始化容量，loadfactor是每个segment的负载因子，在构造方法里需要通过这两个参数来初始化数组中的每个segment。</p>
<pre><code>if (initialCapacity &gt; MAXIMUM_CAPACITY)
    initialCapacity = MAXIMUM_CAPACITY;
int c = initialCapacity / ssize;
if (c * ssize &lt; initialCapacity)
    ++c;
int cap = 1;
while (cap &lt; c)
    cap &lt;&lt;= 1;
for (int i = 0; i &lt; this.segments.length; ++i)
    this.segments[i] = new Segment&lt;K,V&gt;(cap, loadFactor);</code></pre><p>上面代码中的变量cap就是segment里HashEntry数组的长度，它等于initialCapacity除以ssize的倍数c，如果c大于1，就会取大于等于c的2的N次方值，所以cap不是1，就是2的N次方。segment的容量threshold＝(int)cap*loadFactor，默认情况下initialCapacity等于16，loadfactor等于0.75，通过运算cap等于1，threshold等于零。</p>
<h3 id="定位Segment"><a href="#定位Segment" class="headerlink" title="定位Segment"></a>定位Segment</h3><p>既然ConcurrentHashMap使用分段锁Segment来保护不同段的数据，那么在插入和获取元素的时候，必须先通过哈希算法定位到Segment。可以看到ConcurrentHashMap会首先使用Wang/Jenkins hash的变种算法对元素的hashCode进行一次再哈希。</p>
<pre><code>private static int hash(int h) {
        h += (h &lt;&lt; 15) ^ 0xffffcd7d;
        h ^= (h &gt;&gt;&gt; 10);
        h += (h &lt;&lt; 3);
        h ^= (h &gt;&gt;&gt; 6);
        h += (h &lt;&lt; 2) + (h &lt;&lt; 14);
        return h ^ (h &gt;&gt;&gt; 16);
    }</code></pre><p>之所以进行再哈希，其目的是为了减少哈希冲突，使元素能够均匀的分布在不同的Segment上，从而提高容器的存取效率。假如哈希的质量差到极点，那么所有的元素都在一个Segment中，不仅存取元素缓慢，分段锁也会失去意义。我做了一个测试，不通过再哈希而直接执行哈希计算。</p>
<pre><code>System.out.println(Integer.parseInt(&quot;0001111&quot;, 2) &amp; 15);
System.out.println(Integer.parseInt(&quot;0011111&quot;, 2) &amp; 15);
System.out.println(Integer.parseInt(&quot;0111111&quot;, 2) &amp; 15);
System.out.println(Integer.parseInt(&quot;1111111&quot;, 2) &amp; 15);</code></pre><p>计算后输出的哈希值全是15，通过这个例子可以发现如果不进行再哈希，哈希冲突会非常严重，因为只要低位一样，无论高位是什么数，其哈希值总是一样。我们再把上面的二进制数据进行再哈希后结果如下，为了方便阅读，不足32位的高位补了0，每隔四位用竖线分割下。</p>
<pre><code>0100｜0111｜0110｜0111｜1101｜1010｜0100｜1110
1111｜0111｜0100｜0011｜0000｜0001｜1011｜1000
0111｜0111｜0110｜1001｜0100｜0110｜0011｜1110
1000｜0011｜0000｜0000｜1100｜1000｜0001｜1010</code></pre><p>可以发现每一位的数据都散列开了，通过这种再哈希能让数字的每一位都能参加到哈希运算当中，从而减少哈希冲突。ConcurrentHashMap通过以下哈希算法定位segment。</p>
<pre><code>final Segment&lt;K,V&gt; segmentFor(int hash) {
        return segments[(hash &gt;&gt;&gt; segmentShift) &amp; segmentMask];
    }</code></pre><p>默认情况下segmentShift为28，segmentMask为15，再哈希后的数最大是32位二进制数据，向右无符号移动28位，意思是让高4位参与到hash运算中， (hash &gt;&gt;&gt; segmentShift) &amp; segmentMask的运算结果分别是4，15，7和8，可以看到hash值没有发生冲突。</p>
<h3 id="ConcurrentHashMap的get操作"><a href="#ConcurrentHashMap的get操作" class="headerlink" title="ConcurrentHashMap的get操作"></a>ConcurrentHashMap的get操作</h3><p>Segment的get操作实现非常简单和高效。先经过一次再哈希，然后使用这个哈希值通过哈希运算定位到segment，再通过哈希算法定位到元素，代码如下：</p>
<pre><code>public V get(Object key) {
    int hash = hash(key.hashCode());
    return segmentFor(hash).get(key, hash);
}</code></pre><p>get操作的高效之处在于整个get过程不需要加锁，除非读到的值是空的才会加锁重读，我们知道HashTable容器的get方法是需要加锁的，那么ConcurrentHashMap的get操作是如何做到不加锁的呢？原因是它的get方法里将要使用的共享变量都定义成volatile，如用于统计当前Segement大小的count字段和用于存储值的HashEntry的value。定义成volatile的变量，能够在线程之间保持可见性，能够被多线程同时读，并且保证不会读到过期的值，但是只能被单线程写（有一种情况可以被多线程写，就是写入的值不依赖于原值），在get操作里只需要读不需要写共享变量count和value，所以可以不用加锁。之所以不会读到过期的值，是根据java内存模型的happen before原则，对volatile字段的写入操作先于读操作，即使两个线程同时修改和获取volatile变量，get操作也能拿到最新的值，这是用volatile替换锁的经典应用场景。</p>
<pre><code>transient volatile int count;
volatile V value;</code></pre><p>在定位元素的代码里我们可以发现定位HashEntry和定位Segment的哈希算法虽然一样，都与数组的长度减去一相与，但是相与的值不一样，定位Segment使用的是元素的hashcode通过再哈希后得到的值的高位，而定位HashEntry直接使用的是再哈希后的值。其目的是避免两次哈希后的值一样，导致元素虽然在Segment里散列开了，但是却没有在HashEntry里散列开。</p>
<pre><code>hash &gt;&gt;&gt; segmentShift) &amp; segmentMask//定位Segment所使用的hash算法
int index = hash &amp; (tab.length - 1);// 定位HashEntry所使用的hash算法</code></pre><h3 id="ConcurrentHashMap的Put操作"><a href="#ConcurrentHashMap的Put操作" class="headerlink" title="ConcurrentHashMap的Put操作"></a>ConcurrentHashMap的Put操作</h3><p>由于put方法里需要对共享变量进行写入操作，所以为了线程安全，在操作共享变量时必须得加锁。Put方法首先定位到Segment，然后在Segment里进行插入操作。插入操作需要经历两个步骤，第一步判断是否需要对Segment里的HashEntry数组进行扩容，第二步定位添加元素的位置然后放在HashEntry数组里。 是否需要扩容。在插入元素前会先判断Segment里的HashEntry数组是否超过容量（threshold），如果超过阀值，数组进行扩容。值得一提的是，Segment的扩容判断比HashMap更恰当，因为HashMap是在插入元素后判断元素是否已经到达容量的，如果到达了就进行扩容，但是很有可能扩容之后没有新元素插入，这时HashMap就进行了一次无效的扩容。 如何扩容。扩容的时候首先会创建一个两倍于原容量的数组，然后将原数组里的元素进行再hash后插入到新的数组里。为了高效ConcurrentHashMap不会对整个容器进行扩容，而只对某个segment进行扩容。</p>
<h3 id="ConcurrentHashMap的size操作"><a href="#ConcurrentHashMap的size操作" class="headerlink" title="ConcurrentHashMap的size操作"></a>ConcurrentHashMap的size操作</h3><p>如果我们要统计整个ConcurrentHashMap里元素的大小，就必须统计所有Segment里元素的大小后求和。Segment里的全局变量count是一个volatile变量，那么在多线程场景下，我们是不是直接把所有Segment的count相加就可以得到整个ConcurrentHashMap大小了呢？不是的，虽然相加时可以获取每个Segment的count的最新值，但是拿到之后可能累加前使用的count发生了变化，那么统计结果就不准了。所以最安全的做法，是在统计size的时候把所有Segment的put，remove和clean方法全部锁住，但是这种做法显然非常低效。 因为在累加count操作过程中，之前累加过的count发生变化的几率非常小，所以ConcurrentHashMap的做法是先尝试2次通过不锁住Segment的方式来统计各个Segment大小，如果统计的过程中，容器的count发生了变化，则再采用加锁的方式来统计所有Segment的大小。 那么ConcurrentHashMap是如何判断在统计的时候容器是否发生了变化呢？使用modCount变量，在put , remove和clean方法里操作元素前都会将变量modCount进行加1，那么在统计size前后比较modCount是否发生变化，从而得知容器的大小是否发生变化。 参考资料</p>
<ol>
<li>JDK1.6源代码。</li>
<li>《Java并发编程实践》。</li>
<li>Java并发编程之ConcurrentHashMap 。</li>
</ol>
<blockquote>
<p>转载自<a href="http://ifeve.com/" target="_blank" rel="noopener">并发编程网 – ifeve.com</a> 本文链接地址: <a href="http://ifeve.com/concurrenthashmap/" target="_blank" rel="noopener">聊聊并发（四）深入分析ConcurrentHashMap</a></p>
</blockquote>
]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>并发</tag>
        <tag>ConcurrentHashMap</tag>
      </tags>
  </entry>
  <entry>
    <title>语雀Markdown</title>
    <url>/2020/06/07/yuque/%E8%AF%AD%E9%9B%80Markdown/</url>
    <content><![CDATA[<h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="这是一个列表"><a href="#这是一个列表" class="headerlink" title="这是一个列表"></a>这是一个列表</h3><ul>
<li>一个项目</li>
<li>两个项目</li>
</ul>
<a id="more"></a>

<h3 id="这是一段代码"><a href="#这是一段代码" class="headerlink" title="这是一段代码"></a>这是一段代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">	System.out.println(<span class="string">"hello world"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="这是一个表格"><a href="#这是一个表格" class="headerlink" title="这是一个表格"></a>这是一个表格</h3><table>
<thead>
<tr>
<th>标题</th>
<th>标题</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>2</td>
</tr>
<tr>
<td>3</td>
<td>4</td>
</tr>
</tbody></table>
<h4 id="这是四级标题"><a href="#这是四级标题" class="headerlink" title="这是四级标题"></a>这是四级标题</h4><h5 id="五级标题"><a href="#五级标题" class="headerlink" title="五级标题"></a>五级标题</h5>]]></content>
  </entry>
</search>
